[{"title":"blog43","date":"2019-07-23T08:29:53.000Z","path":"2019/07/23/blog43/","text":"","tags":[]},{"title":"巴适川渝","date":"2019-05-03T19:12:48.000Z","path":"2019/05/04/life7/","text":"巴适滴狠！ wangchloe 的 Vlog | 巴适川渝 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"爱旅游","slug":"爱旅游","permalink":"https://wangchloe.vip/tags/爱旅游/"}]},{"title":"征服宝岛～","date":"2019-03-31T19:12:48.000Z","path":"2019/04/01/life6/","text":"世界多大，老汪的脚步就迈多大！PS：🇨🇳台湾真好吃 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"爱旅游","slug":"爱旅游","permalink":"https://wangchloe.vip/tags/爱旅游/"}]},{"title":"nextTick研究报告","date":"2018-10-11T19:27:35.000Z","path":"2018/10/12/blog42/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 nextTick es5源码 关于setTimeout(fn,0) 讨论点 常用示例 1.mounted时更新 console 2.更改子组件更新时间 console 3.同时更改父组件更新时间 console 4.nextTick顺序问题 console 总结 nextTick在下次 DOM 更新循环结束之后执行延迟回调。在修改数据之后立即使用这个方法，获取更新后的 DOM。 vue这么做是因为频繁的更新dom是特别耗费性能的，所以搞了一个批处理更新，把所有的update操作放到任务队列中，等主线程中执行栈的所有同步任务执行完毕，系统就会读取任务队列。 es5源码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051/** * Defer a task to execute it asynchronously. * 异步更新队列 */var nextTick = (function() &#123; var callbacks = []; var pending = false; var timerFunc; function nextTickHandler() &#123; pending = false; var copies = callbacks.slice(0); callbacks.length = 0; for (var i = 0; i &lt; copies.length; i++) &#123; copies[i](); &#125; &#125; // 只要观察到数据变化，Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据改变。 // 如果同一个 watcher 被多次触发，只会被推入到队列中一次。 // 这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作上非常重要。 // 然后，在下一个的事件循环“tick”中，Vue 刷新队列并执行实际 (已去重的) 工作。 // Vue 在内部尝试对异步队列使用原生的 Promise.then 和 MessageChannel，如果执行环境不支持，会采用 setTimeout(fn, 0) 代替。 timerFunc = function() &#123; setTimeout(nextTickHandler, 0); &#125;; return function queueNextTick(cb, ctx) &#123; var _resolve; callbacks.push(function() &#123; if (cb) &#123; try &#123; cb.call(ctx); &#125; catch (e) &#123; handleError(e, ctx, 'nextTick'); &#125; &#125; else if (_resolve) &#123; _resolve(ctx); &#125; &#125;); if (!pending) &#123; pending = true; timerFunc(); &#125; &#125;&#125;)();Vue.prototype.$nextTick = function(fn) &#123; return nextTick(fn, this)&#125;; 关于setTimeout(fn,0)理解 JavaScript 中的 macrotask 和 microtask JavaScript 主线程拥有一个 执行栈 以及一个 任务队列，主线程会依次执行代码，当遇到函数时，会先将函数 入栈，函数运行完毕后再将该函数 出栈，直到所有代码执行完毕。 macrotasks: setTimeout, setInterval, setImmediate, I/O, UI rendering microtasks: process.nextTick, Promises, Object.observe(废弃), MutationObserver 在每一次事件循环中，macrotask 只会提取一个执行，而 microtask 会一直提取，直到 microtasks 队列清空。 讨论点 父组件nextTick的触发在子组件DOM完成前还是完成后？ 常用示例codepen示例 DOM 1234&lt;div id=\"J_app\"&gt; &lt;h3&gt;&#123;&#123;title&#125;&#125;&lt;/h3&gt; &lt;item&gt;&lt;/item&gt;&lt;/div&gt; 1.mounted时更新 父组件 12345678910111213141516171819202122232425262728293031323334353637383940414243(function() &#123; var app = new Vue(&#123; el: \"#J_app\", data: &#123; title: \"父组件\" &#125;, beforeCreate: function() &#123; // 实例初始化之后 console.log(\"父组件beforeCreate\"); &#125;, created: function() &#123; // 实例创建完成之后被调用 console.log(\"父组件created\"); &#125;, beforeMount: function() &#123; // 在挂载开始之前被调用 console.log(\"父组件beforeMount\"); &#125;, beforeUpdate: function() &#123; // 数据更新时调用 console.log(\"父组件beforeUpdate\"); &#125;, updated: function() &#123; // 数据更新之后调用 console.log(\"父组件updated\"); &#125;, mounted: function() &#123; // el被新创建的vm.$el替换，挂载到实例上 var that = this; console.log(\"父组件mounted\"); this.$nextTick(function() &#123; console.log(\"父组件nextTick\"); console.log(\"当前页面content:\" + that.$el.textContent); &#125;); that.title = \"父组件更新\"; console.log(\"父组件更新\"); console.log(\"当前页面content:\" + that.$el.textContent); &#125; &#125;);&#125;)(); 子组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445(function() &#123; var tpl = \"&lt;h4&gt;&#123;&#123;subtitle&#125;&#125;&lt;/h4&gt;\"; Vue.component('item', &#123; data: function() &#123; return &#123; subtitle: \"子组件\" &#125; &#125;, props: [], template: tpl, beforeCreate: function() &#123; // 实例初始化之后 console.log(\"子组件beforeCreate\"); &#125;, created: function() &#123; // 实例创建完成之后被调用 console.log(\"子组件created\"); &#125;, beforeMount: function() &#123; // 在挂载开始之前被调用 console.log(\"子组件beforeMount\"); &#125;, beforeUpdate: function() &#123; // 数据更新时调用 console.log(\"子组件beforeUpdate\"); &#125;, updated: function() &#123; // 数据更新之后调用 console.log(\"子组件updated\"); &#125;, mounted: function() &#123; // el被新创建的vm.$el替换，挂载到实例上 var that = this; console.log(\"子组件mounted\") this.$nextTick(function() &#123; console.log(\"子组件nextTick\"); console.log(\"当前页面content:\" + that.$el.textContent); &#125;); that.subtitle = \"子组件更新\"; console.log(\"子组件更新\"); console.log(\"当前页面content:\" + that.$el.textContent); &#125; &#125;);&#125;)(); console1234567891011121314151617181920父组件beforeCreate父组件created父组件beforeMount子组件beforeCreate子组件created子组件beforeMount子组件mounted子组件更新当前页面content:子组件父组件mounted父组件更新当前页面content:父组件 子组件子组件nextTick当前页面content:子组件父组件beforeUpdate子组件beforeUpdate子组件updated父组件updated父组件nextTick当前页面content:父组件更新 子组件更新 nextTick写在数据更改前不能拿到更新后的数据。 2.更改子组件更新时间1234567891011121314151617181920212223242526272829303132333435363738394041424344454647(function() &#123; var tpl = \"&lt;h4&gt;&#123;&#123;subtitle&#125;&#125;&lt;/h4&gt;\"; Vue.component('item', &#123; data: function() &#123; return &#123; subtitle: \"子组件\" &#125; &#125;, props: [], template: tpl, beforeCreate: function() &#123; // 实例初始化之后 console.log(\"子组件beforeCreate\"); &#125;, created: function() &#123; // 实例创建完成之后被调用 console.log(\"子组件created\"); &#125;, beforeMount: function() &#123; // 在挂载开始之前被调用 console.log(\"子组件beforeMount\"); &#125;, beforeUpdate: function() &#123; // 数据更新时调用 console.log(\"子组件beforeUpdate\"); &#125;, updated: function() &#123; // 数据更新之后调用 console.log(\"子组件updated\"); &#125;, mounted: function() &#123; // el被新创建的vm.$el替换，挂载到实例上 var that = this; console.log(\"子组件mounted\") this.$nextTick(function() &#123; console.log(\"子组件nextTick\"); console.log(\"当前页面content:\" + that.$el.textContent); &#125;); setTimeout(function() &#123; that.subtitle = \"子组件更新\"; console.log(\"子组件更新\"); console.log(\"当前页面content:\" + that.$el.textContent); &#125;, 1000); &#125; &#125;);&#125;)(); console123456789101112131415161718192021父组件beforeCreate父组件created父组件beforeMount子组件beforeCreate子组件created子组件beforeMount子组件mounted父组件mounted父组件更新当前页面content:父组件 子组件子组件nextTick当前页面content:子组件父组件nextTick当前页面content:父组件 子组件父组件beforeUpdate父组件updated子组件更新当前页面content:子组件子组件beforeUpdate子组件updated 若子组件在mounted即更新，子组件的update动作会在父组件的beforeUpdate之后updated之前执行。反之则更新后子组件自己执行update，并且由于父组件nextTick写在数据更改之前，导致先执行父组件nextTick再执行父组件的update动作。 3.同时更改父组件更新时间123456789101112131415161718192021222324252627282930313233343536373839404142434445(function() &#123; var app = new Vue(&#123; el: \"#J_app\", data: &#123; title: \"父组件\" &#125;, beforeCreate: function() &#123; // 实例初始化之后 console.log(\"父组件beforeCreate\"); &#125;, created: function() &#123; // 实例创建完成之后被调用 console.log(\"父组件created\"); &#125;, beforeMount: function() &#123; // 在挂载开始之前被调用 console.log(\"父组件beforeMount\"); &#125;, beforeUpdate: function() &#123; // 数据更新时调用 console.log(\"父组件beforeUpdate\"); &#125;, updated: function() &#123; // 数据更新之后调用 console.log(\"父组件updated\"); &#125;, mounted: function() &#123; // el被新创建的vm.$el替换，挂载到实例上 var that = this; console.log(\"父组件mounted\"); this.$nextTick(function() &#123; console.log(\"父组件nextTick\"); console.log(\"当前页面content:\" + that.$el.textContent); &#125;); setTimeout(function() &#123; that.title = \"父组件更新\"; console.log(\"父组件更新\"); console.log(\"当前页面content:\" + that.$el.textContent); &#125;, 1000); &#125; &#125;);&#125;)(); console123456789101112131415161718192021父组件beforeCreate父组件created父组件beforeMount子组件beforeCreate子组件created子组件beforeMount子组件mounted父组件mounted子组件nextTick当前页面content:子组件父组件nextTick当前页面content:父组件 子组件子组件更新当前页面content:子组件子组件beforeUpdate子组件updated父组件更新当前页面content:父组件 子组件更新父组件beforeUpdate父组件updated 若父、子组件的更新延时相同，则会各自执行各自的update动作，子组件优先。 4.nextTick顺序问题nextTick应写在数据更改后 父组件 123456789101112131415161718192021222324252627282930313233343536373839404142(function() &#123; var app = new Vue(&#123; el: \"#J_app\", data: &#123; title: \"父组件\" &#125;, beforeCreate: function() &#123; // 实例初始化之后 console.log(\"父组件beforeCreate\"); &#125;, created: function() &#123; // 实例创建完成之后被调用 console.log(\"父组件created\"); &#125;, beforeMount: function() &#123; // 在挂载开始之前被调用 console.log(\"父组件beforeMount\"); &#125;, beforeUpdate: function() &#123; // 数据更新时调用 console.log(\"父组件beforeUpdate\"); &#125;, updated: function() &#123; // 数据更新之后调用 console.log(\"父组件updated\"); &#125;, mounted: function() &#123; // el被新创建的vm.$el替换，挂载到实例上 var that = this; console.log(\"父组件mounted\"); that.title = \"父组件更新\"; console.log(\"父组件已更新\"); console.log(\"当前页面content:\" + that.$el.textContent); this.$nextTick(function() &#123; console.log(\"父组件nextTick\"); console.log(\"当前页面content:\" + that.$el.textContent); &#125;); &#125; &#125;);&#125;)(); 子组件 123456789101112131415161718192021222324252627282930313233343536373839404142434445(function() &#123; var tpl = \"&lt;h4&gt;&#123;&#123;subtitle&#125;&#125;&lt;/h4&gt;\"; Vue.component('item', &#123; data: function() &#123; return &#123; subtitle: \"子组件\" &#125; &#125;, props: [], template: tpl, beforeCreate: function() &#123; // 实例初始化之后 console.log(\"子组件beforeCreate\"); &#125;, created: function() &#123; // 实例创建完成之后被调用 console.log(\"子组件created\"); &#125;, beforeMount: function() &#123; // 在挂载开始之前被调用 console.log(\"子组件beforeMount\"); &#125;, beforeUpdate: function() &#123; // 数据更新时调用 console.log(\"子组件beforeUpdate\"); &#125;, updated: function() &#123; // 数据更新之后调用 console.log(\"子组件updated\"); &#125;, mounted: function() &#123; var that = this; console.log(\"子组件mounted\") that.subtitle = \"子组件更新\"; console.log(\"子组件已更新\"); console.log(\"当前页面content:\" + that.$el.textContent); this.$nextTick(function() &#123; console.log(\"子组件nextTick\"); console.log(\"当前页面content:\" + that.$el.textContent); &#125;); &#125; &#125;);&#125;)(); console1234567891011121314151617181920父组件beforeCreate父组件created父组件beforeMount子组件beforeCreate子组件created子组件beforeMount子组件mounted子组件已更新当前页面content:子组件父组件mounted父组件已更新当前页面content:父组件 子组件父组件beforeUpdate子组件beforeUpdate子组件updated父组件updated子组件nextTick当前页面content:子组件更新父组件nextTick当前页面content:父组件更新 子组件更新 如果子组件nextTick写在数据更改前，则会在父组件mouted之后beforeUpdate之前执行nextTick。实际应在updated之后执行nextTick，这样nextTick才能拿到最新的数据。 推荐在updated中执行$nextTick 12345678updated: function() &#123; // 数据更新之后调用 var that = this; console.log(\"组件updated\"); this.$nextTick(function() &#123; console.log(\"组件nextTick\"); &#125;);&#125; 总结 父组件nextTick的触发在子组件updated后。 若子组件在mounted即更新，子组件的update动作会在父组件的beforeUpdate之后updated之前执行。反之则更新后子组件自己执行update，不会影响父组件的nextTick。 若父、子组件的更新延时相同，则会各自执行各自的update动作，子组件优先。 nextTick都需写在各自组件的updated之后。 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！ 公众号不发文的时候推送一些我觉得好用的前端网站或者看到的一些问题的解决方案，也更便于大家交流，就酱。","tags":[{"name":"vue","slug":"vue","permalink":"https://wangchloe.vip/tags/vue/"}]},{"title":"北京5日游攻略～","date":"2018-09-20T19:12:48.000Z","path":"2018/09/21/life2/","text":"手绘导览图，侬晓得伐 北京5日游攻略～ 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"爱旅游","slug":"爱旅游","permalink":"https://wangchloe.vip/tags/爱旅游/"}]},{"title":"小厨教你做鸡蛋灌饼","date":"2018-03-28T19:12:48.000Z","path":"2018/03/29/life5/","text":"公众号又开新功能了，所以我又发了篇做饭教程，这次是老汪鸡蛋灌饼🥚！ 无媛无故-小厨教你做鸡蛋灌饼 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"爱做饭","slug":"爱做饭","permalink":"https://wangchloe.vip/tags/爱做饭/"}]},{"title":"2017-D2前端技术论坛 新思","date":"2018-01-01T19:27:35.000Z","path":"2018/01/02/blog41/","text":"天猫超市Mobile Web的极致体验优化 回归web解决问题 web目前的不足 解决方向 2017-D2 匠心 -&gt; 工匠精神 简单的事做好 简单的事做的更好 天猫超市Mobile Web的极致体验优化 天猫超市 回归web解决问题： 滚动过程代码冻结(Native解决) WKWebview(ios8+) 替代 UIWebview组件 在性能、稳定性、功能方面有很大提升（最直观的体现就是加载网页是占用的内存，模拟器加载百度与开源中国网站时，WKWebView占用23M，而UIWebView占用85M） 允许JavaScript的Nitro引擎库加载并使用（UIWebView中限制） 支持了更多的HTML5特性 高达60fps的滚动刷新率以及内置手势 将UIWebViewDelegate与UIWebView重构成了14类与3个协议 浏览器内核U4 极速引擎，采用全新的V8引擎，在U4 1.0的基础上，性能继续提高10%，重新打开网页的速度提高10%-20%； 全新的渲染架构，新的Passive Event Listener、Intersection Observer等能力赋予H5页面更加流畅的操作体验； 标准领先，新内核支持最新的PWA技术以及其他最新的H5、JS、CSS标准，并在国内首次提供标准Web推送服务； 创新扩展，推出业界效率最高的Web AR技术，兼顾Native的体验和H5的高效率，还有其他更多的创新扩展值得期待。 加载慢 预加载 页头无法定制 隐藏native页头，使用h5页头 web目前的不足 解决方向精细化 还原度 字行高 Android文字垂直居中 非miui下都是偏上的12345678910111213.box&#123; display:-webkit-box; display:flex; -webkit-box-pack:center; /*水平居中*/ -webkit-box-align:center; /*垂直居中*/ align-items:center; /*垂直居中*/ justify-content:center; /*水平居中*/ width:2rem; height:.3rem; margin:1rem; font-size:.24rem; overflow:hidden;&#125; 操作体验 极速响应 100ms内响应用户操作 并行加载资源和数据 Promise.all() 足够快时不需要loading 实时反馈 切换tabview时下边框线实时响应手势过程 操作流畅 动画 只使用transform 3D/opacity 适时使用will-change will-change:transform; /*创建新的渲染层*/ -webkit-transform:translate3d(0,0,0)触发GPU加速，让网页动画更流畅 使用CSS3 will-change提高页面滚动、动画等渲染性能 滚动 必须使用passive event listeners 由于浏览器无法预先知道一个事件处理函数中会不会调用 preventDefault()，它需要等到事件处理函数执行完后，才能去执行默认行为，若监听完后再执行默认行为会导致页面卡顿。 我们可以通过传递 passive 为 true 来明确告诉浏览器，事件处理程序不会调用 preventDefault 来阻止默认滑动行为。 移动Web滚动性能优化: Passive event listeners Chrome 51 和 Firefox 49 已经支持 passive 属性123456789101112131415var supportsPassive = false;try &#123; var opts = Object.defineProperty(&#123;&#125;, 'passive', &#123; get: function() &#123; supportsPassive = true; &#125; &#125;); window.addEventListener(\"test\", null, opts);&#125; catch (e) &#123;&#125;elem.addEventListener( 'touchstart', fn, supportsPassive ? &#123; passive: true &#125; : false); 手势 配合使用touchmove &amp; scroll 事件 ios第一次触发scroll存在延时，应配合使用touchmove 可靠性 预加载 service worker实现离线页面访问 12345678910// 注册 service workerif ('serviceWorker' in navigator) &#123; navigator.serviceWorker.register('./service-worker.js').then(function(registration) &#123; // 注册成功 console.log('ServiceWorker registration successful with scope: ', registration.scope);&#125;).catch(function(err) &#123; // 注册失败 console.log('ServiceWorker registration failed: ', err); &#125;);&#125; 123456789101112131415161718192021222324252627282930313233343536373839'use strict';var cacheVersion = 0;var currentCache = &#123; offline: 'offline-cache' + cacheVersion&#125;;const offlineUrl = 'offline.html';// 首次缓存this.addEventListener('install', event =&gt; &#123; event.waitUntil( caches.open(currentCache.offline).then(function(cache) &#123; return cache.addAll([ './offline.svg', offlineUrl ]); &#125;) );&#125;);// 拦截请求this.addEventListener('fetch', event =&gt; &#123; if (event.request.mode === 'navigate' || (event.request.method === 'GET' &amp;&amp; event.request.headers.get('accept').includes('text/html'))) &#123; event.respondWith( fetch(event.request.url).catch(error =&gt; &#123; // Return the offline page return caches.match(offlineUrl); &#125;) ); &#125; else&#123; event.respondWith(caches.match(event.request) .then(function (response) &#123; return response || fetch(event.request); &#125;) ); &#125;&#125;); ![service workder兼容性](https://ws2.sinaimg.cn/large/006tKfTcly1fmvb3ae3whj31ae0g277h.jpg) 设计语言APP化 无闪烁tabbar PS:同行者 业务线庞大 技术纬度不同 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！ 公众号不发文的时候推送一些我觉得好用的前端网站或者看到的一些问题的解决方案，也更便于大家交流，就酱。","tags":[{"name":"前端论坛","slug":"前端论坛","permalink":"https://wangchloe.vip/tags/前端论坛/"}]},{"title":"每天10个前端知识点：目录","date":"2017-06-02T19:27:35.000Z","path":"2017/06/03/blog40/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 blog1 js六大数据类型 数据类型补充 数字相关判断方法 变量 运算符 常见变量命名前缀 字符串转化为数字 数字转化为字符串 if语句变形 js及事件的笼统概念 blog2 js操作元素属性 js设置复杂样式 物体从中心放大 a链接防止刷新 循环添加事件，事件中的循环变量不能用 浏览器加载的过程 DOM获取元素方法 js中的真假 获取元素当前样式(兼容) 获取一个n~m之间的随机数(n&lt;m，且不包括m) blog3 返回值问题(return) undefined出现的情况 eval(字符串) 数字小于10的补零函数 定时器 日期对象 日期对象应用 事件函数相同可以合并 this 闭包 blog4 参数的数组arguments 设置样式的三种方法 字符串的相关方法 字符串比较 字符串应用 定义数组 数组的相关方法 json(object类型) Math方法 try-catch捕获异常 blog5(数组应用) 数组翻转方法2 首字母大写 3.快速清空数组 数组排序方法 数组内查找元素是否存在 数组去重的多种方法 补一个字符串的应用 blog6 select下拉框的相关属性 预解析 已知计算机编码查看对应单词 字节长度和编码的关系 严格模式 连等及逗号运算符 文本提示框 form表单 blog7(js组成) js实现的组成 DOM节点关系 DOM节点操作 DOM属性操作 BOM blog8(各种宽高，距离) 滚动距离 滚动高度 可视区高度 物体高度 offsetHeight &amp;&amp; getStyle() 物体的相对距离 关于父级 封装一个物体距离左边/上边的绝对位置的函数 blog9(事件篇) 事件对象 事件冒泡 事件绑定 关于捕获(这点理解不是很到位) 事件解绑 查看鼠标点击位置 键盘事件 鼠标事件 domReady 事件委托 事件源 blog10(原生运动框架) move.js blog11(move框架应用) (上) 仿jiaThis分享到 幻灯片 手风琴 多图片展开 blog12(move框架应用) (中) 运动时钟 返回顶部 无缝滚动 无缝幻灯片 带进度条的无缝幻灯片 blog13(move框架应用) (下) 打字依次显示效果 收起当前页放出下一页效果 分块运动 仿Mac 感应变大效果 blog14(前端规范) Reset.css &amp;&amp; Normailze.css css命名规范 注释的写法 id命名 class的命名 css层次 css书写次序 媒体查询(media)屏幕宽度 js常见变量命名 blog15(原生篇6) cookie、Require、数据交互前导 cookie 模块化 Require.js 数据交互 eval的替代用法 数据交互时输入中文问题 blog16(ajax jsonp) Ajax前导 Ajax Ajax服务器相关 Ajax2.0事件 关于锚点hash Ajax跨域 jsonp前导 jsonp 跨浏览器的CORS blog17(jQuery上) jQuery &amp;&amp; js jQuery效果 jQuery选择器 jQuery操作css属性 jQuery操作内容 jQuery操作类名 jQuery操作属性 jQuery DOM jQuery事件 blog18(jQuery下) jQuery获取物体信息 jQuery筛选 jQuery js jQuery链式运动 jQuery循环 jQuery工具 jQuery Ajax jQuery jsonp jQuery插件 blog19(正则) 正则表达式 正则定义的多种方法 正则校验 正则使用的字符串相关方法 特殊字符 元字符(一个字符) 限定符 转义字符 9.单词边界 简单示例 blog20(正则应用) 校验座机号码 校验邮箱 校验年龄(18-100) 仿trim()去除首尾空格 校验名字 首字母大写 过滤标签 正则getByClass等方法 blog21(性能优化) 性能优化 重排 &amp;&amp; 重绘 图层 执行性能优化 网络性能优化 垃圾回收 GC(Gabage Collection) 递归 blog22(面向对象) 面向对象 引用类型 创建对象前导 blog23(面向对象 中) 创建对象 原型与原型链 原型应用 blog24(面向对象 下) 如何编写面向对象程序 面向对象：继承 解决变量名冲突的多种方法 伪数组问题 js的冒泡(Bubbling Event)和捕获(Capture Event)的区别 如何写一个自己的框架 blog25 (算法与数据结构) 查找算法 排序算法 数据结构 blog 26 (代码管理与常见命令) svn代码版本管理工具 git分布式版本控制系统 git的使用姿势 git与svn的区别 常用命令 常用快捷键 blog27 (HTML5) HTML5语法概要 H5新增元素 H5新增属性 H5选择器补充 H5自定义属性 dataset H5元素类名操作 classList H5本地存储 localStorage H5地理位置 geolocation H5音频 audio H5视频 video H5文件 FileReader H5 web工作线程 webworker H5 webSocket 网络套接字 H5画布 canvas H5内联SVG blog28 (杂技) toString() &amp;&amp; valueOf() JSON stringify &amp; parse +new Date() Array.prototype.slice.call(arguments, 0) 剖析 JS Bridge建立Native与H5间通信 blog29 (css3) CSS3老版浏览器兼容处理 CSS3新增选择器 CSS3新增属性 CSS3媒体查询 media 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！ 公众号不发文的时候推送一些我觉得好用的前端网站或者看到的一些问题的解决方案，也更便于大家交流，就酱。","tags":[{"name":"目录","slug":"目录","permalink":"https://wangchloe.vip/tags/目录/"}]},{"title":"每天10个前端知识点：CSS3(2)","date":"2017-06-01T19:27:35.000Z","path":"2017/06/02/blog39/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 CSS3老版浏览器兼容处理 CSS3新增选择器 属性选择器 结构选择器 CSS3新增属性 色值透明度 rgba 文字阴影 text-shadow 文字省略 text-overflow 圆角 border-radius 盒子阴影 box-shadow 变换 transform (搭配transition使用效果更佳) 过渡 transition 动画 animation 视角 perspectiv 文字转向 direction 遮罩 -webkit-mask 倒影 box-reflect 文字阴影 text-shadow 调整尺寸 resize background-image内的一些属性 background相关属性 滤镜 filter CSS3媒体查询 media 媒体类型 媒体功能 meida大全 3. CSS3新增属性色值透明度 rgba之前的opacity改变背景色透明度时同时改变文字颜色透明度 rgba可实现只改变背景色透明度 文字阴影 text-shadowtext-shadow: [x轴 y轴 模糊度 弥散度 颜色] x轴：正值 -&gt; 向右 负值 -&gt; 向左 y轴：正值 -&gt; 向下 负值 -&gt; 向上 阴影叠加 文字省略 text-overflow1234567&lt;style&gt; .ell &#123; white-space: nowrap; /* 不允许换行 */ overflow: hidden; /* 超出隐藏 */ text-overflow: ellipsis; /* 超出显示省略号，默认为clip(无省略号) */ &#125;&lt;/style&gt; 圆角 border-radiusborder-radius: 10px 20px 30px 40px -&gt; 左上角起顺时针经过的角的顺序 border-radius: 10px 20px 30px 40px / 30px 10px 40px 20px / -&gt; 分离x/y轴方向半径 盒子阴影 box-shadowbox-shadow: [inset] 10px 20px 30px 40px black; [内阴影] x位移 y位移 模糊半径 弥散半径 颜色 多边框实例12345678910111213141516&lt;style&gt; #box&#123; width: 100px; height: 100px; box-shadow: 0 0 0 10px black, 0 0 0 20px green, 0 0 0 30px pink, 0 0 0 40px purple, 0 0 0 50px orange, 0 0 0 60px khaki, 0 0 0 70px indigo, 0 0 0 80px plum, 0 0 0 90px violet; margin: 200px auto; &#125;&lt;/style&gt; 变换 transform (搭配transition使用效果更佳)以下属性可以一同使用 rotate([deg]) 旋转 transform: rotate(30deg); 正向旋转30度tansform: rotate(0.785rad); 正向旋转0.785弧度tansform: rotateX|Y|Z(45deg); 角度转弧度 π/180×角度弧度变角度 180/π×弧度 transofrm-origin 旋转中心 eg:transofrm-origin: left|top|bottom|right|center(默认);transofrm-origin: left top|left bottom|right top|left center|center bottom;transofrm-origin: -120px -120px; translate(x, y) 偏移x&gt;0 右偏移x0 下偏移y&lt;0 上偏移 transform: translate(-30px, -40px); 左偏移30px, 右偏移40pxtransform: translateX|Y|Z(-30px); scale(s); 放大/缩小 transform: scale(0.2) 宽高缩小至0.2倍的大小transform: scale(0.2, 1) 宽度缩小至0.2倍大小，高度不变transform: scaleX|scaleY(0.2) skew([deg]) 倾斜 transform: skew(20deg) 水平向左倾斜20度transform: skewX(20deg) 水平向左倾斜20度transform: skewY(20deg) 垂直向上倾斜20度transform: skew(20deg, 20deg) 水平向左倾斜20度，垂直向上倾斜20度 关于多属性 transform多属性时从后向前解析 eg:transform: rotate(45deg) scale(2,1); 先横向放大再旋转transform: scale(2,1) rotate(45deg); 先旋转再横向放大 过渡 transitiontransition 属性是一个简写属性，用于设置四个过渡属性： transition-property 设置过渡效果的 CSS 属性的名称 transition-duration 完成过渡效果需要多少秒 transition-timing-function 速度效果的速度曲线 linear 匀速等于 cubic-bezier(0,0,1,1) ease 慢速开始，然后变快，然后慢速结束 cubic-bezier(0.25,0.1,0.25,1) ease-in 慢速开始 等于 cubic-bezier(0.42,0,1,1) ease-out 慢速结束 等于 cubic-bezier(0,0,0.58,1) ease-in-out 慢速开始和结束 等于 cubic-bezier(0.42,0,0.58,1) cubic-bezier(n,n,n,n) transition-delay 过渡效果何时开始 eg: 123456789101112&lt;style&gt; #box&#123; width: 200px; height: 200px; background-color: green; transition: 1s width cubic-bezier(1, 1.7, 0, 1.54) 1s; /* 1s后由400px过渡到200px */ &#125; #box:active&#123; width: 400px; transition: 0s; /* 按下0s后变为400px */ &#125;&lt;/style&gt; 动画 animationanimation 属性是一个简写属性，用于设置六个动画属性： animation-name 需要绑定到选择器的 keyframe 名称 animation-duration 完成动画所花费的时间 animation-timing-function 动画的速度曲线 animation-delay 在动画开始之前的延迟 animation-iteration-count 动画应该播放的次数 n 播放次数 infinite 无限次播放 animation-direction 是否应该轮流反向播放动画 alternate 轮流反向播放 reverse 反向播放 alternate-reverse 反向交替播放 animation-fill-mode 结束状态 forwards 停留在结束状态 backwards 返回原始状态 animation-play-state 暂停动画 paused 动画已暂停 running 动画正在播放 keyframe 关键帧1234567891011121314151617181920&lt;style&gt; @keyframes name&#123; from&#123; &#125; to&#123; &#125; 10%&#123; &#125; 20%&#123; &#125; 100%&#123; &#125; &#125;&lt;/style&gt; 视角 perspectiv指定观察者与z=0平面的距离，使具有三维位置变换的元素产生透视效果。 小tip: 纯CSS实现视差滚动效果好吧，CSS3 3D transform变换，不过如此！ perspective属性有两种书写形式： 用在舞台元素上（动画元素们的共同父辈元素） perspective:1px; -&gt; 给当前元素的子集增加视角 用在当前动画元素上，与transform的其他属性写在一起 transform:perspective(800px) (perspective必须写在最前面) rotate... -&gt; 给当前元素增加视角 开启3D空间 transform-style:preserve-3d; 加给3D变化元素父集，不可继承 12345678910111213141516171819&lt;style&gt;/*小tip: 纯CSS实现视差滚动效果*/.container &#123; /* 滚动容器 */ perspective: 1px; padding: 0; height: calc(100vh - 300px); overflow: auto;&#125;.box &#123; /* 视差元素的父级需要3D视角 */ height: 1280px; transform-style: preserve-3d; position: relative;&#125;.background &#123; /* 滚动比较慢的背景元素 */ position: absolute; left: 50%; transform: translate3D(-50%, -120px, -1px) scale(2);&#125;&lt;/style&gt; 文字转向 direction需配合unicode-bidi使用 1234567&lt;style&gt; /*right to left*/ .rtl&#123; direction:rtl; unicode-bidi:bidi-override; &#125;&lt;/style&gt; 遮罩 -webkit-mask1234567&lt;style&gt;.mask&#123; -webkit-mask: url(xxx.jpg); /*背景按mask图片大小显示*/ -webkit-mask:linear-gradient(rgba(0,0,0,1)), to(rgba(0,0,0,0); /*背景按渐变遮罩显示*/&#125;&lt;/style&gt; webkit下神奇的图层蒙版效果 12345678910111213141516171819&lt;style&gt; body &#123; margin: 0; padding: 0; background-color: #000; &#125; #box &#123; position: absolute; top:0; right:0; bottom:0; left:0; background: url(img/2.jpg) no-repeat; background-size: cover; -webkit-mask: -webkit-radial-gradient(300px 300px, circle, #f00 100px, rgba(0, 0, 0, .3) 20px); &#125;&lt;/style&gt; 1&lt;div id=&quot;box&quot;&gt;&lt;/div&gt; 123456789101112131415161718&lt;script&gt; var oBox = document.querySelector(&apos;#box&apos;); oBox.onmousemove = function(&#123; clientX, clientY &#125;) &#123; this.style.WebkitMask = `-webkit-radial-gradient($&#123; clientX - oBox.offsetLeft &#125;px $&#123; clientY - oBox.offsetTop &#125;px,circle,#f00 100px,rgba(0,0,0,.3) 20px)` &#125;&lt;/script&gt; 倒影 box-reflect-webkit-box-reflect各个属性值效果演示 box-reflect：none | ? ? 方向 = above | below | left | right间隔 = | 遮罩 = none | | | | | 文字阴影 text-shadowtext-shadow: x-shadow y-shadow [blur] [color]; 水平阴影位置 垂直阴影位置 模糊的距离 阴影颜色 调整尺寸 resize是否允许用户调整元素的尺寸 1234resize: none; 用户无法调整元素的尺寸resize: both; 用户可调整元素的高度和宽度resize: horizontal; 用户可调整元素的宽度resize: vertical; 用户可调整元素的高度 background-image内的一些属性linear-gradient 线性渐变 direction:to top -&gt; 0deg -&gt; 从下到上to right -&gt; 90deg -&gt; 从左到右to bottom -&gt; 180deg -&gt; 从上到下（默认值）to left -&gt; 270deg -&gt; 从右到左to top left -&gt; 右上角到左上角（斜对角）to top right -&gt; 左下角到右上角（斜对角） eg:background-image: linear-gradient(red,blue);background-image: linear-gradient(250deg,red,blue);background-image: linear-gradient(red,orange,yellow,green,blue,indigo,violet);background-image: linear-gradient(red 50%,blue 50%); 跳变background-image: linear-gradient(90deg,blue 33.33333%,white 33.33333%,white 66.66666%,red 66.66666%,red 100%); 0~1/3是蓝色 1/3~2/3是白色 2/3~1是红色 radial-gradient 径向渐变background:radial-gradient(position ,shape size, start-color, stop-color); position 圆心位置 shapecircle 定义径向渐变为“圆形”ellipse 定义径向渐变为“椭圆形” sizecloset-side 指定径向渐变的半径长度为从圆心到离圆心最近的边closest-corner 指定径向渐变的半径长度为从圆心到离圆心最近的角farthest-side 指定径向渐变的半径长度为从圆心到离圆心最远的边farthest-corner 指定径向渐变的半径长度为从圆心到离圆心最远的角 eg:background-image: radial-gradient(red,blue); 内圆红色，外框蓝色background-image: radial-gradient(red,orange,yellow,green,blue,indigo,violet);border-radius: 50%;background-image: radial-gradient(circle,red 30%,white 30%);background-image: -webkit-radial-gradient(100px 100px,circle farthest-corner,red,blue);background-image: -webkit-radial-gradient(100px 100px,circle farthest-side,red,blue);background-image: -webkit-radial-gradient(150px 100px,200px 80px,red,blue); repeating-linear-gradient 重复渐变eg:background-image: repeating-linear-gradient(red,blue 20%); background相关属性####background-origin 相对于内容框来定位背景图像 background-origin: border-box; 相对于边框盒来定位背景图像background-origin: content-box; 相对于内容框来定位背景图像background-origin: padding-box; 相对于内边距框来定位背景图像 background-clip 裁剪背景图片background-clip: border-box; 相对于边框盒来定位背景图像background-clip: content-box; 相对于内容框来定位背景图像background-clip: padding-box; 相对于内边距框来定位背景图像 webkit下神奇的文字蒙版效果 1234567891011121314&lt;style&gt; #box &#123; width: 200px; height: 200px; background: url(img/1.jpg); background-size: cover; -webkit-background-clip: text; font-size: 200px; font-weight: bolder; color: rgba(0, 0, 0, 0.1); &#125;&lt;/style&gt; 1&lt;div id=&quot;box&quot;&gt;W&lt;/div&gt; background-attachmentbackground-attachment: scroll 默认值。背景图像会随着页面其余部分的滚动而移动。background-attachment: fixed 当页面的其余部分滚动时，背景图像不会移动。 图片覆盖切换效果 background-size 背景图像尺寸background-size: 3em, 25%; 自定义背景图像尺寸background-size: cover; 使背景图像完全覆盖背景区域(图像可能被裁剪)background-size: contain; 完全包含背景图(no-repeat背景区域可能有空白) background-position 背景图像定位常用于雪碧图 background-position: center|top|right|bottom|leftbackground-position: 20px 20% 滤镜 filterCSS3 Filter的十种特效 blur 模糊eg:filter: blur(20px); drop-shadow 阴影CSS3 filter:drop-shadow滤镜与box-shadow区别应用eg:filter: drop-shadow(100px 1px 2px black); invert 反色eg:filter: invert(0.7); brightness 亮度eg:filter: brightness(.5); sepia 褐色eg:filter: sepia(1); hue-rotate 色相旋转eg:filter: hue-rotate(30deg); saturate 饱和度eg:filter: saturate(10); 4. CSS3媒体查询 media媒体类型 all 用于所有设备 screen 用于电脑屏幕，平板电脑，智能手机等 print 用于打印机和打印预览 媒体功能 width 定义输出设备中的页面可见区域宽度 heigth 定义输出设备中的页面可见区域高度 min-width 定义输出设备中的页面最小可见区域宽度 max-width 定义输出设备中的页面最大可见区域宽度 min-height 定义输出设备中的页面最小可见区域高度 max-height 定义输出设备中的页面最大可见区域高度 device-width 定义输出设备的屏幕可见宽度 device-height 定义输出设备的屏幕可见高度 orientation 定义输出设备中的页面可见区域高度是否大于或等于宽度 portrait 竖屏 页面可见区域高度大于或等于宽度 landscape 横屏 页面可见区域高度小于宽度 meida大全1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798&lt;style&gt; /* iphone3 */ @media only screen and (min-device-width:320px) and (max-device-width:480px) and (-webkit-device-pixel-ratio:1) &#123; &#125; @media only screen and (min-device-width:320px) and (max-device-width:480px) and (-webkit-device-pixel-ratio:1) and (orientation:portrait) &#123; &#125; @media only screen and (min-device-width:320px) and (max-device-width:480px) and (-webkit-device-pixel-ratio:1) and (orientation:landscape) &#123; &#125; /*iphone 4 (retina)*/ @media only screen and (min-device-width:320px) and (max-device-width:480px) and (-webkit-device-pixel-ratio:2) and (device-aspect-ratio:2/3) &#123; &#125; @media only screen and (min-device-width:320px) and (max-device-width:480px) and (-webkit-device-pixel-ratio:2) and (device-aspect-ratio:2/3) and (orientation:portrait) &#123; &#125; @media only screen and (min-device-width:320px) and (max-device-width:480px) and (-webkit-device-pixel-ratio:2) and (device-aspect-ratio:2/3) and (orientation:landscape) &#123; &#125; /*iphone 5*/ @media only screen and (min-device-width:320px) and (max-device-width:568px) and (-webkit-device-pixel-ratio:2) and (device-aspect-ratio:40/71) &#123; &#125; @media only screen and (min-device-width:320px) and (max-device-width:568px) and (-webkit-device-pixel-ratio:2) and (device-aspect-ratio:40/71) and (orientation:portrait) &#123; &#125; @media only screen and (min-device-width:320px) and (max-device-width:568px) and (-webkit-device-pixel-ratio:2) and (device-aspect-ratio:40/71) and (orientation:landscape) &#123; &#125; /*ipads (all) */ @media only screen and (min-device-width:768px) and (max-device-width:1024px) &#123; &#125; @media only screen and (min-device-width:768px) and (max-device-width:1024px) and (orientation:portrait) &#123; &#125; @media only screen and (min-device-width:768px) and (max-device-width:1024px) and (orientation:landscape) &#123; &#125; /* ipad-retina */ @media screen and (min-device-width:768px) and (max-device-width:1024px) and (-webkit-device-pixel-ratio:2) &#123; &#125; @media screen and (min-device-width:768px) and (max-device-width:1024px) and (-webkit-device-pixel-ratio:2) and (orientation:portrait) &#123; &#125; @media screen and (min-device-width:768px) and (max-device-width:1024px) and (-webkit-device-pixel-ratio:2) and (orientation:landscape) &#123; &#125; /* iPhone 6 */ /* Landscape */ @media only screen and (min-device-width:375px) /* or 213.4375em or 3in or 9cm */ and (max-device-width:667px) /* or 41.6875em */ and (width:667px) /* or 41.6875em */ and (height:375px) /* or 23.4375em */ and (orientation:landscape) and (color:8) and (device-aspect-ratio:375/667) and (aspect-ratio:667/375) and (device-pixel-ratio:2) and (-webkit-min-device-pixel-ratio:2) &#123; &#125; /* Portrait */ @media only screen and (min-device-width:375px) /* or 213.4375em */ and (max-device-width:667px) /* or 41.6875em */ and (width:375px) /* or 23.4375em */ and (height:559px) /* or 34.9375em */ and (orientation:portrait) and (color:8) and (device-aspect-ratio:375/667) and (aspect-ratio:375/559) and (device-pixel-ratio:2) and (-webkit-min-device-pixel-ratio:2) &#123; &#125; /* ----------- iPhone 6+ ----------- */ /* Portrait and Landscape */ @media only screen and (min-device-width: 414px) and (max-device-width: 736px) and (-webkit-min-device-pixel-ratio: 3) &#123; &#125; /* Portrait */ @media only screen and (min-device-width: 414px) and (max-device-width: 736px) and (-webkit-min-device-pixel-ratio: 3) and (orientation: portrait) &#123; &#125; /* Landscape */ @media only screen and (min-device-width: 414px) and (max-device-width: 736px) and (-webkit-min-device-pixel-ratio: 3) and (orientation: landscape) &#123; &#125;&lt;/style&gt; 常见移动设备的 CSS3 Media Query 整理（iPhone/iPad/Galaxy/HTC One etc.）Media Queries for Standard Devices 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！ 公众号不发文的时候推送一些我觉得好用的前端网站或者看到的一些问题的解决方案，也更便于大家交流，就酱。","tags":[{"name":"CSS3","slug":"CSS3","permalink":"https://wangchloe.vip/tags/CSS3/"}]},{"title":"每天10个前端知识点：CSS3(1)","date":"2017-05-31T19:27:35.000Z","path":"2017/06/01/blog38/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 CSS3老版浏览器兼容处理 CSS3新增选择器 属性选择器 结构选择器 CSS3新增属性 色值透明度 rgba 文字阴影 text-shadow 文字省略 text-overflow 圆角 border-radius 盒子阴影 box-shadow 变换 transform (搭配transition使用效果更佳) 过渡 transition 动画 animation 视角 perspectiv 文字转向 direction 遮罩 -webkit-mask 倒影 box-reflect 文字阴影 text-shadow 调整尺寸 resize background-image内的一些属性 background相关属性 滤镜 filter CSS3媒体查询 media 媒体类型 媒体功能 meida大全 1. CSS3老版浏览器兼容处理 css -webkit-transition: 1s; -moz-transition: 1s; -o-transition: 1s; transition: 1s; js(去掉-，首字母大写) WebkitTransition MozTransition OTransition 2. CSS3新增选择器属性选择器兼容：IE7+ E[attr] E[attr=”value”] 匹配属性 只含一个属性值 E[attr~=”value”] 匹配空格隔开的单词 attr属性值包含value E[attr^=”value”] 匹配开头 attr属性值以value开头 E[attr$=”value”] 匹配结尾 attr属性值以value结束 E[attr*=”value”] attr属性值包含value字符 E[attr|=”value”] 匹配value-开头 attr属性值是value或者”value-“开头 只含一个属性值 1234567891011121314151617181920212223&lt;style&gt; p[attr1] &#123; background: #f00; &#125; p[attr1=a] &#123; background: #0ff; &#125; p[attr1~=c] &#123; background: #00f; &#125; p[attr1^=e] &#123; background: #ff0; &#125; p[attr1$=g] &#123; background: #f0f; &#125; p[attr1*=i] &#123; background: #0f0; &#125; p[attr1|=k] &#123; background: #fff; &#125;&lt;/style&gt; 1234567891011121314151617181920212223242526&lt;strong&gt;E[attr=\"value\"] **只含一个属性值**&lt;/strong&gt;&lt;p attr1=\"a\"&gt;attr1=\"a\"&lt;/p&gt;&lt;p attr1=\"b a\"&gt;attr1=\"b a\"&lt;/p&gt;&lt;hr/&gt;&lt;strong&gt;E[attr~=\"value\"] attr属性值包含value&lt;/strong&gt;&lt;p attr1=\"c\"&gt;attr1=\"c\"&lt;/p&gt;&lt;p attr1=\"d c\"&gt;attr1=\"d c\"&lt;/p&gt;&lt;hr/&gt;&lt;strong&gt;E[attr^=\"value\"] attr属性值以value开头&lt;/strong&gt;&lt;p attr1=\"e\"&gt;attr1=\"e\"&lt;/p&gt;&lt;p attr1=\"f ef\"&gt;attr1=\"f ef\"&lt;/p&gt;&lt;p attr1=\"ef f\"&gt;attr1=\"ef f\"&lt;/p&gt;&lt;hr/&gt;&lt;strong&gt;E[attr$=\"value\"] attr属性值以value结束&lt;/strong&gt;&lt;p attr1=\"g gh\"&gt;attr1=\"g gh\"&lt;/p&gt;&lt;p attr1=\"h hg\"&gt;attr1=\"h hg\"&lt;/p&gt;&lt;hr/&gt;&lt;strong&gt;E[attr*=\"value\"] attr属性值包含value字符&lt;/strong&gt;&lt;p attr1=\"i\"&gt;attr1=\"i\"&lt;/p&gt;&lt;p attr1=\"j jij\"&gt;attr1=\"j jij\"&lt;/p&gt;&lt;hr/&gt;&lt;strong&gt;E[attr|=\"value\"] attr属性值是value或者\"value-\"开头 **只含一个属性值**&lt;/strong&gt;&lt;p attr1=\"k\"&gt;attr1=\"k\"&lt;/p&gt;&lt;p attr1=\"l k\"&gt;attr1=\"l k\"&lt;/p&gt;&lt;p attr1=\"m k-m\"&gt;attr1=\"m k-m\"&lt;/p&gt;&lt;p attr1=\"k-m\"&gt;attr1=\"k-m\"&lt;/p&gt; 结构选择器兼容：IE9+ 下标索引从1开始 :nth-child(n) 找当前节点的父节点下的第n个子节点，当且仅当该子节点与当前节点的类型相符时有效 :nth-last-child(n) 找当前节点的父节点下的倒数第n个子节点，当且仅当该子节点与当前节点的类型相符时有效 :nth-of-type(n) 找当前节点的父节点下的第n个与当前节点的类型相符的子节点 :nth-last-of-type(n) 找当前节点的父节点下的倒数第n个与当前节点的类型相符的子节点 :first-child 即 :nth-child(1) :last-child 即 :nth-last-child(1) :first-of-type 即 :nth-of-type(1) :last-of-type 即 :nth-last-of-type(1) :only-child 当前节点的父节点下只有一个子节点时有效 :only-of-type 当前节点的父节点下与当前节点的类型相符的子节点只有一个时有效，可有多个其他类型子节点 :target 设置跳转锚点属性 -&gt; :disabled 不可点击的表单控件 :enabled 可点击的表单控件 :checked 选中的checkbox/radio A~B A元素后的第一个类型为B的兄弟节点 应用：模拟checkbox :first-line 当前节点的第一行 :first-letter 当前节点的第一个字符 :not(x) 不匹配x时有效 伪元素 ::selection 在当前节点内选中文字时有效 ::before 搭配content使用，在当前节点内容最前面插入content 不增加DOM ::after 搭配content使用，在当前节点内容最后面插入content 不增加DOM 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！ 公众号是坚持日更的，不发文的时候推送一些我觉得好用的前端网站或者看到的一些问题的解决方案，也更便于大家交流，就酱。","tags":[{"name":"CSS3","slug":"CSS3","permalink":"https://wangchloe.vip/tags/CSS3/"}]},{"title":"每天10个前端知识点：杂技","date":"2017-05-18T19:27:35.000Z","path":"2017/05/19/blog37/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 toString() &amp;&amp; valueOf() JSON stringify &amp; parse +new Date() Array.prototype.slice.call(arguments, 0) 剖析 JS Bridge建立Native与H5间通信 Hybrid通信原理 JS Bridge 有些平时碰到的很零碎的东西我就随便插入到这个章节里了。 1. toString() &amp;&amp; valueOf() toString() 把一个逻辑值转换为字符串，并返回结果。 valueOf() 返回Boolean对象的原始值 源自知乎这两个方法一般是交由JS去隐式调用，以满足不同的运算情况。 在数值运算里，会优先调用valueOf()，如a+b；在字符串运算里，会优先调用toString()，如alert(c)。 12345678910111213141516171819202122&lt;script&gt; // 该示例来源于脚本之家 var bbb = &#123; i: 10, toString: function() &#123; console.log('toString'); return this.i; &#125;, valueOf: function() &#123; console.log('valueOf'); return this.i; &#125; &#125; alert(bbb); // 10 toString alert(+bbb); // 10 valueOf alert('' + bbb); // 10 valueOf alert(String(bbb)); // 10 toString alert(Number(bbb)); // 10 valueOf alert(bbb == '10'); // true valueOf alert(bbb === '10'); // false&lt;/script&gt; 1234567891011&lt;script&gt; console.log(&#123; valueOf: function() &#123; return 20; &#125; &#125; * &#123; valueOf: function() &#123; return 30; &#125; &#125;); // 600&lt;/script&gt; 2. JSON stringify &amp; parsejson2.js - 引入解决IE7及以下版本JSON未定义问题。 JSON.stringify(object); 对象 -&gt; 字符串 将对象字符串序列化成标准JSON字符串 eg: {a:1,b:2} -&gt; &quot;{&quot;a&quot;:1,&quot;b&quot;:2}&quot; JSON.parse(str); 字符串 -&gt; json对象 将字符串序列化成对象 {&quot;name&quot;:&quot;wangchloe&quot;,&quot;age&quot;:&quot;22&quot;} -&gt;12345&#123; age: &quot;22&quot;, name: &quot;wangchloe&quot;, _proto: Object&#125; 1&lt;a href=\"https://www.baidu.com/\" attr1='13'&gt;baidu.com&lt;/a&gt; 1234567891011121314151617181920212223&lt;script&gt; var oA = document.querySelector('a'); console.log(oA.getAttribute('attr1')); // 13 oA.setAttribute('attr1', '14'); var num = oA.getAttribute('attr1'); console.log(oA.getAttribute('attr1')); // 14 console.log(typeof number); // string 直接设置自定义属性只能得到string类型 oA.setAttribute('attr1', JSON.stringify(&#123;name: 14&#125;)); var num2 = oA.getAttribute('attr1'); console.log(num2); // &#123;\"name\": \"14\"&#125; console.log(JSON.parse(num2)); // Object &#123;name: \"14\"&#125; // name: \"14\" // -&gt; _proto_: Object console.log(JSON.parse(num2).name); // 14 console.log(typeof JSON.parse(num2).name); // number JSON转化得到了真正类型&lt;/script&gt; 3. +new Date()12345678&lt;script&gt; s = new Date().toString(); // &quot;Wed May 17 2017 11:00:16 GMT+0800 (中国标准时间)&quot; t = (+new Date()).toString(); // &quot;1494990039861&quot; // +new Date(); 等同于 new Date().getTime(); 简略写法，得到毫秒&lt;/script&gt; 4. Array.prototype.slice.call(arguments, 0) 剖析将具有length属性的对象转成数组 1234567891011&lt;script&gt;// array.js slice的内部实现function slice(start, end) &#123; var len = ToUint32(this.length), result = []; for (var i = start; i &lt; end; i++) &#123; result.push(this[i]); &#125; return result;&#125;&lt;/script&gt; 1234567&lt;script&gt; // 传入arguments类数组，调用Array.prototype.slice原型方法 // 并用call()方法，将作用域限定在arguments中 // 这里Array.prototype就可以理解为arguments // 参数0为slice()方法的第一个参数，即开始位置索引，返回整个数组。 Array.prototype.slice.call(arguments, 0);&lt;/script&gt; 5. JS Bridge建立Native与H5间通信Hybrid通信原理背景：原生APP开发中有一个webview的组件(Android中是webview,iOS7以下有UIWebview,7以上有WKWebview),这个组件可以加载Html文件。 IOS Object-C可直接调用js，只需调用stringByEvaluatingJavaScriptFromString即可，可直接获取js返回值。 js不可直接调用Object-C，利用 shouldStartLoadWithRequest，需拦截每个url，对指定的schema进行拦截做相应的本地方法。 Android Java可直接调用js，但不可直接获取js返回值。 Java注册addJavascriptInterface 后，js可直接调用Native的接口，并获取Native的返回值。让Java跟Javascript更加亲密 通过 shouldOverrideUrlLoading，也还是拦截Web的所有URL请求来达到通信的目的。 基础通信存在以下问题 Android4.2以下,addJavascriptInterface方式有安全漏洞 iOS7以下,js无法调用Native JS Bridge url scheme交互方式是一套现有的成熟方案，可以完美兼容各种版本，不存在上述问题。 通过JSBridge(JS和Native通信机制),H5页面可以调用Native的api,Native也可调用H5页面的方法或者通知H5页面回调。 原理：（1）初始化创建的一个style.display=none 的iframe,并将iframe.src设置为自有协议，每次js需要与Native通信时，js端主动调用iframe.src即可，Native收到请求通知后，反向调用fetchQueue(可见源码)获取消息内容；若Native需要与js通信，直接调用js，并获取返回值 （2） IOSjs-&gt;Native：js将要发送的消息存放在js端-&gt;调用iframe.src，触发通知Native-&gt;Native拦截请求，调用js bridge里面的fetchQueue并获取返回的消息内容，处理消息-&gt;将需要返回的数据通过直接调用js的方式，让js处理 Androidjs-&gt;Native: 通过 shouldOverrideUrlLoading 携带Js的返回值（3）Native-&gt;js: Native可直接调用Js并获取返回的内容 1234567891011121314151617&lt;script&gt;function bridgeApp(protocol) &#123; var iframe = document.createElement(&quot;iframe&quot;); var iframeStyle = document.createAttribute(&quot;style&quot;); var iframeSrc = document.createAttribute(&quot;src&quot;); iframeStyle.nodeValue = &quot;display:none;width:0;height:0;&quot;; iframeSrc.nodeValue = protocol; iframe.setAttributeNode(iframeStyle); iframe.setAttributeNode(iframeSrc); document.body.appendChild(iframe); setTimeout(function() &#123; document.body.removeChild(iframe); &#125;, 250);&#125;&lt;/script&gt; 连续五篇讲述Hybrid以及JSBridge解决方案 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！ 公众号是坚持日更的，不发文的时候推送一些我觉得好用的前端网站或者看到的一些问题的解决方案，也更便于大家交流，就酱。","tags":[{"name":"杂技","slug":"杂技","permalink":"https://wangchloe.vip/tags/杂技/"}]},{"title":"每天10个前端知识点：HTML5(内联SVG)","date":"2017-04-23T19:27:35.000Z","path":"2017/04/24/blog36/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 H5内联SVG (1) 位图 &amp;&amp; 矢量图 (2) SVG使用 (3) SVG梗概 (4) SVG应用 14. H5内联SVGSVG(Scalable Vector Graphic 可伸缩矢量图形)VML(The Vector Markup Language 矢量可标记语言) SVG 使用 XML 格式定义图形 (1) 位图 &amp;&amp; 矢量图 位图 -&gt; 由像素点构成的图形 优点: 色彩信息相当复杂 缺点: 失真、体积大 矢量图 -&gt; 由数学语言描述出的图形 优点: 体积小不失真 缺点: 色彩信息单一，图形简单 (2) SVG使用1.1&lt;img src=&quot;xxx.svg&quot;&gt; 1234&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;svg width=&quot;801px&quot; height=&quot;792px&quot; viewBox=&quot;0 0 801 792&quot; version=&quot;1.1&quot; xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;&gt; ...&lt;/svg&gt; 2.123&lt;svg&gt; &lt;rect x=&quot;20&quot; y=&quot;20&quot; rx=&quot;20&quot; ry=&quot;20&quot; width=&quot;250&quot; height=&quot;250&quot; style=&quot;fill:blue;stroke:pink;stroke-width:5;fill-opacity:0.1;stroke-opacity:0.9&quot;/&gt;&lt;/svg&gt; 3.12345678910111213&lt;svg width=&quot;200&quot; height=&quot;200&quot;&gt;&lt;/svg&gt;&lt;script&gt; var oSvg = document.querySelector(&apos;svg&apos;); var oLine = document.createElementNS(&apos;http://www.w3.org/2000/svg&apos;, &apos;line&apos;); oLine.setAttribute(&apos;x1&apos;, &apos;10&apos;); oLine.setAttribute(&apos;y1&apos;, &apos;10&apos;); oLine.setAttribute(&apos;x2&apos;, &apos;100&apos;); oLine.setAttribute(&apos;y2&apos;, &apos;100&apos;); oLine.setAttribute(&apos;stroke&apos;, &apos;green&apos;); oSvg.appendChild(oLine);&lt;/script&gt; (3) SVG梗概 &lt;rect&gt; 矩形eg: &lt;rect x=&quot;20&quot; y=&quot;20&quot; rx=&quot;20&quot; ry=&quot;20&quot; width=&quot;250&quot; height=&quot;250&quot; style=&quot;fill:blue;stroke:pink;stroke-width:5;fill-opacity:0.1;stroke-opacity:0.9&quot;/&gt; x, y 位置 width, height 宽高 rx, ry 圆角矩形 style css属性 &lt;circle&gt; 圆形eg: &lt;circle cx=&quot;100&quot; cy=&quot;50&quot; r=&quot;40&quot; stroke=&quot;black&quot; stroke-width=&quot;2&quot; fill=&quot;red&quot;/&gt; cx, cy 圆心坐标 默认(0, 0) r 半径 &lt;ellipse&gt; 椭圆eg: &lt;ellipse cx=&quot;300&quot; cy=&quot;150&quot; rx=&quot;200&quot; ry=&quot;80&quot;style=&quot;fill:rgb(200,100,50);stroke:rgb(0,0,100);stroke-width:2&quot;/&gt; cx, cy 圆心坐标 rx, ry 水平/垂直半径 &lt;line&gt; 线eg: &lt;line x1=&quot;0&quot; y1=&quot;0&quot; x2=&quot;300&quot; y2=&quot;300&quot;style=&quot;stroke:rgb(99,99,99);stroke-width:2&quot;/&gt; x1, y1 开始坐标 x2, y2 结束坐标 &lt;polyline&gt; 折线eg: &lt;polyline points=&quot;0,0 0,20 20,20 20,40 40,40 40,60&quot;style=&quot;fill:white;stroke:red;stroke-width:2&quot;/&gt; points 每个折点的x,y坐标 &lt;polygon&gt; 多边形eg: &lt;polygon points=&quot;220,100 300,210 170,250&quot;style=&quot;fill:#cccccc;stroke:#000000;stroke-width:1&quot;/&gt; points 每个角的x,y坐标(自动闭合) &lt;path&gt; 路径eg: &lt;path d=&quot;M250 150 L150 350 L350 350 Z&quot; style=&quot;#ccc;&quot;/&gt; 大写表示绝对定位，小写表示相对定位。 M moveto L lineto H horizontal lineto V vertical lineto C curveto S smooth curveto Q quadratic Belzier curve T smooth quadratic Belzier curveto A elliptical Arc Z closepath &lt;filter&gt; 高斯滤镜 标签必须嵌套在 标签内。 definitions 定义eg: &lt;defs&gt;&lt;filter id=&quot;Gaussian_Blur&quot;&gt;&lt;feGaussianBlur in=&quot;SourceGraphic&quot; stdDeviation=&quot;3&quot; /&gt;&lt;/filter&gt;&lt;/defs&gt;&lt;ellipse cx=&quot;200&quot; cy=&quot;150&quot; rx=&quot;70&quot; ry=&quot;40&quot; style=&quot;fill:#ff0000;stroke:#000000;stroke-width:2;filter:url(#Gaussian_Blur)&quot;/&gt; id 定义名称 filter:url(#xxx) 链接滤镜 &lt;linearGradient&gt; 线性渐变 标签必须嵌套在 的内部。eg: &lt;defs&gt;&lt;linearGradient id=&quot;orange_red&quot; x1=&quot;0%&quot; y1=&quot;0%&quot; x2=&quot;100%&quot; y2=&quot;0%&quot;&gt;&lt;stop offset=&quot;0%&quot; style=&quot;stop-color:rgb(255,255,0);stop-opacity:1&quot;/&gt;&lt;stop offset=&quot;100%&quot; style=&quot;stop-color:rgb(255,0,0);stop-opacity:1&quot;/&gt;&lt;/linearGradient&gt;&lt;/defs&gt;&lt;ellipse cx=&quot;200&quot; cy=&quot;190&quot; rx=&quot;85&quot; ry=&quot;55&quot; style=&quot;fill:url(#orange_red)&quot;/&gt; id 定义名称 x1,y1 渐变开始位置 x2,y2 渐变结束位置 渐变颜色 fill:url(#xxx) 链接渐变 &lt;radialGradient&gt; 径向渐变 标签必须嵌套在 中。eg: &lt;defs&gt;&lt;radialGradient id=&quot;grey_blue&quot; cx=&quot;50%&quot; cy=&quot;50%&quot; r=&quot;50%&quot;fx=&quot;50%&quot; fy=&quot;50%&quot;&gt;&lt;stop offset=&quot;0%&quot; style=&quot;stop-color:rgb(200,200,200);stop-opacity:0&quot;/&gt;&lt;stop offset=&quot;100%&quot; style=&quot;stop-color:rgb(0,0,255);stop-opacity:1&quot;/&gt;&lt;/radialGradient&gt;&lt;/defs&gt;&lt;ellipse cx=&quot;230&quot; cy=&quot;200&quot; rx=&quot;110&quot; ry=&quot;100&quot; style=&quot;fill:url(#grey_blue)&quot;/&gt; id 定义名称 cx,cy,r 外圈 fx,fy 内圈 渐变颜色 fill:url(#xxx) 链接渐变 (4) SVG应用纯CSS实现帅气的SVG路径描边动画效果 stroke-dasharray 各虚线长度 stroke-dashoffset 虚线的起始偏移 获取路径长度1234&lt;script&gt; var path = document.querySelector(&apos;path&apos;); var length = path.getTotalLength();&lt;/script&gt; 201712345678910111213141516171819202122&lt;style&gt; .one &#123; stroke-dasharray: 600; stroke-dashoffset: 600; animation: ani 2s forwards; &#125; .two &#123; stroke-dasharray: 600; stroke-dashoffset: 600; animation: ani 1.8s forwards 0.2s; &#125; .three &#123; stroke-dasharray: 600; stroke-dashoffset: 600; animation: ani 1.6s forwards 0.4s; &#125; @keyframes ani &#123; to &#123; stroke-dashoffset: 0; &#125; &#125;&lt;/style&gt; 三个颜色变换 1234567891011121314151617&lt;svg width=\"800\" height=\"600\"&gt; &lt;!-- one --&gt; &lt;path d=\"M149.593084,114.512754 C149.593084,80.6086232 265.458217,31.6263568 265.458217,144.647923 C265.458217,257.669489 149.593084,288.726563 149.593084,288.726563 L291.550902,288.726563\" class=\"one\" stroke=\"#4A4A4A\" stroke-width=\"8\" fill=\"none\" stroke-lineCap=\"round\"&gt;&lt;/path&gt; &lt;path d=\"M391.00506,81.6608912 C297.400634,81.6608912 275.086722,284.767558 384.426619,284.767558 C493.766517,284.767558 484.609487,81.6608912 391.00506,81.6608912 Z\" class=\"one\" stroke=\"#4A4A4A\" stroke-width=\"8\" fill=\"none\" stroke-lineCap=\"round\"&gt;&lt;/path&gt; &lt;path d=\"M508.720275,85.6448695 C519.572766,106.125165 510.370277,296.381449 510.370277,296.381449\" class=\"one\" stroke=\"#4A4A4A\" stroke-width=\"8\" fill=\"none\" stroke-lineCap=\"round\"&gt;&lt;/path&gt; &lt;path d=\"M570.187369,93.0436865 C570.187369,93.0436865 703.312123,69.0165013 703.312123,103.354018 C703.312123,137.691534 595.118196,304.797696 595.118196,304.797696\" class=\"one\" stroke=\"#4A4A4A\" stroke-width=\"8\" fill=\"none\" stroke-lineCap=\"round\"&gt;&lt;/path&gt; &lt;!-- two --&gt; &lt;path d=\"M149.593084,114.512754 C149.593084,80.6086232 265.458217,31.6263568 265.458217,144.647923 C265.458217,257.669489 149.593084,288.726563 149.593084,288.726563 L291.550902,288.726563\" class=\"two\" stroke=\"#029df9\" stroke-width=\"8\" fill=\"none\" stroke-lineCap=\"round\"&gt;&lt;/path&gt; &lt;path d=\"M391.00506,81.6608912 C297.400634,81.6608912 275.086722,284.767558 384.426619,284.767558 C493.766517,284.767558 484.609487,81.6608912 391.00506,81.6608912 Z\" class=\"two\" stroke=\"#029df9\" stroke-width=\"8\" fill=\"none\" stroke-lineCap=\"round\"&gt;&lt;/path&gt; &lt;path d=\"M508.720275,85.6448695 C519.572766,106.125165 510.370277,296.381449 510.370277,296.381449\" class=\"two\" stroke=\"#029df9\" stroke-width=\"8\" fill=\"none\" stroke-lineCap=\"round\"&gt;&lt;/path&gt; &lt;path d=\"M570.187369,93.0436865 C570.187369,93.0436865 703.312123,69.0165013 703.312123,103.354018 C703.312123,137.691534 595.118196,304.797696 595.118196,304.797696\" class=\"two\" stroke=\"#029df9\" stroke-width=\"8\" fill=\"none\" stroke-lineCap=\"round\"&gt;&lt;/path&gt; &lt;!-- three --&gt; &lt;path d=\"M149.593084,114.512754 C149.593084,80.6086232 265.458217,31.6263568 265.458217,144.647923 C265.458217,257.669489 149.593084,288.726563 149.593084,288.726563 L291.550902,288.726563\" class=\"three\" stroke=\"#90da32\" stroke-width=\"8\" fill=\"none\" stroke-lineCap=\"round\"&gt;&lt;/path&gt; &lt;path d=\"M391.00506,81.6608912 C297.400634,81.6608912 275.086722,284.767558 384.426619,284.767558 C493.766517,284.767558 484.609487,81.6608912 391.00506,81.6608912 Z\" class=\"three\" stroke=\"#90da32\" stroke-width=\"8\" fill=\"none\" stroke-lineCap=\"round\"&gt;&lt;/path&gt; &lt;path d=\"M508.720275,85.6448695 C519.572766,106.125165 510.370277,296.381449 510.370277,296.381449\" class=\"three\" stroke=\"#90da32\" stroke-width=\"8\" fill=\"none\" stroke-lineCap=\"round\"&gt;&lt;/path&gt; &lt;path d=\"M570.187369,93.0436865 C570.187369,93.0436865 703.312123,69.0165013 703.312123,103.354018 C703.312123,137.691534 595.118196,304.797696 595.118196,304.797696\" class=\"three\" stroke=\"#90da32\" stroke-width=\"8\" fill=\"none\" stroke-lineCap=\"round\"&gt;&lt;/path&gt;&lt;/svg&gt; (5) 矢量图形库 Raphael.jsRaphaël Reference 示例123456789101112131415161718192021222324252627282930&lt;script src=&quot;libs/raphael.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; // Creates canvas 320 × 200 at 10, 50 var paper = Raphael(10, 50, 320, 200); // Creates circle at x = 50, y = 40, with radius 10 var circle = paper.circle(50, 40, 10); // Sets the fill attribute of the circle to red (#f00) circle.attr(&quot;fill&quot;, &quot;#f00&quot;); // Sets the stroke attribute of the circle to white circle.attr(&quot;stroke&quot;, &quot;#fff&quot;); circle.click(function() &#123; this.animate(&#123; fill: &apos;#fe0&apos;, y: 100 &#125;, 500, &apos;bounce&apos;); &#125;) // circle.drag(function(dx,dy)&#123; // this.attr(&#123; // x: x + dx, // y: y + dy // &#125;) // &#125;,function()&#123; // x = this.attr(&apos;x&apos;) // y = this.attr(&apos;y&apos;) // &#125;)&lt;/script&gt; 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！ 公众号是坚持日更的，不发文的时候推送一些我觉得好用的前端网站或者看到的一些问题的解决方案，也更便于大家交流，就酱。","tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://wangchloe.vip/tags/HTML5/"}]},{"title":"每天10个前端知识点：HTML5(canvas应用)","date":"2017-04-22T19:27:35.000Z","path":"2017/04/23/blog35/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 (1) 应用 canvas笑脸 (2) 应用 canvas画图 (3) 应用 canvas变换 (4) 应用 canvas内长方形拖拽 (5) 应用 canvas内圆形拖拽 (6) 应用 下载canvas绘图 (7) 应用 canvas运动回调 (8) canvas框架 jCanvaScript.js (1) 应用 canvas笑脸12345678910111213141516171819202122232425262728293031323334&lt;canvas width=&quot;800&quot; height=&quot;1200&quot;&gt;&lt;/canvas&gt;&lt;script&gt; var oC = document.querySelector(&apos;canvas&apos;); var ctx = oC.getContext(&apos;2d&apos;); // face ctx.fillStyle = &apos;yellow&apos;; ctx.arc(400, 250, 180, 0, 2 * Math.PI, false); ctx.fill(); ctx.stroke(); // mouth ctx.beginPath(); ctx.lineCap = &apos;round&apos;; ctx.lineWidth = 20; ctx.fillStyle = &apos;red&apos;; ctx.arc(400, 280, 80, 0, Math.PI, false); // ctx.fill(); // 红色实心半圆张嘴笑脸 ctx.stroke(); // 黑色半圆弧微笑脸 // eyes ctx.beginPath(); ctx.fillStyle = &apos;black&apos;; ctx.moveTo(350, 200); ctx.arc(350, 200, 20, 0, 2 * Math.PI, false); ctx.moveTo(450, 200); ctx.arc(450, 200, 20, 0, 2 * Math.PI, false); ctx.closePath(); ctx.fill();&lt;/script&gt; (2) 应用 canvas画图12345678910111213141516171819202122232425262728293031323334&lt;canvas width=&quot;800&quot; height=&quot;600&quot;&gt;&lt;/canvas&gt;&lt;script&gt; var oC = document.querySelector(&apos;canvas&apos;); var ctx = oC.getContext(&apos;2d&apos;); oC.onmousedown = function(ev) &#123; var &#123; clientX, clientY &#125; = ev; ctx.moveTo(clientX, clientY) oC.onmousemove = function(ev) &#123; ctx.clearRect(0, 0, oC.width, oC.height); var &#123; clientX, clientY &#125; = ev; ctx.lineWidth = 5; ctx.lineTo(clientX, clientY); ctx.stroke(); &#125; oC.onmouseup = function() &#123; oC.onmousemove = null; oC.onmouseup = null; &#125; &#125;&lt;/script&gt; (3) 应用 canvas变换12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;canvas width=&quot;800&quot; height=&quot;600&quot;&gt;&lt;/canvas&gt; &lt;script&gt; var oC = document.querySelector(&apos;canvas&apos;); var ctx = oC.getContext(&apos;2d&apos;); var degree = 1; var x1 = 300; var y1 = 300; var w1 = 100; var h1 = 100; var x2 = 100; var y2 = 100; var w2 = 50; var h2 = 50; var rotate1 = 0; var rotate2 = 0; setInterval(function() &#123; ctx.clearRect(-oC.width, -oC.height, oC.width * 2, 2 * oC.height); ctx.save(); ctx.translate(x1, y1); ctx.rotate(rotate1); ctx.fillRect(-w1 / 2, -h1 / 2, w1, h1); ctx.restore(); ctx.save(); ctx.translate(x2, y2); ctx.rotate(rotate2); ctx.fillRect(-w2 / 2, -h2 / 2, w2, h2); ctx.restore() rotate1++; rotate2 += 0.2; &#125;, 100) function d2a(deg) &#123; return deg / 180 * Math.PI &#125; &lt;/script&gt; (4) 应用 canvas内长方形拖拽12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;canvas width=&quot;800&quot; height=&quot;600&quot;&gt;&lt;/canvas&gt;&lt;script&gt; var oC = document.querySelector(&apos;canvas&apos;); var ctx = oC.getContext(&apos;2d&apos;); var rect = &#123; x: 0, y: 0, w: 100, h: 100 &#125; ctx.fillRect( rect.x, rect.y, rect.w, rect.h ); oC.onmousedown = function(&#123; clientX, clientY &#125;) &#123; var &#123; x, y, w, h &#125; = rect; var disX = clientX - x; var disY = clientY - y; if ( clientX &gt; x &amp;&amp; clientX &lt; x + w &amp;&amp; clientY &gt; y &amp;&amp; clientY &lt; y + h ) &#123; oC.onmousemove = function(&#123; clientX, clientY &#125;) &#123; ctx.clearRect(0, 0, oC.width, oC.height) // **先清空画布再画 var deltaX = clientX - disX; var deltaY = clientY - disY; rect.x = deltaX; rect.y = deltaY; ctx.fillRect( rect.x, rect.y, rect.w, rect.h ); &#125; oC.onmouseup = function() &#123; oC.onmousemove = null; oC.onmouseup = null; &#125; &#125; &#125;&lt;/script&gt; (5) 应用 canvas内圆形拖拽12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;canvas width=&quot;800&quot; height=&quot;600&quot;&gt;&lt;/canvas&gt;&lt;script&gt; var oC = document.querySelector(&apos;canvas&apos;); var ctx = oC.getContext(&apos;2d&apos;); var circle = &#123; x: 50, y: 50, r: 50 &#125; ctx.arc(circle.x, circle.y, circle.r, 0, 2 * Math.PI, false); ctx.fill(); oC.onmousedown = function(&#123; clientX, clientY &#125;) &#123; var &#123; x, y, r &#125; = circle; var disX = clientX - x; var disY = clientY - y; if ( ctx.isPointInPath(clientX, clientY) // 利用isPointInPath函数 ) &#123; oC.onmousemove = function(&#123; clientX, clientY &#125;) &#123; ctx.clearRect(0, 0, oC.width, oC.height); ctx.beginPath(); var deltaX = clientX - disX; var deltaY = clientY - disY; circle.x = deltaX; circle.y = deltaY; ctx.arc(circle.x, circle.y, circle.r, 0, 2 * Math.PI, false); ctx.fill(); &#125; oC.onmouseup = function() &#123; oC.onmousemove = null; oC.onmouseup = null; &#125; &#125; &#125;&lt;/script&gt; (6) 应用 下载canvas绘图1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162&lt;canvas width=&quot;600&quot; height=&quot;400&quot;&gt;&lt;/canvas&gt;&lt;br&gt;&lt;button&gt;Download&lt;/button&gt;&lt;script&gt; var oC = document.querySelector(&apos;canvas&apos;); var ctx = oC.getContext(&apos;2d&apos;); var oBtn = document.querySelector(&apos;button&apos;); var data = [ rnd(100, 1000), rnd(100, 1000), rnd(100, 1000), rnd(100, 1000), rnd(100, 1000) ] var start = 0; var sum = sumUp(data); data.forEach(function(number, index) &#123; var color = `rgb($&#123;rnd(0,255)&#125;,$&#123;rnd(0,255)&#125;,$&#123;rnd(0,255)&#125;)`; var delta = number / sum * 2 * Math.PI; ctx.fillStyle = color; ctx.beginPath(); ctx.moveTo(300, 200) ctx.arc(300, 200, 100, start, start + delta, false); ctx.lineTo(300, 200) ctx.fill(); start = start + delta; &#125;) function sumUp(array) &#123; var sum = 0; array.forEach(function(n) &#123; sum += n &#125;) return sum; &#125; function rnd(n, m) &#123; return parseInt(Math.random() * (m - n) + n); &#125; // **下载canvas图片 oBtn.onclick = function() &#123; var oA = document.createElement(&apos;a&apos;); oA.href = oC.toDataURL(); oA.download = &apos;默认命名&apos;; // oA.download = fileName.value ? fileName.value : &apos;默认命名&apos; + &apos;.png&apos;; oA.click(); &#125;&lt;/script&gt; (7) 应用 canvas运动回调12345678910111213141516171819202122232425262728293031323334353637&lt;script&gt; function loadStatics(statics, callback) &#123; var count = 0; statics.forEach(function(path, index) &#123; var oImage = new Image(); oImage.src = `img/$&#123;path&#125;.png` resources[path] = oImage; oImage.onload = function() &#123; count++ if (count == statics.length) &#123; callback &amp;&amp; callback(); &#125; &#125; &#125;) &#125; function d2a(d) &#123; return d / 180 * Math.PI &#125; function a2d(a) &#123; return a / Math.PI * 180 &#125; function rnd(n, m) &#123; return parseInt(Math.random() * (m - n) + n) &#125; function rndSign() &#123; return Math.random() &lt; 0.5 ? -1 : 1 &#125;&lt;/script&gt; (8) canvas框架 jCanvaScript.jsjCanvaScript.js 示例123456789101112131415161718192021222324252627282930313233343536373839404142&lt;canvas id=&quot;c1&quot; width=&quot;500&quot; height=&quot;500&quot;&gt;&lt;/canvas&gt;&lt;script src=&quot;libs/jCanvaScript.1.5.18.min.js&quot;&gt;&lt;/script&gt;&lt;script&gt; var idCanvas = &quot;c1&quot;; onload_1(); var interval_1 = 0; function startShow() &#123; var r = Math.floor(Math.random() * (254)), g = Math.floor(Math.random() * (254)), b = Math.floor(Math.random() * (254)), x = Math.floor(Math.random() * (439)), y = Math.floor(Math.random() * (554)), color = &quot;rgba(&quot; + r + &quot;, &quot; + g + &quot;, &quot; + b + &quot;, 0.5)&quot;, filled = true, radius = 1; jc.circle(x, y, radius, color, filled) .animate(&#123; radius: 100, opacity: 0 &#125;, 1500, function() &#123; this.del(); &#125;); &#125; function onload_1() &#123; jc.start(idCanvas, true); interval_1 = setInterval(startShow, 200); &#125; function start_1(idCanvas) &#123; if (interval_1) return; onload_1(); &#125; function stop_1(idCanvas) &#123; clearInterval(interval_1); interval_1 = 0; jc.clear(idCanvas); &#125;&lt;/script&gt; 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！ 公众号是坚持日更的，不发文的时候推送一些我觉得好用的前端网站或者看到的一些问题的解决方案，也更便于大家交流，就酱。","tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://wangchloe.vip/tags/HTML5/"}]},{"title":"每天10个前端知识点：HTML5(canvas)","date":"2017-04-05T19:27:35.000Z","path":"2017/04/06/blog34/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 13. H5画布 canvas基于 JavaScript 的绘图 API &lt;canvas&gt;&lt;/canvas&gt; 获取绘图上下文1234&lt;script&gt; var oC = document.querySelector('canvas'); var ctx = oC.getContext('2d');&lt;/script&gt; ctx. moveTo(x, y) 移动 lineTo(x, y) 划线 fillStyle = “color” 更改填充颜色 fill() 填充 strokeStyle = “color” 更改描边样式 stroke() 描边 矩形ctx. fillRect(x, y, w, h) 填充矩形(没有路径) strokeRect(x, y, w, h) 描边矩形(没有路径) rect(x, y, w, h) 举行路径 clearRect(x, y, w, h) 清空区域 弧ctx. arc(cx, cy, r, startDegree, endDegree, anticlockwise) 圆心x，圆心y，半径，起始角度(弧度制)，结束角度(弧度制)，是否逆时针 fill() 填充 文本ctx. font = “字号 字体” textAlign = “left/center/right” 竖轴对齐方式 textBaseline =”top/middle/bottom” 横轴对齐方式 fillText(‘文字’, x, y) 填充文字 strokeText(‘文字’, x, y) 描边文字 measureText(‘文字’) 返回文字长度(width) ctx. beginPath() 开始路径 closePath() 闭合路径 线条样式ctx. lineCap = “round/butt(默认)/square” 更改线帽 lineJoin = “round/miter(默认)/bevel(切角)” 更改连接点样式 lineWidth = 20 线宽 阴影ctx. shadowColor 设置或返回阴影颜色 shadowBlur 设置或返回阴影模糊级别 shadowOffsetX 设置或返回阴影距形状的水平距离 shadowOffsetY 设置或返回阴影距形状的垂直距离 渐变ctx. createLinearGradient(x0, y0, x1, y1) 创建线性渐变 起始位置 结束位置（用在画布内容上） createPattern(img, “repeat|repeat-x|repeat-y|no-repeat”) 在指定的方向上重复指定的元素 createRadialGradient(x0, y0, r0, x1, y1, r1) 创建径向渐变 起始位置 结束位置（用在画布内容上） addColorStop(位置, 颜色) 规定渐变对象中的颜色和停止位置(0~1) 画图ctx. drawImage(img, x, y) 在画布上绘制图像、画布或视频 drawImage(img, x, y, width, height) drawImage(img, sx, sy, swidth, sheight, x, y, width, height) 剪切图像，并在画布上定位被剪切的部分 s-裁剪 1234567891011&lt;script&gt; var oC = document.querySelector(&apos;canvas&apos;); var ctx = oC.getContext(&apos;2d&apos;); var oImage = new Image(); oImage.src = &apos;xxx.png&apos;; oImage.onload = function() &#123; ctx.drawImage(oImage, 0, 0); &#125;&lt;/script&gt; 像素操作ctx. getImageData(x, y, w, h) 画布指定矩形复制像素数据 需服务器环境imgData包括{data, width, height} 其中data是像素数组 red=imgData.data[0]; green=imgData.data[1]; blue=imgData.data[2]; alpha=imgData.data[3]; putImageData(imgData, x, y) 将图像数据放回画布 变换ctx. scale(sW, sH) 缩放当前绘图至更大或更小 rotate(角度*Math.PI/180) 旋转当前绘图 translate(x, y) 重新映射画布上的 (0,0) 位置 注意translate和moveTo的区别 transform(a,b,c,d,e,f) 替换绘图的当前转换矩阵(相对变化) 水平缩放 水平倾斜 垂直倾斜 垂直缩放 水平移动 垂直移动 setTransform(a,b,c,d,e,f) 将当前转换重置为单位矩阵(不相对变化) 水平缩放 水平倾斜 垂直倾斜 垂直缩放 水平移动 垂直移动 ctx. isPointInPath(x, y) 点是否在路径内 ctx. save() 保存当前环境的状态 restore() 返回之前保存过的路径状态和属性 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！ 公众号是坚持日更的，不发文的时候推送一些我觉得好用的前端网站或者看到的一些问题的解决方案，也更便于大家交流，就酱。","tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://wangchloe.vip/tags/HTML5/"}]},{"title":"每天10个前端知识点：HTML5(线程、websocket)","date":"2017-04-03T19:27:35.000Z","path":"2017/04/04/blog33/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 H5 web工作线程 webworker (1) 方法 (2) 示例 H5 webSocket 网络套接字 11. H5 web工作线程 webworker 进程 线程 var worker = new Worker(&#39;js文件&#39;); 新建worker 需在服务器环境下 不会改变数据类型 不会改变父线程数据 DOM/BOM 不可使用(console.log可用) 只能有一层子线程，子线程不可再开子线程 (1) 方法 worker.postMessage(‘Data’) 向worker内传递数据 (1) worker.onmessage 监听事件 (4) worker.terminate 停止worker worker内部监听事件： this.onmessage -&gt; ev -&gt; ev.data //‘Data’ (2) this.postMessage 向父线程传递数据 (3) (2) 示例 主程序 12345&lt;script&gt; var worker = new Worker('./calc.js'); worker.postMessage(2);&lt;/script&gt; calc.js 1234567891011&lt;script&gt; this.onmessage = function(ev) &#123; console.log(ev.data) &#125; function fibonacci(n)&#123; if( n == 1 || n == 2 ) return 1; return fibonacci(n-1) + fibonacci(n-2); &#125;&lt;/script&gt; 12. H5 webSocket 网络套接字 客户端 1.发消息 -&gt; emit 2.接消息 -&gt; on 服务端 1.接消息 -&gt; on 2.发消息 -&gt; emit 在以前 HTTP 协议中所谓的 keep-alive connection 是指在一次 TCP 连接中完成多个 HTTP 请求，但是对每个请求仍然要单独发 header。 WebSocket 解决的第一个问题是，通过第一个 HTTP request 建立了 TCP 连接之后，之后的交换数据都不需要再发 HTTP request了，使得这个长连接变成了一个真.长连接。 Websocket只需要一次HTTP握手，所以说整个通讯过程是建立在一次连接/状态中，也就避免了HTTP的非状态性，服务端会一直知道你的信息，直到你关闭请求，这样就解决了接线员要反复解析HTTP协议。 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！ 公众号是坚持日更的，不发文的时候推送一些我觉得好用的前端网站或者看到的一些问题的解决方案，也更便于大家交流，就酱。","tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://wangchloe.vip/tags/HTML5/"}]},{"title":"我为什么不考研","date":"2017-04-03T19:12:48.000Z","path":"2017/04/04/life3/","text":"虽然距离17届考研结束已经很久很久了，但还是突发奇想来讨论这个话题。 我旁边很多朋友选择考研，我自己的六人寝里头就有五个考研党，也就是说除了我大家都选择了考研。 先不说我为什么不考研，我就近问我这些室友为什么考研，得到的答案让我诧异又苦笑。 他们说因为不想工作，惧怕工作，所以只能选择考研，而且还有可能因为这个原因一直读到博士。 这个答案是我没有想到的，我原以为是因为想要工作时有更多的优势，或者是想潜心更深入钻研。 我认识的朋友里面有考研数学打出147的，有考上交大大数据方向的，有考上复旦的。但还有更多的是类似于这些不想工作的结局大多是没有得到满意的结果。 因为从头就没想过考研所以我对考研这件事情是没有多少了解和认知的，我都不知道读研还要交学费这回事，😂笑哭。只能看到身边考研的这些人很匆忙，年前开始各种准备，买书、买视频、报培训班各种忙活，看来考研难度着实不小，但我没有这种经历是没有话语权的。 而我为什么不考研，理由其实也很简单。我个人觉得在学校待着读书近二十年，平时无所事事追剧追综艺，到了期末就开始一周周地通宵刷题，虽然这样都能年年能拿奖学金，可以说至少我保本校研是件很轻松的事。但我天生是个不安分的人，所以选择不再继续这种无所事事的环境了。再者我认为计算机这行更多在于实践，书本上得来的总觉得生涩且不易理解通透。而且女生念完本科已经22岁了，再读个研得25 26了，我不想把不多的青春年少耗费在一件不热衷的事情上。 上学时我是憧憬工作的，像电视剧的OL那样穿个小裙子踩双细高跟👠，然后徜徉在上海的陆家嘴，这应该就是大都市的魅力。 😂谁知道做程序员这行用不上我备好的黑西装和细高跟，落灰也只能闲置在家。 我还记得初中生物背了很久的一句“生物适应环境，环境影响生物”，我大概是把前者发挥地淋漓尽致的那类，也许可以归为一个处女座♍️的属性之一。这也是我没有惧怕工作的原因，无论到了什么样的环境，都能以最短的时间把自己及周边安顿好且舒适。我的室友经常讶异于我储物箱里各种使用的小工具又或者超龄的面面俱到的处事方式。从去年七月至今，想想我已经在外租住第十个月了，索性还能把自己的生活打理的不错，学会买菜做饭，一周打扫一次房间，除了堪忧且日渐增长的拖延症和健忘。 从小到大我也上过很多类别的培训班，画画、毛笔字、小提琴、游泳，然而却没有一项能坚持到现在。所以我很庆幸至少现在做的是一件自己能感兴趣并且近年内能钻研下去的一个行业。 我更庆幸从小到大所有重大决定都是我自己做的，也感谢父母无论何时都尊重我的决定。所以我没有埋怨父母的机会，也不会让自己后悔。选择不去最好的高中，选择就读的大学，选择不入党，选择计算机专业，选择不考研，选择留在上海。毕竟人的路只有一条，选择岔路口的左拐角你就不会再有机会知道右拐角的风景是什么样子，所以大胆往前走好了。🤷‍妹妹你大胆地往前走哇。 说这些并没有呵责谁的意思，纯属闲聊瞎侃，每个人都该有自己的想法，只想论述下自己对考研和不考研的观点。我也祝福那些得以在更高学府深造的同学，能看到不一样的风景，不同层次的导师同学。 祝福大家都能不乱于心，不困于情，不念过去，不畏将来。 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"爱生活","slug":"爱生活","permalink":"https://wangchloe.vip/tags/爱生活/"}]},{"title":"每天10个前端知识点：HTML5(选择器、自定义属性、存储)","date":"2017-03-19T19:27:35.000Z","path":"2017/03/20/blog31/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 H5地理位置 geolocation (1) 测试用例 (2) 百度地图API H5音频 audio (1) 属性 (2) 方法 (3) 应用：钢琴弹奏 (4) 应用：音乐播放器 7. H5地理位置 geolocationLBS -&gt; Location Based Service 基于位置服务 (1) 测试用例1234567&lt;script&gt; window.navigator.geolocation.getCurrentPosition(function(res) &#123; console.log(res); &#125;, function(err) &#123; console.log(err); &#125;)&lt;/script&gt; PositionError错误码 错误信息 code: 1message: &quot;User denied Geolocation&quot; -&gt; 用户拒绝授权 code: 1message: &quot;Only secure origins are allowed (see: https://goo.gl/Y0ZkNV). -&gt; 仅允许HTTPS访问 code:2message:&quot;Network location provider at &#39;https://www.googleapis.com/&#39; : No response received.&quot; -&gt; 没翻墙 (2) 百度地图API timestamp 时间戳 coords -&gt; 地理坐标 accuracy:26 -&gt; 精确度 altitude:null -&gt; 海拔 altitudeAccuracy:null -&gt; 海拔高度精确度 heading:null -&gt; 方向 latitude:31.167638 -&gt; 纬度 longitude:121.423593 -&gt; 经度 speed:null -&gt; 速度 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt; &lt;meta http-equiv=&quot;Content-Type&quot; content=&quot;text/html; charset=utf-8&quot; /&gt; &lt;meta name=&quot;viewport&quot; content=&quot;initial-scale=1.0, user-scalable=no&quot; /&gt; &lt;style type=&quot;text/css&quot;&gt; body, html,#allmap &#123; user-select: none; width: 100%; height: 100%; overflow: hidden; margin: 0; font-family: &quot;微软雅黑&quot;; &#125; &lt;/style&gt; &lt;script type=&quot;text/javascript&quot; src=&quot;http://api.map.baidu.com/api?v=2.0&amp;ak=wmwHFMPxi66GlPBVUrdgEhDzbLUqlSrM&quot;&gt;&lt;/script&gt; &lt;title&gt;上海师范大学 - 百度地图&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;allmap&quot;&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;&lt;script type=&quot;text/javascript&quot;&gt; var map = new BMap.Map(&quot;allmap&quot;); map.centerAndZoom(new BMap.Point(121.423593, 31.167638), 20); // 初始化地图,设置中心点坐标和地图级别 map.addControl(new BMap.MapTypeControl()); //添加地图类型控件 map.setCurrentCity(&quot;上海&quot;); // 设置地图显示的城市 此项是必须设置的 map.enableScrollWheelZoom(true); //开启鼠标滚轮缩放 navigator.geolocation.getCurrentPosition(function(res) &#123; var &#123; coords: &#123; longitude, latitude &#125; &#125; = res; var point = new BMap.Point(longitude, latitude); var marker = new BMap.Marker(point); map.addOverlay(marker); marker.setAnimation(BMAP_ANIMATION_BOUNCE) map.panTo(point) &#125;, function(err) &#123; console.log(err); &#125;)&lt;/script&gt; 8. H5音频 audio 音频格式：mp3 wma flat ape wav ogg (1) 属性 src -&gt; 音频路径 controls -&gt; 显示自带控制进度条 loop -&gt; 音频循环 autoplay -&gt; 自动播放 只有pc端可以实现 muted -&gt; 静音 currentTime -&gt; 当前播放时间 duration -&gt; 音频总时间 volume -&gt; 音量 [0,1] ontimeupdate -&gt; 进度更新 play -&gt; 是否在播放 返回true/false pause -&gt; 是否暂停 返回true/false (2) 方法 play() -&gt; 播放歌曲 pause() -&gt; 暂停歌曲 load() -&gt; 重新加载歌曲 onended() -&gt; 音频播放完毕 常见结构12345678910111213&lt;html&gt; &lt;audio src=\"xxx.mp3\" controls&gt;&lt;/audio&gt; &lt;!-- 显示音频自带播放器样式 --&gt; &lt;hr&gt; &lt;!-- 自定义播放器 --&gt; &lt;audio src=\"xxx.mp3\" id=\"a1\"&gt;&lt;/audio&gt; &lt;!-- 只显示下面的按钮 --&gt; &lt;!-- 进度条 --&gt; &lt;div class=\"progress\"&gt; &lt;div class=\"inner\"&gt;&lt;/div&gt; &lt;/div&gt; &lt;input type=\"range\" min=\"0\" max=\"100\" value=\"100\"&gt;音量 &lt;button onclick=\"aPlay()\"&gt;播放/暂停&lt;/button&gt; &lt;button onclick=\"aMute()\"&gt;静音&lt;/button&gt;&lt;/html&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;script&gt; var a1 = document.getElementById('a1'); var progress = document.querySelector('.progress'); var oInner = document.querySelector('.inner'); var oRange = document.querySelector('[type=range]'); // 自定义进度条 // setInterval(function() &#123; // oInner.style.width = (a1.currentTime / a1.duration) * 100 + '%'; // &#125;, 16); a1.ontimeupdate = function()&#123; oInner.style.width = (a1.currentTime / a1.duration) * 100 + '%'; &#125; progress.onclick = function(&#123; clientX &#125;) &#123; var leftDelta = clientX - this.offsetLeft; var percentage = leftDelta / this.offsetWidth; a1.currentTime = a1.duration * percentage; &#125; oRange.oninput = function()&#123; a1.volume = this.value/100; &#125; function aPlay() &#123; if (a1.paused) &#123; a1.play(); &#125; else &#123; a1.pause(); &#125; &#125; function aMute() &#123; a1.muted = !oA.muted; &#125;&lt;/script&gt; (3) 应用：钢琴弹奏 sound.js 钢琴示例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;钢琴示例&lt;/title&gt; &lt;style&gt; body &#123; user-select: none; &#125; ul, li &#123; list-style: none; margin: 0; padding: 0; &#125; ul &#123; width: 400px; margin: 40px auto; &#125; li &#123; width: 38px; border: 1px solid black; height: 198px; float: left; text-align: center; line-height: 350px; margin-left: 10px; transform-origin: top center; &#125; li:active &#123; transform: perspective(800px) rotateX(-10deg); &#125; li.active &#123; transform: perspective(800px) rotateX(-10deg); &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;li&gt;7&lt;/li&gt; &lt;li&gt;8&lt;/li&gt; &lt;/ul&gt; &lt;script src=&quot;statics/sound.js&quot;&gt;&lt;/script&gt; &lt;script&gt; var aLi = document.querySelectorAll(&apos;li&apos;); aLi.forEach(function(oLi, index) &#123; oLi.onmousedown = function() &#123; playSound(index + 49); &#125; &#125;) window.onkeydown = function(&#123; keyCode &#125;) &#123; playSound(keyCode); aLi[keyCode - 49].classList.add(&apos;active&apos;); &#125; window.onkeyup = function(&#123; keyCode &#125;) &#123; if (keyCode &gt;= 49 &amp;&amp; keyCode &lt;= 56) &#123; aLi[keyCode - 49].classList.remove(&apos;active&apos;); &#125; &#125; function playSound(index) &#123; new Audio(oggSound[`sound$&#123;index&#125;`]).play(); &#125; &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; (4) 应用：音乐播放器 歌词显示 12345678910111213141516171819202122232425262728293031323334&lt;!DOCTYPE html&gt;&lt;html lang=&quot;en&quot;&gt;&lt;head&gt; &lt;meta charset=&quot;UTF-8&quot;&gt; &lt;title&gt;Document&lt;/title&gt; &lt;style&gt; #box &#123; width: 200px; margin: 40px auto; text-align: center; padding: 10px; border: 2px solid black; -webkit-background-clip: text; background-image: linear-gradient(90deg, red 30%, blue 30%); color: transparent; &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div id=&quot;box&quot;&gt; 西湖的水我的泪 &lt;/div&gt; &lt;script&gt; var progress = 0; var oBox = document.querySelector(&apos;div&apos;); setInterval(function() &#123; oBox.style.backgroundImage = `linear-gradient(90deg,red $&#123;progress&#125;%,blue $&#123;progress&#125;%)` progress += 0.4; &#125;, 16) &lt;/script&gt;&lt;/body&gt;&lt;/html&gt; 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://wangchloe.vip/tags/HTML5/"}]},{"title":"每天10个前端知识点：HTML5(选择器、自定义属性、存储)","date":"2017-03-18T19:27:35.000Z","path":"2017/03/19/blog30/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 H5选择器补充 querySelectorAll 对比 getElements 的优势 jQuery的选择器即是querySelectorAll H5自定义属性 dataset H5元素类名操作 classList 隐式原型上的方法(不一一列举) H5本地存储 localStorage Web Storage实际上由两部分组成：sessionStorage与localStorage sessionStorage与localStorage操作相同 3. H5选择器补充*兼容：IE8+ document/dom.querySelector() 匹配指定 css 选择器的一个元素 querySelectorAll() 匹配指定 css 选择器的所有元素 (NodeList) 注意： querySelectorAll()方法得到的类数组对象是非动态实时的 querySelectorAll 对比 getElements 的优势可以操作数组 123&lt;div class=\"box\"&gt;&lt;/div&gt;&lt;div class=\"box\"&gt;&lt;/div&gt;&lt;div class=\"box\"&gt;&lt;/div&gt; 12345678910111213141516171819&lt;script&gt; var aBox = document.querySelectorAll('div'); // getElements得到的是伪数组，不能操作各项的属性 // var aBox = document.getElementsByTagName('div'); // for (var i = 0; i &lt; aBox.length; i++) &#123; // aBox[i].onclick = function() &#123; // alert(1); // &#125; // &#125; aBox.forEach(function(item, index) &#123; item.onclick = function() &#123; alert(index); // 弹出当前点击div的索引值，依次为0、1、2 &#125; &#125;)&lt;/script&gt; jQuery的选择器即是querySelectorAll12345678910111213&lt;script&gt; function $(selector) &#123; var items = document.querySelectorAll(selector); if(items.length &gt; 1) &#123; return items; &#125; else if (items.length == 0) &#123; return; &#125; else &#123; return items[0]; &#125; &#125;&lt;/script&gt; 4. H5自定义属性 datasetHTML5自定义属性对象Dataset简介 HTML5 datalist在实际项目中应用的可行性研究 示例1&lt;a data-link=\"#\" data-user-name=\"chloe\"&gt;wangchloe.vip&lt;/a&gt; 1234567&lt;script&gt; var oA = document.querySelector('a'); oA.dataset.link = 'http://wangchloe.vip'; oA.href = oA.dataset.link + '?name=' + oA.dataset.userName; // http://wangchloe.vip?name=chloe // *注意：两个及以上属性名调用时需转化为驼峰命名&lt;/script&gt; 5. H5元素类名操作 classListHTML5 DOM元素类名相关操作API classList简介 12&lt;!-- 该示例来源于张鑫旭个人博客 --&gt;&lt;body class=\"a b c\"&gt;&lt;/body&gt; 12345&lt;script&gt; console.log(document.body.classList); console.log(document.body.className); console.log(document.body.classList.toString() === document.body.className;) // true&lt;/script&gt; HTML5 DOM元素类名相关操作API classList简介&gt;&gt;&gt;测试 隐式原型上的方法(不一一列举) obj.add(cName1, cName2, …); obj.remove(cName1, cName2, …); obj.toggle(cName); obj.contains(cName); 6. H5本地存储 localStorageHTML5 localStorage本地存储实际应用举例 cookie &amp;&amp; localStorage &amp;&amp; sessionStorage (来源CSDN) 共同点： 都是保存在浏览器端，且同源的。 不同点： cookie数据始终在同源的http请求中携带（即使不需要），即cookie在浏览器和服务器间来回传递。而sessionStorage和localStorage不会自动把数据发给服务器，仅在本地保存。 cookie数据还有路径（path）的概念，可以限制cookie只属于某个路径下。 存储大小限制也不同，cookie数据不能超过4k，同时因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如会话标识。sessionStorage和localStorage 虽然也有存储大小的限制，但比cookie大得多，可以达到5M或更大。 数据有效期不同，sessionStorage：仅在当前浏览器窗口关闭前有效，自然也就不可能持久保持；localStorage：始终有效，窗口或浏览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前一直有效，即使窗口或浏览器关闭。 作用域不同，sessionStorage不在不同的浏览器窗口中共享，即使是同一个页面；localStorage 在所有同源窗口中都是共享的；cookie也是在所有同源窗口中都是共享的。 Web Storage 支持事件通知机制，可以将数据更新的通知发送给监听者。Web Storage 的 api 接口使用更方便。 Web Storage实际上由两部分组成：sessionStorage与localStorage sessionStorage用于本地存储一个会话(session)中的数据，这些数据只有在同一个会话中的页面才能访问并且当前会话结束后数据也随之销毁。因此sessionStorage不是一种持久化的本地存储，仅仅是会话级别的存储。 localStorage用于持久化的本地存储，除非主动删除数据，否则数据是永远不会过期的。 *兼容：可以先测试，以确定window.localStorage是否存在。 sessionStorage与localStorage操作相同 设置 localStorage.key = value; localStorage.setItem(key, value); 12345678910&lt;script&gt; var userName = 'chloe'; //存储，IE6~7 cookie 其他浏览器HTML5本地存储 if (window.localStorage) &#123; localStorage.setItem(\"name\", userName); &#125; else &#123; Cookie.write(\"name\", userName); // MooTools框架下cookie的写法 &#125;&lt;/script&gt; 读取 localStorage.key; localStorage.getItem(key); 123&lt;script&gt; var userName = window.localStorage ? localStorage.getItem(\"name\") : Cookie.read(\"name\"); // MooTools框架下cookie的写法&lt;/script&gt; 遍历 12345678&lt;script&gt; var storage = window.localStorage; for (var i = 0, len = storage.length; i &lt; len; i++) &#123; var key = storage.key(i); var value = storage.getItem(key); console.log(key + \"=\" + value); &#125;&lt;/script&gt; 删除 delete localStorage.key; localStorage.removeItem(key); 1234567&lt;script&gt; if (window.localStorage) &#123; localStorage.removeItem(\"name\"); &#125; else &#123; Cookie.dispose('name'); // MooTools框架下cookie的写法 &#125;&lt;/script&gt; 清空 localStorage.clear(); 监听window.onStorage 监听localStorage变化 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://wangchloe.vip/tags/HTML5/"}]},{"title":"每天10个前端知识点：HTML5(新增元素及属性)","date":"2017-03-17T19:27:35.000Z","path":"2017/03/18/blog29/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 HTML5语法概要 H5新增元素 (1) 结构元素 (2) 其他元素 (3) input元素类型 (4) *废除的元素 H5新增属性 (1) 表单相关属性 (2) 链接相关属性 (3) 其他属性 (4) *废除属性 (5) 全局属性 翻译-你必须知道的28个HTML5特征、窍门和技术 html5shiv项目让IE6-IE9浏览器都支持HTML5中的元素 HTML5语法概要 内容类型 DOCTYPE声明 指定字符编码 可以省略标记的元素 具有boolean值的元素 省略行内属性赋值的引号 1. H5新增元素 (1) 结构元素section对网站内容分块、分段当容器需要被直接定义样式或通过脚本定义行为时，推荐使用div而非section 结构(标题+内容)1234&lt;section&gt; &lt;h1&gt;&lt;/h1&gt; &lt;p&gt;&lt;/p&gt;&lt;/section&gt; article代表文档内容 独立性 可嵌套使用可看作特殊的section元素 常见结构12345678910111213&lt;article&gt; &lt;header&gt; &lt;h1&gt;&lt;/h1&gt; &lt;/header&gt; &lt;article&gt; &lt;header&gt; &lt;h2&gt;&lt;/h2&gt; &lt;/header&gt; &lt;p&gt;&lt;/p&gt; &lt;footer&gt;&lt;/footer&gt; &lt;/article&gt; &lt;footer&gt;&lt;/footer&gt;&lt;/article&gt; aside用来表示当前页面或文章的附属信息(相关引用、侧边栏、广告、导航条) 常见结构1234567891011121314151617181920&lt;header&gt; &lt;h1&gt;&lt;/h1&gt;&lt;/header&gt;&lt;article&gt; &lt;h1&gt;&lt;/h1&gt; &lt;p&gt;&lt;/p&gt; &lt;aside&gt; &lt;h1&gt;&lt;/h1&gt; &lt;p&gt;&lt;/p&gt; &lt;/aside&gt;&lt;/article&gt;&lt;aside&gt; &lt;nav&gt; &lt;h2&gt;评论&lt;/h2&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"javascipt:;\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascipt:;\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;/aside&gt; nav常见应用：导航条、侧边栏导航、页内导航、翻页操作不能用menu元素代替nav元素 常见结构1234567891011121314151617181920212223242526272829&lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"javascript:;\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript:;\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/nav&gt;&lt;article&gt; &lt;header&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"javascript\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"javascript\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt; &lt;/header&gt; &lt;section&gt; &lt;h1&gt;&lt;/h1&gt; &lt;p&gt;&lt;/p&gt; &lt;/section&gt; &lt;section&gt; &lt;h1&gt;&lt;/h1&gt; &lt;p&gt;&lt;/p&gt; &lt;/section&gt; &lt;footer&gt; &lt;a href=\"javascript:;\"&gt;&lt;/a&gt; &lt;a href=\"javascript:;\"&gt;&lt;/a&gt; &lt;/footer&gt;&lt;/article&gt; figuretime用来区分各时区或编码 常见结构12&lt;time datetime=\"2017-1-1\"&gt;2017-1-1&lt;/time&gt;&lt;time datetime=\"2017-1-1T20:00\"&gt;2017-1-1&lt;/time&gt; pubdate指明发布时间 常见结构12345678&lt;article&gt; &lt;header&gt; &lt;h1&gt;&lt;/h1&gt; &lt;p&gt; &lt;time datetime=\"2017-1-1\" pubdate&gt;2017-1-1&lt;/time&gt; &lt;/p&gt; &lt;/header&gt;&lt;/article&gt; headerheader可出现多次 常见结构123456789101112131415&lt;header&gt; &lt;h1&gt;&lt;/h1&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;/header&gt;&lt;article&gt; &lt;header&gt; &lt;h1&gt;&lt;/h1&gt; &lt;/header&gt;&lt;/article&gt; footerfooter可出现多次常见应用：脚注(相关链接、版权信息) 常见结构1234567&lt;footer&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"\"&gt;版权信息&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;联系我们&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"\"&gt;加入我们&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/footer&gt; hgroup将标题及其子标题进行分组 常见结构1234567891011121314&lt;article&gt; &lt;header&gt; &lt;hgroup&gt; &lt;h1&gt;主标题&lt;/h1&gt; &lt;h2&gt;子标题&lt;/h2&gt; &lt;/hgroup&gt; &lt;p&gt; &lt;time datetime=\"2017-1-1\"&gt;2017-1-1&lt;/time&gt; &lt;/p&gt; &lt;/header&gt; &lt;div&gt;&lt;/div&gt; &lt;footer&gt; &lt;/footer&gt;&lt;/article&gt; address在文档中呈现联系信息(作者名字、网站连接、电子邮箱、地址、手机号) 常见结构123456789101112&lt;address&gt; &lt;a href=\"\"&gt;&lt;/a&gt; &lt;a href=\"\"&gt;&lt;/a&gt;&lt;/address&gt;&lt;footer&gt; &lt;div&gt; &lt;address&gt; &lt;a href=\"\"&gt;&lt;/a&gt; &lt;/address&gt; &lt;time datetime=\"2017-1-1\"&gt;2017-1-1&lt;/time&gt; &lt;/div&gt;&lt;/footer&gt; 整体应用123456789101112131415161718192021222324252627&lt;header&gt; &lt;h1&gt;xxx&lt;/h1&gt; &lt;nav&gt; &lt;ul&gt; &lt;li&gt;&lt;a href=\"#\"&gt;a1&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href=\"#\"&gt;a2&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/nav&gt;&lt;/header&gt;&lt;article&gt; &lt;hgroup&gt; &lt;h1&gt;主标题&lt;/h1&gt; &lt;h2&gt;子标题&lt;/h2&gt; &lt;/hgroup&gt; &lt;p&gt;正文&lt;/p&gt; &lt;section&gt; &lt;div&gt; &lt;article&gt; &lt;h1&gt;评论标题&lt;/h1&gt; &lt;p&gt;评论正文&lt;/p&gt; &lt;/article&gt; &lt;/div&gt; &lt;/section&gt;&lt;/article&gt;&lt;footer&gt; &lt;small&gt;版权***&lt;/small&gt;&lt;/footer&gt; (2) 其他元素video不同浏览器支持的格式不同，可能需要转码，在source标签里引入多种格式 FF不支持mp4，支持ogg controls属性显示自带控制进度条 常见结构1234567891011&lt;html&gt; &lt;video src=\"xxx.mp4\" controls&gt;&lt;/video&gt; &lt;hr&gt; &lt;video controls&gt; &lt;source src=\"xxx.mp4\"&gt; &lt;source src=\"xxx.ogg\"&gt; &lt;/video&gt; &lt;hr&gt; &lt;video src=\"xxx.mp4\" id=\"v1\" width=\"400px\" height=\"200px\"&gt;&lt;/video&gt; &lt;button onclick=\"play()\"&gt;播放/暂停&lt;/button&gt;&lt;/html&gt; 12345678910&lt;script&gt; var v1 = document.getElementById('v1'); function play() &#123; if(v1.paused) &#123; v1.play(); &#125; else &#123; v1.pause(); &#125; &#125;&lt;/script&gt; audiocontrols属性显示自带控制进度条 常见结构123456&lt;html&gt; &lt;audio src=\"xxx.mp3\" controls&gt;&lt;/audio&gt; &lt;!-- 显示音频自带播放器样式 --&gt; &lt;hr&gt; &lt;audio src=\"xxx.mp3\" id=\"a1\"&gt;&lt;/audio&gt; &lt;!-- 只显示下面的按钮 --&gt; &lt;button onclick=\"play()\"&gt;播放/暂停&lt;/button&gt;&lt;/html&gt; 12345678910&lt;script&gt; var a1 = document.getElementById('a1'); function play() &#123; if(a1.paused) &#123; a1.play(); &#125; else &#123; a1.pause(); &#125; &#125;&lt;/script&gt; canvas…(3) input元素类型 email url number range date time Date Pickers (4) *废除的元素 能用CSS替代的元素：basefont、big、center、font、s、tt、u等 frame框架 只有部分浏览器支持的元素 2. H5新增属性(1) 表单相关属性####formform的元素可写在form外，只要指向相同id 常见结构1234&lt;form id=\"form1\"&gt; &lt;input type=\"text\"&gt;&lt;/form&gt;&lt;textarea form=\"form1\"&gt;&lt;/textarea&gt; formaction不同表单元素不同action路径 常见结构123456&lt;form id=\"form1\"&gt; &lt;input type=\"text\"&gt; &lt;input type=\"submit\" name=\"s1\" value=\"v1\" formaction=\"fc1\"&gt; &lt;input type=\"submit\" name=\"s2\" value=\"v2\" formaction=\"fc2\"&gt; &lt;input type=\"submit\" name=\"s3\" value=\"v3\" formaction=\"fc3\"&gt;&lt;/form&gt; formmethod不同表单元素不同提交方法 常见结构12345&lt;form id=\"form1\"&gt; &lt;input type=\"text\"&gt; &lt;input type=\"submit\" name=\"s1\" value=\"v1\" formmethod=\"get\" formaction=\"fc1\"&gt; &lt;input type=\"submit\" name=\"s2\" value=\"v2\" formmethod=\"post\" formaction=\"fc2\"&gt;&lt;/form&gt; formenctype不同表单元素不同编码方式 常见结构123456&lt;form id=\"form1\"&gt; &lt;input type=\"text\" formenctype=\"text/plain\" value=\"表单数据中的空格转换为加号\"&gt; &lt;input type=\"text\" formenctype=\"multipart/form-data\" value=\"文件上传\"&gt; &lt;input type=\"text\" formenctype=\"application/x-www-form-urlencoded\" value=\"get方式时把表单数据转换为字符\"&gt;&lt;/form&gt;&lt;textarea form=\"form1\"&gt;&lt;/textarea&gt; formtarget不同表单元素不同提交后在何处打开加载页面 常见结构12345678&lt;form id=\"form1\"&gt; &lt;input type=\"text\"&gt; &lt;input type=\"submit\" name=\"s1\" value=\"v1\" formtarget=\"_blank\" formaction=\"fc1\"&gt; &lt;input type=\"submit\" name=\"s1\" value=\"v1\" formtarget=\"_self\" formaction=\"fc1\"&gt; &lt;input type=\"submit\" name=\"s1\" value=\"v1\" formtarget=\"_parent\" formaction=\"fc1\"&gt; &lt;input type=\"submit\" name=\"s1\" value=\"v1\" formtarget=\"_top\" formaction=\"fc1\"&gt; &lt;input type=\"submit\" name=\"s1\" value=\"v1\" formtarget=\"framename\" formaction=\"fc1\"&gt;&lt;/form&gt; autofocus表单元素自动获得焦点 常见结构1234&lt;form id=\"form1\"&gt; &lt;input type=\"text\" autofocus&gt; &lt;input type=\"text\"&gt;&lt;/form&gt; require提交时内容为空不允许提交，并显示提示 常见结构12345&lt;form id=\"form1\"&gt; &lt;input type=\"text\" required&gt; &lt;input type=\"text\"&gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; labels验证提示信息 常见结构12345&lt;form id=\"form1\"&gt; &lt;label for=\"t1\" id=\"l1\"&gt;&lt;/label&gt; &lt;input type=\"text\" id=\"t1\"&gt; &lt;input type=\"button\" id=\"btn1\" value=\"验证\" onclick=\"validate()\"&gt;&lt;/form&gt; 1234567891011121314&lt;script&gt; function validate() &#123; var t1 = document.getElementById('t1'); var btn1 = document.getElementById('btn1'); var fm1 = document.getElementById('form1'); if(t1.value.trim() == \"\") &#123; var l1 = document.getElementById('l1'); l1.setAttribute('for', 't1'); f1.insertBefore(l1, btn1); // 在button前显示验证提示信息 t1.labels[1].innerHTML = '输入为空'; &#125; &#125;&lt;/script&gt; placeholder输入提示信息 常见结构123&lt;form id=\"form1\"&gt; &lt;input type=\"text\" placeholder=\"请输入...\"&gt;&lt;/form&gt; datalist可输入的下拉框 常见结构1234567&lt;form id=\"form1\"&gt; &lt;input type=\"text\" name=\"n1\" list=\"ns\"&gt; &lt;!-- 点击下拉箭头时显示datalist --&gt; &lt;datalist id=\"ns\" style=\"display: none\"&gt; &lt;option value=\"v1\"&gt;v1&lt;/option&gt; &lt;option value=\"v2\"&gt;v2&lt;/option&gt; &lt;/datalist&gt;&lt;/form&gt; autocomplete输入自动填充 pattern表单元素正则验证，输入错误时不跳转 常见结构1234&lt;form id=\"form1\" action=\"xxx\"&gt; &lt;input type=\"text\" pattern=\"&#123;a-z&#125;[3]\" &gt; &lt;input type=\"submit\"&gt;&lt;/form&gt; selectionDirection*Chrome不支持 indeterminate复选框checkbox 的第三种状态 “尚未明确是否选取”状态 image按钮的width/height(2) 链接相关属性(3) 其他属性(4) *废除属性(5) 全局属性contentEditabledesignModehiddenspellcheck 拼写检查tabindex 设置tab键焦点的顺序 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://wangchloe.vip/tags/HTML5/"}]},{"title":"每天10个前端知识点：HTML5目录","date":"2017-03-15T19:27:35.000Z","path":"2017/03/16/blog28/","text":"HTML5语法概要 H5新增元素 (1) 结构元素 (2) 其他元素 (3) input元素类型 (4) *废除的元素 H5新增属性 (1) 表单相关属性 (2) 链接相关属性 (3) 其他属性 (4) *废除属性 (5) 全局属性 H5选择器补充 querySelectorAll 对比 getElements 的优势 jQuery的选择器即是querySelectorAll H5自定义属性 dataset H5元素类名操作 classList 隐式原型上的方法(不一一列举) H5本地存储 localStorage Web Storage实际上由两部分组成：sessionStorage与localStorage sessionStorage与localStorage操作相同 H5地理位置 geolocation (1) 测试用例 (2) 百度地图API H5音频 audio (1) 属性 (2) 方法 (3) 应用：钢琴弹奏 (4) 应用：音乐播放器 H5视频 video (1) 属性 (2) 方法 H5文件 FileReader (1) 文件拖拽 (2) File接口 (3) 示例 H5 web工作线程 webworker (1) 方法 (2) 示例 H5 webSocket 网络套接字 H5画布 canvas (1) 应用 canvas笑脸 (2) 应用 canvas画图 (3) 应用 canvas变换 (4) 应用 canvas内长方形拖拽 (5) 应用 canvas内圆形拖拽 (6) 应用 下载canvas绘图 (7) 应用 canvas运动回调 (8) canvas框架 jCanvaScript.js H5内联SVG (1) 位图 &amp;&amp; 矢量图 (2) SVG使用 (3) SVG梗概 (4) SVG应用 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"HTML5","slug":"HTML5","permalink":"https://wangchloe.vip/tags/HTML5/"}]},{"title":"每天10个前端知识点：代码管理及常见命令","date":"2017-03-13T19:27:35.000Z","path":"2017/03/14/blog27/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 svn代码版本管理工具 git分布式版本控制系统 工作区 缓存区 本地仓库 服务器仓库 其他 reset的两种用法 reset命令的3种方式 git的使用姿势 本地代码放到github上 服务器仓库已有项目 多人合作 关于SSH配置 git与svn的区别 常用命令 DOS Linux 编辑文件 Node.js 常用快捷键 Windows Firebug 调试 Sublime Emmet 1. svn代码版本管理工具Subversion 更新 update 修改 增加(已存在文件跳过这步) add 提交(注释) commit 2. git分布式版本控制系统 工作区 -&gt; 缓存区 -&gt; 本地仓库 -&gt; 服务器仓库 工作区 git init 当前目录改为git目录，变为工作区 缓存区 git add xx.txt 添加一个文件至缓存区 git add . 添加所有文件至缓存区 git rm --cache xx.txt 从缓存区删除一个文件 本地仓库 git commit -m &#39;注释&#39; 添加文件至本地仓库 服务器仓库 git remote add origin &lt;github上的链接&gt; git push -u origin master 其他 git status 查看git此时状态 git log 日志 git reset 跟一个commit(key)回到某个状态下 reset的两种用法 git reset [-q] [commit] [--] &lt;paths&gt; git reset [--soft | --mixed | --hard | --merge | --keep] [-q] [&lt;commit&gt;] reset命令的3种方式 git reset –mixed 此为默认方式，不带任何参数的git reset，即时这种方式，它回退到某个版本，只保留源码，回退commit和index信息 git reset –soft 回退到某个版本，只回退了commit的信息，不会恢复到index file一级。如果还要提交，直接commit即可 git reset –hard 彻底回退到某个版本，本地的源码也会变为上一个版本的内容 eg: git reset --hard HEAD^ 最新一次提交的父提交 3. git的使用姿势(1) 本地代码放到github上服务器上没有 跟github建立一个关系 git remote add origin &lt;github上的链接&gt; 推送到github上 git push -u origin master (2) 服务器仓库已有项目git clone &lt;github上的链接&gt; 多人合作 git merge 和 git rebase 小结 关于SSH配置http://jingyan.baidu.com/article/5bbb5a1b17107e13eba179d1.html注意：id_rsa.pub才是公用秘钥，把这个放进github 配置 git config -l 查看此时git的配置文件 git config --global user.name &#39;名字&#39; git config --global user.email &#39;邮箱地址&#39; 4. git与svn的区别 来源博客 git是分布式的，svn不是。git跟svn一样有自己的集中式版本库或服务器。但git更倾向于被使用于分布式模式，克隆版本库后即使没有网络也能够commit文件，查看历史版本记录，创建项目分支等，等网络再次连接上Push到服务器端。 git把内容按元数据方式存储，而svn是按文件。所有的资源控制系统都是把文件的元信息隐藏在一个类似.svn,.cvs等的文件夹里。git目录是处于你的机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签，分支，版本记录等。 git没有一个全局的版本号，svn有。 git的内容完整性优于svn。因为git的内容存储使用的是SHA-1哈希算法。 git可以有无限个版本库，svn只能有一个指定中央版本库。当svn中央版本库有问题时，所有工作成员都一起瘫痪直到版本库维修完毕或者新的版本库设立完成。每一个git都是一个版本库，区别是它们是否拥有活跃目录（Git Working Tree）。如果主要版本库（例如：置於GitHub的版本库）有问题，工作成员仍然可以在自己的本地版本库（local repository）提交，等待主要版本库恢复即可。工作成员也可以提交到其他的版本库！ 5. 常用命令这些命令碰见了再慢慢补全吧 DOS d: 切换盘符 dir 查看当前目录(文件夹)下所有文件夹及文件 cls 清屏 cd xx 进入目录(文件夹) Linux ls 查看当前目录(文件夹)下所有文件夹及文件 cd xx 进入xx文件夹 cd .. 返回上级目录(文件夹) cd / 返回根目录 touch xx 创建文件并命名为xx rm xx 删除文件xx clear 清屏 cat xx 查看文件xx的内容 mkdir xx 创建目录(文件夹)并命名为xx rmdir xx 删除目录(文件夹)xx，当文件夹内容不为空时不能删除 rmdir -rf 删除目录(文件夹)xx并删除其内容 编辑文件 进入文件 vi 文件名 启用编辑 按insert键 开始编辑 保存 esc -&gt; :wq+ -&gt; 回车 快捷命令 创建文件并且输入内容 echo 内容 &gt; xxx.txt http://www.cnblogs.com/roucheng/p/linuxdos.html Node.js这是一次看慕课视频的时候记下的 npm ls -g 显示全局所有安装包 --depth=1 最多展示一层 &gt; 重定向 2&gt;/dev/null 1 stand out 2 stand error 输出错误重定向到空设备文件 | 上一个输出内容转为下一个输入内容 grep xxx- 检索xxx开头的安装包 6. 常用快捷键Windows 显示桌面 Win + D 打开资源管理器 Win + E 相当于鼠标右键（等同于Shift + F10）） 新建文件夹 Ctrl + Shift + N 焦点移至任务栏托盘区 Win + B 打开所有活动窗口的切换栏 Ctrl + Shift + Alt +Tab 与上条想必按键松开切换栏会消失 Alt + Tab 打开Windows放大镜 Win + &quot;+&quot; 关闭当前标签页（浏览器中应用较多） Ctrl + W 关闭窗口/关机 Alt + F4 定位到地址栏并选中文本（资源管理器/浏览器） Ctrl + L 快速定位到地址栏（资源管理器浏览器） Alt + D 刷新页面（浏览器）Ctrl + R 显示主窗口的“系统”菜单 Alt + Space 切换到多文档界面的下一个子窗口 Ctrl + Tab 在同一个程序多个窗口之间切换 Alt + F6 打开选定对象的属性 Alt + Enter 重命名对象 F2 查找所有文件 F3 在资源管理器中的窗格之间移动 F6 Firebug 打开Firebug F12 在新窗口中打开Firebug Ctrl + F12 快速定位元素 Ctrl + Shift +C 调试设置断点后 继续 F8 单步跳过 F10 单步进入 F11 单步退出 Shift + F11 Sublime 选中一个元素 Ctrl + D 多选中同一个相同的元素 按住Ctrl + D不放 多行光标定位 eg:选中前五行 -&gt; Ctrl + Shift +L (光标定位在前五行末尾) —&gt; Home (光标定位在前五行行首) —&gt; Shift（不动）+ End（7次） (选中前五行的前7个字符) 或 —&gt; Ctrl + Shift +End(3次) (选中前五行的前三列) 全屏 F11 快速打开文件 Ctrl + P 打开命令面板 Ctrl + Shift + P 打开/关闭SideBar Ctrl + K/B 放大/缩小字号 Ctrl + &quot;+&quot;/&quot;-&quot; 打开一个新页面 Ctrl + N 在多个页面中跳转 Ctrl + Tab 合并两行（光标定位在第一行末尾处） Ctrl + J 缩进/退回一个级别 Ctrl + &quot;]&quot;/&quot;[&quot; 选中当前行 Ctrl + L 当前行下方新建行（允许光标不在当前行末尾时使用） Ctrl + Enter 当前行上方新建行（允许光标不在当前行末尾时使用） Ctrl + Shift + N 调整页面缩进 Ctrl + Shift + P —&gt;reindent lines 打开控制台 Ctrl + （Tab上面那个键） -&gt;输入Sublime.log_command(True)查看命令名及参数 本文件查找字符串 `Ctrl + F -&gt; Enter 查找下一处或-&gt;Shift + Enter查找上一处` 关闭当前文档 Ctrl + W 护肤已关闭的标签 Ctrl + Shift + T 删除当前行 Ctrl + X 当前位置插入注释 Ctrl + Shift + / 从光标处开始删除代码至行尾 Ctrl + K + K 闭合标签 Alt + &quot;.&quot; 默认1屏 Alt + Shift + &quot;1&quot; 左右分屏2列 Alt + Shift + &quot;2&quot; 左右分屏3列 Alt + Shift + &quot;3&quot; 左右分屏4列 Alt + Shift + &quot;4&quot; 上下左右等分4屏（“田”字） Alt + Shift + &quot;5&quot; 垂直等分2屏 Alt + Shift + &quot;8&quot; 垂直等分3屏 Alt + Shift + &quot;9&quot; 选中当前最小区域 Ctrl + Shift +Space -&gt; Ctrl +Shift + Space 向外扩展选中区域 局部矩形选中字符 鼠标滚轮按住拖动 去除最内层标签嵌套（光标定位在最内层） Ctrl + Shift + &quot;;&quot; ctrl+shift+d 复制粘贴当前行 ctrl+shift+[ 折叠代码 ctrl+shift+] 展开代码 ctrl+shift+v 粘贴并格式化 ctrl+g 跳转到第几行 ctrl+m 跳转到对应括号 ctrl+w 关闭当前文件 ctrl+r 前往method alt+数字 切换至当前窗口的第N个文件 alt+. 闭合标签 alt+F3 选中所有相同的词 ctrl+鼠标左键点击 标记多个光标 ###Emmet p20 -&gt; Tab -&gt; padding: 20px; m0-auto -&gt; Tab -&gt; margin: 0 auto; .nav -&gt; Tab -&gt; &lt;div calss= &quot;nav&quot;&gt;&lt;/div&gt; #nav -&gt; Tab -&gt; &lt;div id= &quot;nav&quot;&gt;&lt;/div&gt; .siderbar&gt;.nav -&gt; Tab -&gt; 123&lt;div calss= &quot;siderbar&quot;&gt; &lt;div class=&quot;nav&quot;&gt;&lt;/div&gt;&lt;/div&gt; ul.nav&gt;.li*3 -&gt; Tab -&gt; 12345&lt;ul calss= &quot;nav&quot;&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 选中需嵌套的字符串 Ctrl + Shift +G -&gt;`xxx.sidebar-&gt;&lt;div class= &quot;sidebar&quot;&gt;&lt;/div&gt;` `.sidebar&gt;navxxx.sidebar&gt;#navxxx` 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"工具","slug":"工具","permalink":"https://wangchloe.vip/tags/工具/"}]},{"title":"小厨教你做红烧鱼","date":"2017-03-09T19:12:48.000Z","path":"2017/03/10/life1/","text":"有人不服我的鱼头，来来来，前端技术比不过做饭我还是有信心的！ 无媛无故-小厨教你做红烧鱼 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"爱做饭","slug":"爱做饭","permalink":"https://wangchloe.vip/tags/爱做饭/"}]},{"title":"每天10个前端知识点：算法与数据结构","date":"2017-03-01T19:27:35.000Z","path":"2017/03/02/blog26/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 这篇真的写的相当好，我记得有一次见过bat的面试题是要把算法过程以柱状图形势展现。十大经典排序算法总结（JavaScript描述） 1. 查找算法以有序数组查找定值为例(1) 线性查找 循环遍历比较 eg: findInArr 12345678910&lt;script&gt; function findInArr(item, arr) &#123; for (var i = 0; i &lt; arr.length; i++) &#123; if (arr[i] == item) &#123; return true; &#125; &#125; return false; &#125;&lt;/script&gt; (2) 二分法查找从中间开始，往左右两边查找 1234567891011121314151617181920212223242526272829&lt;script&gt; var arr = [1, 2, 4]; function findMid(item, start, end) &#123; if (start &gt; end) &#123; // 起始位置不能大于结束位置 return false; &#125; else if (start == end) &#123; if (arr[start] == item) &#123; return true; &#125; else &#123; return false; // 没有找到最终走这步 &#125; &#125; var mid = Math.floor((start + end) / 2); // 二分法先确定中间位置 if (arr[mid] == item) &#123; return true; &#125; else &#123; if (item &lt; arr[mid]) &#123; return findMid(item, start, mid); &#125; else &#123; return findMid(item, mid + 1, end); &#125; &#125; &#125; console.log(findMid(10, 0, arr.length - 1)); // **注意此处传入的结束位置是arr.length-1&lt;/script&gt; 二分法应用掌握二分法的核心思想：从中间开始，往左右两边查找 无序数组查找最小值 1234567891011121314151617181920212223&lt;script&gt; var arr = [1, 2, -4, -11, 13]; function findMin(arr, s, e) &#123; if (s &gt; e) &#123; return false; &#125; else if (s == e) &#123; return arr[s]; &#125; var c = Math.floor((s + e) / 2); var l = findMin(arr, s, c); // 先找左侧最小值 var r = findMin(arr, c + 1, e); // 再找右侧最小值 if (l &lt; r) &#123; // 两侧最小值比较 return l; &#125; else &#123; return r; &#125; &#125; console.log(findMin(arr, 0, arr.length - 1));&lt;/script&gt; 二分法数组去重 1234567891011121314151617181920212223242526272829303132333435&lt;script&gt; var arr = [1, 2, 3, 2, 4, 3, 1, 5, 7, 2, 5]; // 数组内查找元素是否存在 function findInArr(item, arr) &#123; for (var i = 0; i &lt; arr.length; i++) &#123; if (item == arr[i]) &#123; return true; &#125; &#125; return false; &#125; function del(arr, s, e) &#123; if (s &gt; e) &#123; return []; &#125; else if (s == e) &#123; return [arr[s]]; &#125; var c = Math.floor((s + e) / 2); var l = del(arr, s, c); var r = del(arr, c + 1, e); for (var i = 0; i &lt; r.length; i++) &#123; if (!findInArr(r[i], l)) &#123; l.push(r[i]); &#125; &#125; return l; &#125; console.log(del(arr, 0, arr.length - 1));&lt;/script&gt; 二分法数组排序(归并排序) 1234567891011121314151617181920212223242526&lt;script&gt; var arr = [3, 1, 4, 6, 5, 7, 2, 11]; function _sort(arr, s, e) &#123; if (s &gt; e) &#123; return []; &#125; else if (s == e) &#123; return [arr[s]]; &#125; var c = Math.floor((s + e) / 2); var l = _sort(arr, s, c); var r = _sort(arr, c + 1, e); var arr2 = []; while (l.length &gt; 0 || r.length &gt; 0) &#123; if (l[0] &lt; r[0]) &#123; arr2.push(l.shift()); &#125; else &#123; arr2.push(r.shift()); &#125; &#125; return arr2; &#125;&lt;/script&gt; 2. 排序算法 (1) 交换排序冒泡排序每一轮循环内比较相邻的两个数，如果后一个比前一个小，互换位置。 时间复杂度：O(n^2) 123456789101112131415161718192021222324252627282930313233343536&lt;script&gt; var arr = [3, 1, 4, 6, 5, 7, 2]; function bubbleSort(arr) &#123; var len = arr.length; for (var i = len; i &gt;= 2; --i) &#123; for (var j = 0; j &lt; i - 1; j++) &#123; if (arr[j + 1] &lt; arr[j]) &#123; var temp; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; return arr; &#125; function bubbleSort2(arr) &#123; var len = arr.length; for (var i = 0; i &lt;= len - 1; i++) &#123; for (var j = 0; j &lt;= len - i; j++) &#123; if (arr[j + 1] &lt; arr[j]) &#123; var temp; temp = arr[j]; arr[j] = arr[j + 1]; arr[j + 1] = temp; &#125; &#125; &#125; return arr; &#125; console.log(bubbleSort(arr)); console.log(bubbleSort2(arr));&lt;/script&gt; 快速排序采用二分法，取出中间数，数组每次和中间数比较，小的放到左边，大的放到右边。左边和右边再同理比较。 时间复杂度：O(nlog2(n)) 1234567891011121314151617181920212223242526&lt;script&gt; var arr = [3, 1, 4, 6, 5, 7, 2]; function quickSort(arr) &#123; if(arr.length == 0) &#123; return []; // 返回空数组 &#125; var cIndex = Math.floor(arr.length / 2); var c = arr.splice(cIndex, 1); var l = []; var r = []; for (var i = 0; i &lt; arr.length; i++) &#123; if(arr[i] &lt; c) &#123; l.push(arr[i]); &#125; else &#123; r.push(arr[i]); &#125; &#125; return quickSort(l).concat(c, quickSort(r)); &#125; console.log(quickSort(arr));&lt;/script&gt; (2) 选择排序直接选择每次从当前位置，往后查找最小值，与当前位置交换。 时间复杂度：O(n^2) 12345678910111213141516171819202122232425262728293031&lt;script&gt; var arr = [3, 1, 4, 6, 5, 7, 2]; function selectSort(arr) &#123; for (var i = 0; i &lt; arr.length; i++) &#123; var iMinIndex = findMinIndex(arr, i); var temp; temp = arr[iMinIndex]; arr[iMinIndex] = arr[i]; arr[i] = temp; &#125; return arr; &#125; function findMinIndex(arr, start) &#123; var iMin = arr[start]; var iMinIndex = start; for (var i = start + 1; i &lt; arr.length; i++) &#123; if(arr[i] &lt; iMin) &#123; iMin = arr[i]; iMinIndex = i; &#125; &#125; return iMinIndex; &#125; console.log(selectSort(arr));&lt;/script&gt; 堆排序堆排序用到二叉树的概念。 时间复杂度：O(nlog2(n)) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859&lt;script&gt; var arr = [3, 1, 4, 6, 5, 7, 2]; function headAdjust(elements, pos, len) &#123; //将当前节点值进行保存 var swap = elements[pos]; //定位到当前节点的左边的子节点 var child = pos * 2 + 1; //递归，直至没有子节点为止 while (child &lt; len) &#123; //如果当前节点有右边的子节点，并且右子节点较大的场合，采用右子节点和当前节点进行比较 if (child + 1 &lt; len &amp;&amp; elements[child] &lt; elements[child + 1]) &#123; child ++; &#125; //比较当前节点和最大的子节点，小于则进行值交换，交换后将当前节点定位于子节点上 if (elements[pos] &lt; elements[child]) &#123; elements[pos] = elements[child]; pos = child; child = pos * 2 + 1; &#125; else &#123; break; &#125; elements[pos] = swap; &#125; &#125; //构建堆 function buildHeap(elements) &#123; //从最后一个拥有子节点的节点开始，将该节点连同其子节点进行比较， //将最大的数交换与该节点,交换后，再依次向前节点进行相同交换处理， //直至构建出大顶堆（升序为大顶，降序为小顶） for (var i = elements.length / 2; i &gt;= 0; i--) &#123; headAdjust(elements, i, elements.length); &#125; &#125; function sort(elements) &#123; //构建堆 buildHeap(elements); //从数列的尾部开始进行调整 for (var i = elements.length - 1; i &gt; 0; i--) &#123; //堆顶永远是最大元素，故，将堆顶和尾部元素交换，将 //最大元素保存于尾部，并且不参与后面的调整 var swap = elements[i]; elements[i] = elements[0]; elements[0] = swap; //进行调整，将最大）元素调整至堆顶 headAdjust(elements, 0, i); &#125; &#125; console.log(sort(arr));&lt;/script&gt; (3) 归并排序采用二分法，左边一个排序好的数组，右边一个排序好的数组，每次比较左右数组的第一个数，小的放到一个新的数组中。 时间复杂度：O(nlog2(n)) 12345678910111213141516171819202122232425262728&lt;script&gt; var arr = [3, 1, 4, 6, 5, 7, 2]; function mergeSort(arr, s, e) &#123; if(s &gt; e) &#123; return []; &#125; else if(s == e) &#123; return [arr[s]]; &#125; var c = Math.floor((s + e) / 2); var l = mergeSort(arr, s, c); var r = mergeSort(arr, c + 1, e); var arr2 = []; while(l.length &gt; 0 || r.length &gt; 0) &#123; if(l[0] &lt; r[0]) &#123; arr2.push(l.shift()); &#125; else &#123; arr2.push(r.shift()); &#125; &#125; return arr2; &#125; console.log(mergeSort(arr, 0, arr.length - 1));&lt;/script&gt; 3. 数据结构 时间复杂度 空间复杂度 (1) 有序数组(2) 无序数组不重复 1234567891011121314151617181920212223242526&lt;script&gt; var unorder_arr = []; function unorder_find(n) &#123; for (var i = 0; i &lt; unorder_arr.length; i++) &#123; if(unorder_arr[i] == n) &#123; return true; &#125; &#125; return false; &#125; function unorder_add(n) &#123; if(!unorder_find(n)) &#123; unorder_arr.push(n); &#125; &#125; unorder_add(33); unorder_add(16); unorder_add(41); unorder_add(22); console.log(unorder_arr);&lt;/script&gt; (3) 二叉树增加、查找 以第一个树为根节点，新进来的数比谁小跟谁近就放在谁下面 123456根 节点: &#123; value: n, l: null, r: null &#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;script&gt; var root = null; function add(node, n) &#123; if (root == null) &#123; root = &#123; value: n, l: null, r: null &#125;; &#125; else &#123; if (n == node.value) &#123; console.log('不能重复'); return; &#125; else &#123; if (n &lt; node.value) &#123; console.log('查看左子树'); if (node.l == null) &#123; node.l = &#123; value: n, l: null, r: null &#125; &#125; else &#123; console.log('左子树不为空'); return add(node.l, n); &#125; &#125; else &#123; console.log('查看右子树'); if (node.r == null) &#123; node.r = &#123; value: n, l: null, r: null &#125; &#125; else &#123; console.log('右子树不为空'); return add(node.r, n); &#125; &#125; &#125; &#125; &#125; add(root, 42); add(root, 33); add(root, 66); add(root, 88); add(root, 1); add(root, 50); console.log(root);&lt;/script&gt; (4) 队列特点：先进先出，后进后出 (5) 堆栈特点：后进先出，先进后出 (6) 散列存的时候先开辟一块空间出来 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;script&gt; var hash_arr = []; hash_arr.length = 5; var count = 0; function hash_add(n) &#123; var pos = n % hash_arr.length; if (hash_arr[pos]) &#123; while (hash_arr[pos]) &#123; if (hash_arr[pos] == n) return; pos++; if (pos == hash_arr.length - 1) &#123; pos = 0; &#125; &#125; hash_arr[pos] = n; &#125; else &#123; hash_arr[pos] = n; &#125; count++; if (count == hash_arr.length) &#123; var oldArr = hash_arr; hash_arr = []; count = 0; hash_arr.length = oldArr.length * 2; for (var i = 0; i &lt; oldArr.length; i++) &#123; hash_add(oldArr[i]); &#125; &#125; &#125; hash_add(35); alert(hash_arr); hash_add(42); alert(hash_arr); hash_add(9); alert(hash_arr); hash_add(22); alert(hash_arr); hash_add(11); alert(hash_arr); hash_add(46); alert(hash_arr); hash_add(32); alert(hash_arr); hash_add(7); alert(hash_arr); hash_add(2); alert(hash_arr); hash_add(12); alert(hash_arr); hash_add(31); alert(hash_arr);&lt;/script&gt; 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"js","slug":"js","permalink":"https://wangchloe.vip/tags/js/"}]},{"title":"每天10个前端知识点：面向对象(下)","date":"2017-02-27T19:27:35.000Z","path":"2017/02/28/blog25/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 7. 如何编写面向对象程序 采用构造+原型，写一个构造函数 把方法挂在原型上(不能有方法嵌套) 把全局变量变成属性 调整this 123456789101112131415161718192021222324252627&lt;script&gt; // 1. 写一个构造函数 function ToRed() &#123; // 3. 全局变量变成属性 this.oDiv = document.body.children[0]; // document.onclick = this.fnClick; // 上句相当于 // document.onclick = function() &#123; // alert(this); // document // this.oDiv.style.background = &apos;#f00&apos;; // 当前的this指向document，错误 // &#125; // 4. 调整this var _this = this; document.onclick = function() &#123; _this.fnClick(); &#125; &#125; // 2. 方法挂在原型上 ToRed.prototype.fnClick = function() &#123; this.oDiv.style.background = &apos;#f00&apos;; &#125; new ToRed();&lt;/script&gt; 8. 面向对象：继承 属性的继承 父级的构造函数.call(this, 参数1, 参数2, ...); 父级的构造函数.apply(this, arguments); 方法的继承 子级.prototype = 父级.prototype; // 引用 子级新方法在此之前写会被清空问题：子级改了，父级也改了 循环复制 12345&lt;script&gt; for(var name in 父级.prototype) &#123; 子级.prototype[name] = 父级.prototype[name]; // 循环复制父级的方法 &#125;&lt;/script&gt; 问题：子级 instanceof 父级; // false 组合继承：子级的原型对象指向父级的实例，子级的原型对象的构造函数再指向自己。 推荐使用 1234&lt;script&gt; 子级.prototype = new 父级的构造函数(); 子级.prototype.constructor = 子级的构造函数;&lt;/script&gt; 实例：自动播放选项卡(继承)12345678910111213141516171819&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; #box button.active, #box2 button.active &#123; background: #ff0; &#125; #box div, #box2 div &#123; display: none; width: 100px; height: 100px; font-size: 20px; border: 1px solid #ccc; &#125; #box div.active, #box2 div.active &#123; display: block; &#125;&lt;/style&gt; 12345678910111213141516171819&lt;!-- 不自动播放 --&gt;&lt;div id=&quot;box&quot;&gt; &lt;button class=&quot;active&quot;&gt;btn1&lt;/button&gt; &lt;button&gt;btn2&lt;/button&gt; &lt;button&gt;btn3&lt;/button&gt; &lt;div class=&quot;active&quot;&gt;div1&lt;/div&gt; &lt;div&gt;div2&lt;/div&gt; &lt;div&gt;div3&lt;/div&gt;&lt;/div&gt;&lt;!-- 自动播放 --&gt;&lt;div id=&quot;box2&quot;&gt; &lt;button class=&quot;active&quot;&gt;btn1&lt;/button&gt; &lt;button&gt;btn2&lt;/button&gt; &lt;button&gt;btn3&lt;/button&gt; &lt;div class=&quot;active&quot;&gt;div1&lt;/div&gt; &lt;div&gt;div2&lt;/div&gt; &lt;div&gt;div3&lt;/div&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;script&gt; // 构造函数写属性 function Tab(id) &#123; if(!id) &#123; return; &#125; this.oBox = document.getElementById(id); this.aBtn = this.oBox.getElementsByTagName(&apos;button&apos;); this.aDiv = this.oBox.getElementsByTagName(&apos;div&apos;); &#125; // 原型写方法 Tab.prototype.fnClick = function() &#123; var _this = this; for (var i = 0; i &lt; this.aBtn.length; i++) &#123; (function(index) &#123; _this.aBtn[i].onclick = function() &#123; _this._click(this, index); &#125; &#125;)(i); &#125; &#125; Tab.prototype._click = function(oBtn, index) &#123; for (var i = 0; i &lt; this.aBtn.length; i++) &#123; this.aBtn[i].className = &apos;&apos;; this.aDiv[i].className = &apos;&apos;; &#125; oBtn.className = &apos;active&apos;; this.aDiv[index].className = &apos;active&apos;; &#125; // 自动播放属性 function AutoTab(id) &#123; var _this = this; Tab.call(this, id); // 继承Tab属性 this.iNow = 0; // 当前选项卡索引值 this.timer = null; clearInterval(this.timer); this.timer = setInterval(function() &#123; _this.next(); &#125;, 1000); &#125; AutoTab.prototype = new Tab(); // 继承Tab方法 AutoTab.prototype.constructor = AutoTab; // 自动播放方法 AutoTab.prototype.next = function() &#123; this._click(this.aBtn[this.iNow], this.iNow); this.iNow++; if(this.iNow == this.aBtn.length) &#123; this.iNow = 0; &#125; this.fnClick(); &#125; var old_click = AutoTab.prototype._click; AutoTab.prototype._click = function(oBtn, index) &#123; this.iNow = index; old_click.apply(this, arguments); // 调整this &#125; var oTab = new Tab(&apos;box&apos;); // 不自动播放 var oAuto = new AutoTab(&apos;box2&apos;); oAuto.next(); // 自动播放 console.log(oTab.constructor == Tab); // true console.log(oTab instanceof AutoTab); // false console.log(oAuto.constructor == AutoTab); // true console.log(oAuto instanceof AutoTab); // true console.log(oAuto instanceof Tab); // true&lt;/script&gt; 9. 解决变量名冲突的多种方法 闭包、自执行函数 12345678&lt;script&gt; (function()&#123;&#125;)(); (function()&#123;&#125;()); // 首部加符号防止报错，不限于~ ~function()&#123;&#125;();&lt;/script&gt; 面向对象 命名空间 模块化 let(ES6) 10. 伪数组问题 DOM获取的元素是伪数组 arguments是伪数组 注意json属性名不用纯数字 11. js的冒泡(Bubbling Event)和捕获(Capture Event)的区别 这个问题在之前的原生篇没有写好，这边补充进来。面试题那篇中也有这题。 js之事件冒泡和事件捕获详细介绍 冒泡型事件：事件按照从最特定的事件目标到最不特定的事件目标(document对象)的顺序触发。 捕获型事件(event capturing)：事件从最不精确的对象(document 对象)开始触发，然后到最精确(也可以在窗口级别捕获事件，不过必须由开发人员特别指定)。 DOM事件流：同时支持两种事件模型：捕获型事件和冒泡型事件，但是，捕获型事件先发生。两种事件流会触及DOM中的所有对象，从document对象开始，也在document对象结束。DOM事件模型最独特的性质是，文本节点也触发事件(在IE中不会)。 示例假设一个元素div，它有一个下级元素p。123&lt;div&gt; &lt;p&gt;元素&lt;/p&gt;&lt;/div&gt; 这两个元素都绑定了click事件，如果用户点击了p： 事件捕获当你使用事件捕获时，父级元素先触发，子级元素后触发，即div先触发，p后触发。 事件冒泡当你使用事件冒泡时，子级元素先触发，父级元素后触发，即p先触发，div后触发。 addEventListener函数，它有三个参数，第三个参数若是true，则表示采用事件捕获，若是false，则表示采用事件冒泡。IE只支持事件冒泡，不支持事件捕获。 阻止冒泡• 在W3c中，使用stopPropagation()方法• 在IE下设置oEvent.cancelBubble = true； 在捕获的过程中stopPropagation()后，后面的冒泡过程也不会发生了。 阻止捕获阻止事件的默认行为，例如click &lt;a&gt;后的跳转 • 在W3c中，使用oEvent.preventDefault()方法；• 在IE下设置window.event.returnValue = false;或return false 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"js","slug":"js","permalink":"https://wangchloe.vip/tags/js/"}]},{"title":"每天10个前端知识点：面向对象(中)","date":"2017-02-26T19:27:35.000Z","path":"2017/02/27/blog24/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 4. 创建对象这里先提一下23种设计模式： 创建型模式(5种) 工厂方法模式 抽象工厂模式 单例模式 建造者模式 原型模式 结构型模式(7种) 适配器模式 装饰器模式 代理模式 外观模式 桥接模式 组合模式 享元模式 行为型模式(11种) 策略模式 模板方法模式 观察者模式 迭代子模式 责任链模式 命令模式 备忘录模式 状态模式 访问者模式 中介者模式 解释器模式 (1) 工厂模式123456789101112131415161718192021222324&lt;script&gt; function createObject(name, age) &#123; // 1.原料 var obj = new Object(); // 创建自定义对象 // 2.加工 // 属性 obj.name = name; obj.age = age; // 方法 obj.getName = function() &#123; return this.name; &#125; obj.getAge = function() &#123; return this.age; &#125; // 3.出厂 return obj; &#125; var p = createObject(&apos;x&apos;, 11); console.log(p.getName());&lt;/script&gt; (2) 单例模式需要重新指定父级 这个例子有点问题，等我找到合适的补上，或者评论区留言给我。 1234567891011&lt;script&gt; var person = &#123;&#125;; // 加属性 person.name = &apos;xxx&apos;; // 加方法 person.getName = function() &#123; return this.name; &#125;;&lt;/script&gt; javascript 单例模式 - 长江之水向西流 - 博客频道 - CSDN.NET 12345678910111213141516171819202122232425&lt;script&gt; function Person() &#123; //缓存实例 var instance = this; //重写构造函数 Person = function() &#123; return instance; &#125; //保留原型属性 Person.prototype = this; //实例 instance = new Person(); //重置构造函数引用 instance.constructor = Person; //其他初始化 instance.createTime = new Date(); return instance; &#125;&lt;/script&gt; (3) 构造函数模式构造函数函数名首字母大写 -&gt; 区分普通函数 以这种方式定义的构造函数是定义在Global对象(浏览器中为window对象)中的。 123456789101112131415161718192021222324252627282930313233343536&lt;script&gt; function CreateObject(name, age) &#123; // 1.原料 // var obj = new Object(); // 创建自定义对象 // 2.加工 // 属性 // obj.name = name; // obj.age = age; this.name = name; this.age = age; // 方法 // obj.getName = function() &#123; // return this.name; // &#125; // obj.getAge = function() &#123; // return this.age; // &#125; this.getName = function() &#123; return this.name; &#125; this.getAge = function() &#123; return this.age; &#125; // 3.出厂 // return obj; &#125; var p = new CreateObject(&apos;x&apos;, 11); // 创建对象，并赋值给this console.log(p.getName()); console.log(p.constructor == CreateObject); // true console.log(p instanceof Object); // true console.log(p instanceof CreateObject); // true&lt;/script&gt; (4) 原型模式123456789101112131415161718192021222324252627&lt;script&gt; function CreateObject() &#123; &#125; CreateObject.prototype.name = &apos;xxx&apos;; CreateObject.prototype.age = &apos;11&apos;; CreateObject.prototype.getName = function() &#123; return this.name; &#125; var p = new CreateObject(); console.log(p.getName()); // 查找过程 // 先在 p上查找有没有getName属性 // 没有，再在p的原型上查找getName属性 console.log(CreateObject.prototype.isPrototypeOf(p)); // true console.log(p.hasOwnProperty(&apos;name&apos;)); // false 原型属性 p.name = &apos;yyy&apos;; console.log(p.hasOwnProperty(&apos;name&apos;)); // true 实例属性 delete p.name; // 删除p.name console.log(p.hasOwnProperty(&apos;name&apos;)); // false 原型属性 console.log(&apos;name&apos; in p); // true&lt;/script&gt; 重写prototype将导致实例的constructor转向1234567891011121314151617181920212223242526272829&lt;script&gt; function CreateObject() &#123; &#125; // CreateObject.prototype.name = &apos;xxx&apos;; // CreateObject.prototype.age = &apos;11&apos;; // CreateObject.prototype.getName = function() &#123; // return this.name; // &#125; CreateObject.prototype = &#123; // constructor: CreateObject, // 可特意声明constructor指向 CreateObject name: &apos;xxx&apos;, age: &apos;11&apos;, getName: function() &#123; return this.name; &#125; &#125; var p = new CreateObject(); console.log(p.getName()); console.log(p instanceof CreateObject); // true console.log(p instanceof Object); // true console.log(p.constructor == CreateObject); // false // 重写默认的prototype后，constructor不在指向CreateObject，而是指向Object console.log(p.constructor == Object); // true&lt;/script&gt; (5) 构造+原型原型模式的问题 12345678910111213141516171819202122232425&lt;script&gt; function CreateObject() &#123; &#125; CreateObject.prototype = &#123; constructor: CreateObject, // 可特意声明constructor指向 CreateObject name: &apos;xxx&apos;, age: &apos;11&apos;, children: [&apos;aaa&apos;, &apos;bbb&apos;], getName: function() &#123; return this.name; &#125; &#125; var p = new CreateObject(); var p2 = new CreateObject(); p.children.push(&apos;ccc&apos;); console.log(p.children); // &apos;aaa,bbb,ccc&apos; console.log(p2.children); // &apos;aaa,bbb,ccc&apos; console.log(p.children == p2.children); // true // 尴尬了，p新增加的孩子同时增加到了p2上&lt;/script&gt; 改为 构造+原型 构造定义实例属性 原型定义方法及共享属性 12345678910111213141516171819202122232425&lt;script&gt; function CreateObject(name, age) &#123; this.name = name; // 实例属性 this.age = age; // 实例属性 this.children = [&apos;aaa&apos;, &apos;bbb&apos;]; // 实例属性 &#125; CreateObject.prototype = &#123; constructor: CreateObject, // 共享属性 getName: function() &#123; // 共享方法 return this.name; &#125; &#125; var p = new CreateObject(); var p2 = new CreateObject(); p.children.push(&apos;ccc&apos;); console.log(p.children); // &apos;aaa,bbb,ccc&apos; console.log(p2.children); // &apos;aaa,bbb&apos; console.log(p.children == p2.children); // false console.log(p.getName == p2.getName); // true&lt;/script&gt; 5. 原型与原型链关于原型 对象有属性_proto__(隐式原型)，指向该对象的构造函数的原型对象。（不要忘记万物皆对象） 方法(也是对象)除了有属性__proto__，还有属性prototype，prototype指向该方法的原型对象。 原型对象还有属性constructor，指向原构造函数。 关于原型链 只要创建一个新函数(CreateObject)，都会附带一个prototype属性，并指向函数的原型对象(CreateObject.prototype)。CreateObject.prototype -&gt; CreateObject.prototype 所有原型对象(CreateObject.prototype)都附带一个constructor(构造函数)属性，并指向prototype属性所在函数的指针(CreateObject)。CreateObject.prototype.constructor -&gt; CreateObject 调用构造函数创建的实例(p)，内部将包含指针proto，并指向构造函数的原型对象(CreateObject.prototype)。p._proto_ -&gt; CreateObject.prototypeCreateObject._proto_ -&gt; Function.prototypeFunction.prototype._proto_ -&gt; Object.prototypeCreateObject.prototype._proto_ -&gt; Object.prototypeObject.prototype._proto_ -&gt; null 6. 原型应用(1) 数组arr.indexOf()兼容问题*兼容：高级浏览器IE8- -&gt; 报错 兼容写法123456789101112131415&lt;script&gt; var arr = [1, 2, 3, 4]; Array.prototype.indexOf = Array.prototype.indexOf || function(item) &#123; // 如果有indexOf()就用系统自带的 // IE8- for (var i = 0; i &lt; this.length; i++) &#123; if(this[i] == item) &#123; return i; &#125; &#125; &#125; console.log(arr.indexOf(3));&lt;/script&gt; (2) 字符串str.trim()兼容问题*兼容：高级浏览器IE8- -&gt; 报错 兼容写法12345678910&lt;script&gt; var str = &apos; aaa &apos;; String.prototype.indexOf = String.prototype.indexOf || function() &#123; // 如果有trim()就用系统自带的 // IE8- return this.replace(/^\\s+|\\s+$/g, &apos;&apos;); &#125; console.log(&apos;去空格&apos; + str.trim() + &apos;去空格&apos;);&lt;/script&gt; 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"js","slug":"js","permalink":"https://wangchloe.vip/tags/js/"}]},{"title":"每天10个前端知识点：面向对象(上)","date":"2017-02-25T19:27:35.000Z","path":"2017/02/26/blog23/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 1. 面向对象(1) 对象组成 属性(变量) 方法(函数) (2) 面向对象特征 封装 继承 子级可以继承父级的一切东西 多态 子级可以继承多个父级 (3) 对象相关方法 instanceof 判断是否属于该类型 true 属于 false 不属于eg: arr instanceof Array; // true constructor 查找对象的父级eg: arr.constructor == Array; // true JSON不是一个类型，其父类型就是Objectjson.constructor == JSON; // falsejson.constructor == Object; // true 执念12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;script&gt; var arr = [1, 2]; var json = &#123;&#125;; var oDate = new Date(); console.log(arr.constructor == Array); // true console.log(json.constructor == JSON); // false console.log(json.constructor == Object); // true console.log(typeof oDate); // object console.log(oDate instanceof Date); // true console.log(typeof Date); // function console.log(Date instanceof Function); // true console.log(oDate instanceof Function); // false console.log(typeof Image); // function console.log(Image instanceof Function); // true // 开始划重点 console.log(Function instanceof Object); // true console.log(Object instanceof Function); // true console.log(Object instanceof Object); // true console.log(Function instanceof Function); // true console.log(arr instanceof Array); // true console.log(Array instanceof Object); // true console.log(arr instanceof Object); // *true console.log(arr instanceof Array); // true console.log(Array instanceof Function); // true console.log(arr instanceof Function); // *false Object.prototype.run = 7; var run = 5; var arr2 = []; console.log(run); // 5 console.log(typeof run); // number console.log(run instanceof Number); // false console.log(Number instanceof Object); // true console.log(Boolean instanceof Object); // true console.log(run instanceof Object); // false console.log(arr2.run); // 7&lt;/script&gt; 2. 引用类型 Object类型 Array类型 Date类型 RegExp类型 Function类型 基本包装类型 Boolean类型 String类型 内置对象 Global对象 Math对象 Array.sum实现原理1234567891011121314&lt;script&gt; var arr = [1, 2, 3]; // sum的实现原理 Array.prototype.sum = function() &#123; var sum = 0; for(var i = 0; i &lt; this.length; i++) &#123; sum += this[i]; &#125; return sum; &#125; console.log(arr.sum());&lt;/script&gt; Array.forEach实现原理1234567891011121314&lt;script&gt; // forEach实现原理 if (!Array.prototype.forEach) &#123; Array.prototype.forEach = function(fn) &#123; for (var i = 0; i &lt; this.length; i++) &#123; fn(this[i], i, this); &#125; &#125;; &#125; [&quot;a&quot;, &quot;b&quot;, &quot;c&quot;].forEach(function(value, index, array) &#123; assert(value, &quot;Is in position &quot; + index + &quot; out of &quot; + (array.length - 1)); &#125;);&lt;/script&gt; Array.every实现原理1234567891011121314151617&lt;script&gt; if (Array.prototype.every === undefined) &#123; Array.prototype.every = function(fun) &#123; //遍历当前数组中每个元素 for (var i = 0; i &lt; this.length; i++) &#123; if (this[i] !== undefined) &#123; //调用fun,依次传入当前元素值,位置i,当前数组作为参数 ，将返回值，保存在变量r中 var r = fun(this[i], i, this); if (r == false) &#123; //如果r为false return false; //返回false &#125; &#125; &#125; //(遍历结束) return true; //返回true &#125; &#125;&lt;/script&gt; Array.some原理123456789101112131415&lt;script&gt; if (Array.prototype.some === undefined) &#123; Array.prototype.some = function(fun) &#123; for (var i = 0; i &lt; this.length; i++) &#123; if (this[i] !== unefined) &#123; var r = fun(this[i], i, this); if (r == true) &#123; return true; &#125; &#125; &#125; return false; &#125; &#125;&lt;/script&gt; Array.map原理12345678910111213141516171819&lt;script&gt; if (Array.prototype.map === undefined) &#123; Array.prototype.map = function(fun) &#123; //创建空数组: newArr var newArr = []; //遍历当前数组中每个元素 for (var i = 0; i &lt; this.length; i++) &#123; //如果当前元素不是undefined if (this[i] !== undefined) &#123; //判断稀疏数组 //调用fun传入当前元素值，位置i，当前数组，将结果保存在r中 //将newArr的i位置赋值为r var r = fun(this[i], i, this); newArr[i] = r; &#125; &#125; //(遍历结束) return newArr; //返回newArr &#125; &#125;&lt;/script&gt; Array.reduce原理12345678910111213&lt;script&gt; if (Array.prototype.reduce === undefined) &#123; Array.prototype.reduce = function(fun, base) &#123; base === undefined &amp;&amp; (base = 0); for (var i = 0; i &lt; this.length; i++) &#123; if (this[i] !== undefined) &#123; base = fun(base, this[i], i, this); &#125; &#125; return base; &#125; &#125;&lt;/script&gt; Function.bind原理123456789101112131415161718192021222324&lt;script&gt; if (Function.prototype.bind === undefined) &#123; Function.prototype.bind = function(obj /*，参数列表*/ ) &#123; var fun = this; //留住this //*****将类数组对象，转化为普通数组 var args = Array.prototype.slice.call(arguments, 1); //args保存的就是提前绑定的参数列表 /*function slice(1)&#123; var sub=[]; for(var i=0;i&lt;length;i++)&#123; sub.push(arguments[i]); &#125; return sub; &#125;*/ return function() &#123; //将后传入的参数值，转为普通数组 var innerArgs = Array.prototype.slice.call(arguments); //将之前绑定的参数值和新传入的参数值，拼接为完整参数之列表 var allArgs = args.concat(innerArgs) //调用原始函数fun，替换this为obj，传入所有参数 fun.apply(obj, allArgs); &#125; &#125; &#125;&lt;/script&gt; 3. 创建对象前导(1) 关于new 创建一个空对象，并赋值给this 返回this (2) 关于this当前方法属于谁，this就是谁 1234&lt;script&gt; // In web browsers, the window object is also the global object: console.log(this === window); // true&lt;/script&gt; this的优先级： new -&gt; object 定时器 -&gt; window 事件 -&gt; 事件对象 方法 -&gt; 方法对象 多包一层时优先级失效 哈哈，关于this的坑详见后面的坑集合！ 1234567891011121314151617181920212223242526272829&lt;script&gt; function show() &#123; console.log(this); &#125; var arr = [1, 2]; arr.show = show; document.onclick = arr.show; // 点击时 document new arr.show(); // 1. object new show(); // 2. object new document.onclick(); // 3. object setTimeout(show, 1000); // 9. window setTimeout(arr.show, 1000); // 10. window setTimeout(new arr.show, 1000); // 4. object **在上两个行执行前先弹出 var oDate = new Date(); oDate.show = show; document.show = show; document.onclick = show; setTimeout(function() &#123; // setTimeout多包一层优先级失效 oDate.show(); // 5. oDate时间 new oDate.show(); // 6. object document.show(); // 7. document document.onclick(); // 8. document &#125;, 100);&lt;/script&gt; 强制改变this指向 call fn.call(a); 改变this指向，指向a fn.call(a, p1, p2); 改变this指向并传参p1, p2 apply fn.apply(a, [p1, p2]); 改变this指向并传入参数数组 fn.apply(a, arguments); 改变this指向并传入当前方法(非fn)的参数数组 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"js","slug":"js","permalink":"https://wangchloe.vip/tags/js/"}]},{"title":"小厨教你做叉烧","date":"2017-02-25T19:12:48.000Z","path":"2017/02/26/life4/","text":"就说做饭好吃这点是不是该写简历上，是不是该加分！ 无媛无故-小厨教你做叉烧 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"爱做饭","slug":"爱做饭","permalink":"https://wangchloe.vip/tags/爱做饭/"}]},{"title":"每天10个前端知识点：性能优化篇","date":"2017-02-23T19:27:35.000Z","path":"2017/02/24/blog22/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 二话不说！先三炷香膜拜下YaHoo军规。 以下方便你们ctrl+c、ctrl+v 网页内容 减少 http请求次数 减少 DNS查询次数 避免页面跳转 缓存 Ajax 延迟加载 提前加载 减少 DOM元素数量 根据域名划分内容 减少iframe数量 避免 404 服务器 使用CDN(内容分发网络) 添加Expires或Cache-Control报文头 Gzip压缩传输文件 配置ETags 尽早flush(刷新输出)缓冲 使用GET来完成AJAX请求 避免空的图片src Cookie 减少Cookie大小 页面内容使用无cookie域名 CSS 将样式表置顶 避免使用CSS表达式(Expression) 用代替@import 避免使用Filters(滤镜) JavaScript 把脚本置于页面底部 使用外部JavaScript和CSS 精简JavaScript和CSS 去除重复脚本 减少DOM访问 开发智能事件处理程序 图片 优化图像 优化CSS Spirite 不要在HTML中缩放图片 favicon.ico要小而且可缓存 移动客户端 保持单个内容小于25KB 打包组建成复合文档 再来一张私藏的移动端性能优化 以下是正文 1. 性能优化项目讲求： 稳定性 可维护性 性能优化 性能分类： 执行性能 网络性能 2. 重排 &amp;&amp; 重绘简单-页面性能优化 (1) 重排(reflow)即重新生成布局，重排必然导致重绘。 会触发重排的属性： 盒子模型相关属性 width height padding margin display border-width border min-height 定位属性及浮动 top bottom left right position float clear 改变节点内部文字结构 text-align overflow-y font-weight overflow font-family line-height vertival-align white-space font-size (2) 重绘即重新绘制，重绘不一定需要重排。 会触发重绘的属性： color border-style border-radius visibility text-decoration background background-image background-position background-repeat background-size outline-color outline outline-style outline-width box-shadow 3. 图层浏览器layout和paint是在每一个图层上进行的，当有一个元素经常变化，为了减少这个元素对页面的影响，我们可以为这个元素创建一个单独的图层，来提供页面的性能。 什么时候会创建图层 3D或透视变换（perspective transform）CSS属性（例如translateZ(0)/translate3d(0,0,0)） 使用加速视频解码的&lt;video&gt;节点 拥有3D（WebGL）上下文或加速的2D上下文的&lt;canvas&gt;节点 混合插件（如Flash） 对自己的opacity做CSS动画或使用一个动画webkit变换的元素 拥有加速CSS过滤器的元素 元素有一个包含复合层的后代节点（一个元素拥有一个子元素，该子元素在自己的层里） 元素有一个z-index较低且包含一个复合层的兄弟元素（换句话说就是该元素在复合层上面渲染） position为fixed也会创建图层，而absolute则不会 利用GPU来加速页面渲染(硬件加速) 触发CSS硬件加速 translate3d(0,0,0) rotate3d(0,0,0,0) scale3d(0,0,0) translateZ(0)【可能】 4. 执行性能优化建议： 不用的东西删除 尽量不用全局变量(命名冲突，耗资源) 能用系统自带的一定不用自己写的(eg:getByClass) 尽量使用正则操作字符串 DOM操作耗性能，尽量减少DOM操作 属性用的越多，性能越低 css耗性能属性：expression、filter、border-radius、box-shadow、gradients Math.floor比parseInt快 变量性能消耗：属性 &gt; 全局变量 &gt; 局部变量 5. 网络性能优化查看网络性能 F12 -&gt; network Status 状态码 Type 资源类型 主类型/次类型 text/html text/css image/png/gif Initiator 发起人 Size 资源大小 Time 请求耗时 Timeline 时间轴 Queueing 排队 Stalled 停滞 Request sent 请求发送 Waiting 等待 Content Download 内容下载 工具FF -&gt; firebug -&gt; yslow(网站评分)Chrome -&gt; Audits(查看网络性能) 网络性能提升方法 减少http请求 -&gt; 合并 js -&gt; 合并 css -&gt; 合并，避免@import方式引入css文件 图片 -&gt; css sprites http请求越小越好 -&gt; 压缩 js -&gt; 压缩 css -&gt; 压缩 css值缩写(margin,border等) 省略值为0的单位 色值用最短的表示 图片 -&gt; 压缩工具 在线工具 —— 开源中国社区 HTML格式化 、HTML压缩- 站长工具 前端自动化工具 图片延迟加载 CDN(Content Delivery Network, 内容分发网络)加速 加载顺序 阻塞加载(同步加载)js解决：引用其他网站的js放在body最后 非阻塞加载(异步加载，并行加载)css、html、图片 6. 垃圾回收 GC(Gabage Collection) js中的垃圾回收：(宿主环境)浏览器会自动回收垃圾 底层语言不会自动回收垃圾 垃圾的评判标准：生存周期 生存周期：作用域 全局变量：生存周期长，直到浏览器关闭时清除 占资源 局部变量：生存周期短，方法调用完即清除 闭包(子函数可以使用父函数的全局变量)子函数若没有释放，整条作用域链上的局部变量都会保留作用域链：从内一级一级往外找，知道全局 1234567891011121314151617181920&lt;script&gt; // 作用域链 function show1() &#123; var a = 12; function show2() &#123; var b = 1; function show3() &#123; var c = 2; document.onclick = function() &#123; var d = 3; alert(a); &#125; &#125; show3(); &#125; show2(); &#125; show1();&lt;/script&gt; 7. 递归函数自己调用自己核心思想：化大为小，逐一解决 斐波那契数列(Fibonacci sequence) 以递归的方法定义：F0=0，F1=1，Fn=F(n-1)+F(n-2)（n&gt;=2，n∈N*） 经典问题：兔子问题 有一对兔子，从出生后第3个月起每个月都生一对兔子，小兔子长到第三个月后每个月又生一对兔子，假如兔子都不死，问每个月的兔子总对数为多少？ 分析：假设将兔子分为小、中、大三种。兔子从出生后每三个月就生出一对兔子，那么我们假定第一个月为小兔子，第二个月为中兔子，第三个月之后就为老兔子(老兔子每过三个月还会再生的)。 那么第一个月分别有1、0、0，第二个月分别为0、1、0，第三个月分别为1、0、1，第四个月分别为1、1、1，第五个月分别为2、1、2，第六个月分别为3、2、3，第七个月分别为5、3、5…… 兔子总对数分别为：1、1、2、3、5、8、13…… 找出规律即得出以下代码 123456789101112131415&lt;script&gt; function fn(n) &#123; // n为当前月份 var arr = []; if(n &lt;= 2) &#123; // 前两个月只有一对兔子 return 1; &#125; else &#123; if(arr[n]) &#123; return arr[n]; &#125; else &#123; arr[n] = fn(n-1) + fn(n-2); // 第三个月开始返回前两月之和 return arr[n]; // 返回截止当前月份的总对数 &#125; &#125; &#125;&lt;/script&gt; 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"js","slug":"js","permalink":"https://wangchloe.vip/tags/js/"},{"name":"css","slug":"css","permalink":"https://wangchloe.vip/tags/css/"},{"name":"性能优化","slug":"性能优化","permalink":"https://wangchloe.vip/tags/性能优化/"}]},{"title":"每天10个前端知识点：布局大全","date":"2017-02-19T19:27:35.000Z","path":"2017/02/20/blog21/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 本次内容主要整理来源：布局 - 代码库 - NEC : 更好的CSS样式解决方案 以下代码可复制至codePen实践 一. 单列布局1. 水平居中(1) 文本、图片等行内元素12345&lt;style&gt; .parent &#123; text-align: center; &#125;&lt;/style&gt; (2) 定宽块级元素12345&lt;style&gt; .child &#123; margin: 0 auto; &#125;&lt;/style&gt; (3) 不定宽块元素 inline + text-align 12345678&lt;style&gt; .parent &#123; text-align: center; &#125; .child &#123; display: inline; &#125;&lt;/style&gt; table + margin 123456&lt;style&gt; .child &#123; display: table; margin: 0 auto; &#125;&lt;/style&gt; float + relative 1234567891011&lt;style&gt; .parent &#123; float: left; position: relative; left: 50%; &#125; .child &#123; position: relative; left: -50%; &#125;&lt;/style&gt; absolute + transform 12345678910&lt;style&gt; .parent &#123; position: relative; &#125; .child &#123; position: absolute; left: 50%; transform: translateX(-50%); &#125;&lt;/style&gt; (4) 多个块级元素(单个块级元素也可用) inline-block + text-align 12345678910&lt;style&gt; .parent &#123; text-align: center; &#125; .child &#123; display: inline-block; *display: inline; *zoom:1; &#125;&lt;/style&gt; flex + justify-content 12345678&lt;style&gt; .parent &#123; display: flex; &#125; .child &#123; justify-content: center; &#125;&lt;/style&gt; 2. 垂直居中(1) 父元素高度确定的单行文本1234567&lt;style&gt; .parent &#123; height: 20px; line-height: 20px; overflow:hidden; &#125;&lt;/style&gt; (2) 父元素高度确定的多行文本123456789&lt;style&gt; .parent &#123; display: table; &#125; .child &#123; display: table-cell; vertical-align: middle; &#125;&lt;/style&gt; (3) 子元素定高块级元素123456789&lt;style&gt; .child &#123; position: absolute; top: 50%; margin-top: -50px; width: 100px; height: 100px; &#125;&lt;/style&gt; (4) 子元素不定高块级元素 absolute + transform 12345678910&lt;style&gt; .parent &#123; position: relative; &#125; .child &#123; position: absolute; top: 50%; transform: translateY(-50%); &#125;&lt;/style&gt; flex + align-items 123456&lt;style&gt; .parent &#123; display: flex; align-items: center; &#125;&lt;/style&gt; 3. 水平垂直居中(1) 定宽高1234567891011&lt;style&gt; .child &#123; position: absolute; top: 50%; left: 50%; margin-top: -75px; margin-left: -75px; width: 150px; height: 150px; &#125;&lt;/style&gt; (2) 不定宽高 inline-block + table-cell 123456789101112&lt;style&gt; .parent &#123; display: tabel-cell; text-align: center; vertical-align: middle; &#125; .child &#123; display: inline-block; *display: inline; *zoom:1; &#125;&lt;/style&gt; table-cell + absolute 12345678910111213&lt;style&gt; .parent &#123; display: tabel; position: absolute; width: 100%; height: 100%; &#125; .child &#123; display: table-cell; text-align: center; vertical-align: middle; &#125;&lt;/style&gt; absolute + transform 1234567891011&lt;style&gt; .parent &#123; position: relative &#125; .child &#123; position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%); &#125;&lt;/style&gt; flex + justify-content + align-items 1234567&lt;style&gt; .parent &#123; display: flex; justify-content: center; align-items: center; &#125;&lt;/style&gt; jQuery 12345678910111213&lt;script&gt; $(window).resize(function() &#123; $(&apos;.child&apos;).css(&#123; position: &apos;absolute&apos;, left: ($(window).width()-$(&apos;.child&apos;).outerWidth())/2, top: ($(window).height()-$(&apos;.child&apos;).outerHeight())/2 &#125;); &#125;); $(function() &#123; $(window).resize(); &#125;)&lt;/script&gt; 二. 两列布局1. 两个div并排的多种方法 定位 margin负值 浮动 行内块 table 2. 左侧定宽，右侧自适应 float + margin 123456789&lt;style&gt; .left &#123; float: left; width: 100px; &#125; .right &#123; margin-left: 120px; &#125;&lt;/style&gt; 12&lt;div class=\"left\"&gt;左侧定宽&lt;/div&gt; &lt;div class=\"right\"&gt;右侧自适应&lt;/div&gt; float + margin 12345678910&lt;style&gt; .left &#123; float: left; width: 100px; margin-right: 20px; &#125; .right &#123; overflow: hidden; &#125;&lt;/style&gt; 12&lt;div class=\"left\"&gt;左侧定宽&lt;/div&gt; &lt;div class=\"right\"&gt;右侧自适应&lt;/div&gt; absolute + margin 1234567891011121314151617181920&lt;style&gt; .left &#123; width: 300px; height: 500px; background: red; font-size: 30px; color: #fff; position: absolute; left: 0; top: 0; &#125; .right &#123; height: 500px; background: blue; font-size: 30px; color: #fff; /* padding-left: 300px; */ margin-left: 300px; &#125;&lt;/style&gt; 12&lt;div class=\"left\"&gt;左侧定宽&lt;/div&gt; &lt;div class=\"right\"&gt;右侧自适应&lt;/div&gt; relative + float + margin 123456789101112131415&lt;style&gt; .g-sd1 &#123; position: relative; float: left; margin-right: -190px; width: 190px; &#125; .g-mn1 &#123; float: right; width: 100%; &#125; .g-mn1c &#123; margin-left: 200px; &#125;&lt;/style&gt; 12345678&lt;div class=\"g-sd1\"&gt; &lt;p&gt;左侧定宽&lt;/p&gt;&lt;/div&gt;&lt;div class=\"g-mn1\"&gt; &lt;div class=\"g-mn1c\"&gt; &lt;p&gt;右侧自适应&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; absolute + margin 123456789101112&lt;style&gt; .parent &#123; display: flex; &#125; .left &#123; margin-right: 20px; width: 100px; &#125; .right &#123; flex: 1; &#125;&lt;/style&gt; 12345678&lt;div class=\"parent\"&gt; &lt;div class=\"left\"&gt; &lt;p&gt;左侧定宽&lt;/p&gt; &lt;/div&gt; &lt;div class=\"right\"&gt; &lt;p&gt;右侧自适应&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 3. 左侧自适应，右侧定宽(基本同理，不一一列举) margin + absolute 1234567891011121314151617181920&lt;style&gt; .left &#123; /* padding-right: 300px; */ margin-left: 300px; height: 500px; background: blue; font-size: 30px; color: #fff; &#125; .right &#123; position: absolute; right: 0; top: 0; width: 300px; height: 500px; background: red; font-size: 30px; color: #fff; &#125;&lt;/style&gt; 12&lt;div class=\"left\"&gt;左侧自适应&lt;/div&gt; &lt;div class=\"right\"&gt;右侧定宽&lt;/div&gt; relative + float + margin 123456789101112131415&lt;style&gt; .g-sd2 &#123; position: relative; float: right; width: 230px; margin-left: -230px &#125; .g-mn2 &#123; float: left; width: 100%; &#125; .g-mn2c &#123; margin-right: 240px; &#125;&lt;/style&gt; 12345678&lt;div class=\"g-mn2\"&gt; &lt;div class=\"g-mn2c\"&gt; &lt;p&gt;左侧自适应&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"g-sd2\"&gt; &lt;p&gt;右侧定宽&lt;/p&gt;&lt;/div&gt; 三. 等高布局 float + margin-bottom负值 123456789101112131415161718192021&lt;style&gt; .box &#123; width: 800px; overflow: hidden; /* 搭配使用 */ margin: 10px auto; &#125; .l-box &#123; float: left; margin-bottom: -2000px; /* 搭配使用 */ padding-bottom: 2000px; /* 搭配使用 */ width: 300px; background: red; &#125; .r-box &#123; float: left; margin-bottom: -2000px; /* 搭配使用 */ padding-bottom: 2000px; /* 搭配使用 */ width: 500px; background: blue; &#125;&lt;/style&gt; 123456789101112131415161718192021&lt;div class=\"box\"&gt; &lt;div class=\"l-box\"&gt; 左侧左侧左侧左侧&lt;br/&gt; 左侧左侧左侧左侧&lt;br/&gt; 左侧左侧左侧左侧&lt;br/&gt; 左侧左侧左侧左侧&lt;br/&gt; &lt;/div&gt; &lt;div class=\"r-box\"&gt; 右侧右侧右侧右侧&lt;br/&gt; 右侧右侧右侧右侧&lt;br/&gt; 右侧右侧右侧右侧&lt;br/&gt; 右侧右侧右侧右侧&lt;br/&gt; 右侧右侧右侧右侧&lt;br/&gt; 右侧右侧右侧右侧&lt;br/&gt; 右侧右侧右侧右侧&lt;br/&gt; 右侧右侧右侧右侧&lt;br/&gt; 右侧右侧右侧右侧&lt;br/&gt; 右侧右侧右侧右侧&lt;br/&gt; 右侧右侧右侧右侧&lt;br/&gt; &lt;/div&gt; &lt;/div&gt; flex 123456789101112&lt;style&gt; .box &#123; display: flex; &#125; .l-box &#123; margin-right: 20px; width: 100px; &#125; .r-box &#123; flex: 1; &#125;&lt;/style&gt; 123456789101112131415161718192021&lt;div class=\"box\"&gt; &lt;div class=\"l-box\"&gt; 左侧左侧左侧左侧&lt;br/&gt; 左侧左侧左侧左侧&lt;br/&gt; 左侧左侧左侧左侧&lt;br/&gt; 左侧左侧左侧左侧&lt;br/&gt; &lt;/div&gt; &lt;div class=\"r-box\"&gt; 右侧右侧右侧右侧&lt;br/&gt; 右侧右侧右侧右侧&lt;br/&gt; 右侧右侧右侧右侧&lt;br/&gt; 右侧右侧右侧右侧&lt;br/&gt; 右侧右侧右侧右侧&lt;br/&gt; 右侧右侧右侧右侧&lt;br/&gt; 右侧右侧右侧右侧&lt;br/&gt; 右侧右侧右侧右侧&lt;br/&gt; 右侧右侧右侧右侧&lt;br/&gt; 右侧右侧右侧右侧&lt;br/&gt; 右侧右侧右侧右侧&lt;br/&gt; &lt;/div&gt; &lt;/div&gt; 四. 多列布局1. 左右定宽，中间自适应 absolute + margin 123456789101112131415161718192021222324252627282930&lt;style&gt; .left &#123; position: absolute; top: 0; left: 0; width: 200px; height: 500px; background: red; color: #fff; font-size: 20px; &#125; .right &#123; position: absolute; top: 0; right: 0; width: 200px; height: 500px; background: red; color: #fff; font-size: 20px; &#125; .content &#123; /* padding: 0 200px; */ margin: 0 200px; height: 500px; background: blue; font-size: 20px; color: #fff; &#125;&lt;/style&gt; 123&lt;div class=\"left\"&gt;左侧定宽&lt;/div&gt;&lt;div class=\"content\"&gt;中间自适应&lt;/div&gt; &lt;div class=\"right\"&gt;右侧定宽&lt;/div&gt; relative + float + margin 1234567891011121314151617181920&lt;style&gt; .g-sd51, .g-sd52 &#123; position: relative; float: left; width: 230px; margin: 0 -230px 0 0; &#125; .g-sd52 &#123; float: right; width: 190px; margin: 0 0 0 -190px; &#125; .g-mn5 &#123; float: left; width: 100%; &#125; .g-mn5c &#123; margin: 0 200px 0 240px; &#125;&lt;/style&gt; 1234567891011&lt;div class=\"g-sd51\"&gt; &lt;p&gt;左侧定宽&lt;/p&gt;&lt;/div&gt;&lt;div class=\"g-mn5\"&gt; &lt;div class=\"g-mn5c\"&gt; &lt;p&gt;中间自适应&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"g-sd52\"&gt; &lt;p&gt;右侧定宽&lt;/p&gt;&lt;/div&gt; 圣杯布局 中间栏放到文档流前面，保证先行渲染 三栏全部float:left浮动 中间栏在添加相对定位，并配合left和right属性 效果上表现为三栏是单独分开的 可参考该篇圣杯的分析过程：【CSS】 布局之圣杯布局) 1234567891011121314151617181920212223242526272829303132333435363738394041&lt;style&gt; #hd &#123; height: 50px; background: #666; text-align: center; &#125; #bd &#123; /*左右栏通过添加负的margin放到正确的位置了，此段代码是为了摆正中间栏的位置*/ padding: 0 200px 0 180px; height: 100px; &#125; #middle &#123; float: left; width: 100%; height: 100px; background: blue; &#125; #left &#123; float: left; width: 180px; height: 100px; margin-left: -100%; /*左栏上去到第一行*/ background: #0c9; position: relative; left: -180px; /*中间栏的位置摆正之后，左栏的位置也相应右移，通过相对定位的left恢复到正确位置*/ &#125; #right &#123; float: left; width: 200px; height: 100px; margin-left: -200px; background: #0c9; position: relative; right: -200px; /*中间栏的位置摆正之后，右栏的位置也相应左移，通过相对定位的right恢复到正确位置*/ &#125; #footer &#123; height: 50px; background: #666; text-align: center; &#125;&lt;/style&gt; 1234567&lt;div id=&quot;hd&quot;&gt;header&lt;/div&gt;&lt;div id=&quot;bd&quot;&gt; &lt;div id=&quot;middle&quot;&gt;middle&lt;/div&gt; &lt;div id=&quot;left&quot;&gt;left&lt;/div&gt; &lt;div id=&quot;right&quot;&gt;right&lt;/div&gt;&lt;/div&gt;&lt;div id=&quot;footer&quot;&gt;footer&lt;/div&gt; 双飞翼布局 中间栏放到文档流前面，保证先行渲染 三栏全部float:left浮动 在中间栏的div中嵌套一个div，内容写在嵌套的div里，然后对嵌套的div设置margin-left和margin-right 效果上表现为左右两栏在中间栏的上面 区别：双飞翼多了1个div，少用大致4个css属性（圣杯布局中间div padding-left和padding-right这2个属性，加上左右两个div用相对布局position: relative及对应的right和left共4个属性，一共6个；而双飞翼布局子div里用margin-left和margin-right共2个属性，6-2=4）作者：吕延庆链接：https://www.zhihu.com/question/21504052/answer/50053054来源：知乎著作权归作者所有，转载请联系作者获得授权。 123456789101112131415161718192021222324252627282930313233343536373839&lt;style&gt; #hd &#123; height: 50px; background: #666; text-align: center; &#125; #middle &#123; float: left; width: 100%; height: 100px; background: blue; &#125; #left &#123; float: left; width: 180px; height: 100px; margin-left: -100%; /*左栏上去到第一行*/ background: #0c9; &#125; #right &#123; float: left; width: 200px; height: 100px; margin-left: -200px; background: #0c9; &#125; /*给内部div添加margin，把内容放到中间栏，其实整个背景还是100%*/ #inside &#123; margin: 0 200px 0 180px; height: 100px; &#125; #footer &#123; clear: both; /*记得清除浮动*/ height: 50px; background: #666; text-align: center; &#125;&lt;/style&gt; 1234567&lt;div id=\"hd\"&gt;header&lt;/div&gt;&lt;div id=\"middle\"&gt; &lt;div id=\"inside\"&gt;middle&lt;/div&gt;&lt;/div&gt;&lt;div id=\"left\"&gt;left&lt;/div&gt;&lt;div id=\"right\"&gt;right&lt;/div&gt;&lt;div id=\"footer\"&gt;footer&lt;/div&gt; 2. 左侧自适应，中间右侧定宽12345678910111213141516171819&lt;style&gt; .g-sd41, .g-sd42 &#123; position: relative; float: right; width: 190px; &#125; .g-sd41 &#123; width: 230px; margin-left: 10px; &#125; .g-mn4 &#123; float: left; width: 100%; margin-right: -430px; &#125; .g-mn4c &#123; margin-right: 440px; &#125;&lt;/style&gt; 1234567891011&lt;div class=\"g-mn4\"&gt; &lt;div class=\"g-mn4c\"&gt; &lt;p&gt;左侧自适应&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"g-sd41\"&gt; &lt;p&gt;中间定宽&lt;/p&gt;&lt;/div&gt;&lt;div class=\"g-sd42\"&gt; &lt;p&gt;右侧定宽&lt;/p&gt;&lt;/div&gt; 3. 右侧自适应，中间左侧定宽12345678910111213141516171819&lt;style&gt; .g-sd31, .g-sd32 &#123; position: relative; float: left; width: 230px; &#125; .g-sd31 &#123; width: 190px; margin-right: 10px; &#125; .g-mn3 &#123; float: right; width: 100%; margin-left: -430px; &#125; .g-mn3c &#123; margin-left: 440px; &#125;&lt;/style&gt; 1234567891011&lt;div class=\"g-sd31\"&gt; &lt;p&gt;左侧定宽&lt;/p&gt;&lt;/div&gt;&lt;div class=\"g-sd32\"&gt; &lt;p&gt;中间定宽&lt;/p&gt;&lt;/div&gt;&lt;div class=\"g-mn3\"&gt; &lt;div class=\"g-mn3c\"&gt; &lt;p&gt;右侧自适应&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 五. 图片绝对居中1234567891011121314151617&lt;style&gt; .box &#123; width: 500px; height: 600px; margin: 10px auto; border: 1px solid red; text-align: center; &#125; .box img &#123; vertical-align: middle; &#125; .box span &#123; display: inline-block; height: 100%; vertical-align: middle; &#125;&lt;/style&gt; 1234&lt;div class=\"box\"&gt; &lt;img src=\"img/xxx.png\" alt=\"\"/&gt; &lt;span&gt;&lt;/span&gt;&lt;/div&gt; 图片居中溢出隐藏1234567891011121314151617181920212223242526&lt;style&gt; .m-demo &#123; position: relative; width: 300px; height: 300px; overflow: hidden; border: 1px solid #ddd; &#125; .m-demo p &#123; position: absolute; top: 50%; left: 50%; margin: 0; padding: 0; &#125; .m-demo img &#123; position: absolute; top: -50%; left: -50%; display: block; &#125; .m-demo img.hidden &#123; visibility: hidden; position: static; &#125;&lt;/style&gt; 123456789101112131415161718&lt;div class=\"m-demo\"&gt; &lt;p&gt; &lt;img src=\"http://nec.netease.com/img/s/1.jpg\" class=\"hidden\"/&gt; &lt;img src=\"http://nec.netease.com/img/s/1.jpg\" alt=\"\"/&gt; &lt;/p&gt;&lt;/div&gt;&lt;div class=\"m-demo\"&gt; &lt;p&gt; &lt;img src=\"http://nec.netease.com/img/m/1.jpg\" class=\"hidden\"/&gt; &lt;img src=\"http://nec.netease.com/img/m/1.jpg\" alt=\"\"/&gt; &lt;/p&gt;&lt;/div&gt;&lt;div class=\"m-demo\"&gt; &lt;p&gt; &lt;img src=\"http://nec.netease.com/img/l/1.jpg\" class=\"hidden\"/&gt; &lt;img src=\"http://nec.netease.com/img/l/1.jpg\" alt=\"\"/&gt; &lt;/p&gt;&lt;/div&gt; 六. 两列三列自适应1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;style&gt; /* 两列布局 主列左 侧列右 */ .g-mn1 &#123; float: left; width: 100%; margin-right: -200px; &#125; .g-mnc1 &#123; margin-right: 210px; &#125; .g-sd1 &#123; float: right; width: 200px; &#125; /* 两列布局 主列右 侧列左*/ .g-mn2 &#123; float: right; width: 100%; margin-left: -200px; &#125; .g-mnc2 &#123; margin-left: 210px; &#125; .g-sd2 &#123; float: left; width: 200px; &#125; /* 三列布局 主列右 两侧列左*/ .g-mn3 &#123; float: right; width: 100%; margin-left: -520px; &#125; .g-mnc3 &#123; margin-left: 520px; &#125; .g-sd3a &#123; float: left; width: 300px; margin-right: 10px; &#125; .g-sd3b &#123; float: left; width: 200px; &#125; /* 三列布局 主列中 两侧列分居左右*/ .g-mn4 &#123; float: right; width: 100%; margin-left: -200px; &#125; .g-mnc4 &#123; margin-left: 210px; &#125; .g-sd4 &#123; float: left; width: 200px; &#125; .g-mn5 &#123; float: left; width: 100%; margin-right: -200px; &#125; .g-mnc5 &#123; margin-right: 210px; &#125; .g-sd5 &#123; float: right; width: 200px; &#125;&lt;/style&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;div class=\"g-bd\"&gt; &lt;div class=\"g-mn1\"&gt; &lt;div class=\"g-mnc1\"&gt; &lt;p&gt;主列1内容区&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"g-sd1\"&gt; &lt;p&gt;侧列1内容区&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"g-bd\"&gt; &lt;div class=\"g-mn2\"&gt; &lt;div class=\"g-mnc2\"&gt; &lt;p&gt;主列2内容区&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"g-sd2\"&gt; &lt;p&gt;侧列2内容区&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"g-bd\"&gt; &lt;div class=\"g-mn3\"&gt; &lt;div class=\"g-mnc3\"&gt; &lt;p&gt;主列3内容区&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"g-sd3a\"&gt; &lt;p&gt;侧列a内容区&lt;/p&gt; &lt;/div&gt; &lt;div class=\"g-sd3b\"&gt; &lt;p&gt;侧列b内容区&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"g-bd\"&gt; &lt;div class=\"g-mn4\"&gt; &lt;div class=\"g-mnc4\"&gt; &lt;div class=\"g-mn5\"&gt; &lt;div class=\"g-mnc5\"&gt; &lt;p&gt;主列5内容区&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"g-sd5\"&gt; &lt;p&gt;侧列5内容区&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;div class=\"g-sd4\"&gt; &lt;p&gt;侧列4内容区&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 七. 全屏自适应 absolute 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;style&gt; html, body &#123; width: 100%; height: 100%; overflow: hidden; margin: 0; &#125; html &#123; _height: auto; _padding: 100px 0 50px; &#125; .g-hd, .g-sd, .g-mn, .g-ft &#123; position: absolute; left: 0; &#125; .g-hd, .g-ft &#123; width: 100%; &#125; .g-sd, .g-mn &#123; top: 100px; bottom: 50px; _height: 100%; overflow: auto; &#125; .g-hd &#123; top: 0; height: 100px; &#125; .g-sd &#123; width: 300px; &#125; .g-mn &#123; _position: relative; left: 300px; right: 0; _top: 0; _left: 0; _margin-left: 300px; &#125; .g-ft &#123; bottom: 0; height: 50px; &#125;&lt;/style&gt; 123456789101112&lt;div class=\"g-hd\"&gt; 顶部&lt;/div&gt;&lt;div class=\"g-sd\"&gt; 内容左侧&lt;/div&gt;&lt;div class=\"g-mn\"&gt; 内容右侧&lt;/div&gt;&lt;div class=\"g-ft\"&gt; 底部&lt;/div&gt; flex 123456789101112131415161718192021222324252627&lt;style&gt; html, body, .wrapper &#123; height: 100%; overflow: hidden; &#125; .wrapper &#123; display: flex; flex-direction: column; &#125; .g-hd &#123; height: 100px; &#125; .g-ft &#123; height: 50px; &#125; .g-md &#123; flex: 1; display: flex; &#125; .g-md .g-sd &#123; width: 200px; &#125; .g-md .g-mn &#123; flex: 1; overflow: auto; &#125;&lt;/style&gt; 12345678910111213141516&lt;div class=\"wrapper\"&gt; &lt;div class=\"g-hd\"&gt; 顶部 &lt;/div&gt; &lt;div class=\"g-md\"&gt; &lt;div class=\"g-sd\"&gt; 内容左侧 &lt;/div&gt; &lt;div class=\"g-mn\"&gt; 内容右侧 &lt;/div&gt; &lt;/div&gt; &lt;div class=\"g-ft\"&gt; 底部 &lt;/div&gt;&lt;/div&gt; 八. 底部显示自适应123456789101112131415161718192021&lt;style&gt; html, body &#123; width: 100%; height: 100%; margin: 0; &#125; .g-doc &#123; position: relative; min-height: 100%; _height: 100%; &#125; .g-bd &#123; padding: 0 0 60px; zoom: 1; &#125; .g-ft &#123; height: 50px; margin: -50px 0 0; background: #ddd; &#125;&lt;/style&gt; 123456789101112&lt;div class=\"g-doc\"&gt; &lt;div class=\"g-bd\"&gt; &lt;p&gt;请增加或减少内容，或改变窗口大小，以便查看效果。&lt;/p&gt; &lt;p&gt;请增加或减少内容，或改变窗口大小，以便查看效果。&lt;/p&gt; &lt;p&gt;请增加或减少内容，或改变窗口大小，以便查看效果。&lt;/p&gt; &lt;p&gt;请增加或减少内容，或改变窗口大小，以便查看效果。&lt;/p&gt; &lt;p&gt;请增加或减少内容，或改变窗口大小，以便查看效果。&lt;/p&gt; &lt;/div&gt;&lt;/div&gt;&lt;div class=\"g-ft\"&gt; &lt;p&gt;底部始终在文档末尾，当文档较长时跟随在文档末尾，当文档较短时在窗口底部。&lt;/p&gt;&lt;/div&gt; 九. 前自适应后跟随12345678910111213141516&lt;style&gt; .m-demo &#123; padding: 5px 0; border-bottom: 1px dotted #ddd; font-size: 12px; &#125; .m-demo .cnt &#123; float: left; margin-right: 80px; &#125; .m-demo .date &#123; display: inline; float: left; margin-left: -70px; &#125;&lt;/style&gt; 1234&lt;div class=\"m-demo f-cb\"&gt; &lt;div class=\"cnt\"&gt;这是一段长度未知的文本，自动换行，且不会把右边的时间挤掉，修改这段文字长度或改变窗口宽度试试。&lt;/div&gt; &lt;div class=\"date\"&gt;2009-08-08&lt;/div&gt;&lt;/div&gt; 十. 图文问题123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293&lt;style&gt; /* 左图右文 */ .m-demo:after, .m-demo li .cnt:after &#123; display: block; clear: both; visibility: hidden; height: 0; overflow: hidden; content: \".\"; &#125; .m-demo, .m-demo li .cnt &#123; zoom: 1; &#125; .m-demo &#123; width: 640px; margin: 0 0 1em; overflow: hidden; background: #dfedf0; &#125; .m-demo ul &#123; padding: 0; margin: -11px 0 -10px; &#125; .m-demo li &#123; padding: 10px 0; border-top: 1px dashed #999; &#125; .m-demo .img &#123; float: left; width: 100px; height: 100px; padding: 5px; border: 1px solid #ccc; margin-right: -112px; background: #eee; &#125; .m-demo .img img, .m-demo .img a &#123; display: block; width: 100px; height: 100px; &#125; .m-demo .txt &#123; line-height: 18px; color: #666; margin-left: 122px; &#125; .m-demo .txt h3 &#123; margin: 0 0 3px; font-size: 14px; &#125; .m-demo .txt a, .m-demo .txt a:hover &#123; color: #f60; &#125; .m-demo .txt p &#123; font-size: 12px; margin: 0; &#125; /* 左图右文列表 */ .m-demo-1 ul &#123; margin: -21px 0 0 -20px; &#125; .m-demo-1 li &#123; float: left; display: inline; width: 200px; overflow: hidden; margin: 1px 0 -11px; padding: 20px 0 10px 20px; border-top: none; border-bottom: 1px dashed #999; &#125; /* 上图下文列表 */ .m-demo-2 ul &#123; margin: -20px 0 0 -20px; &#125; .m-demo-2 li &#123; float: left; display: inline; width: 112px; padding: 0; border: none; margin: 20px 0 0 20px; overflow: hidden; &#125; .m-demo-2 .img &#123; float: none; &#125; .m-demo-2 .txt &#123; margin: 6px 0 0 0; &#125;&lt;/style&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102&lt;div class=\"m-demo\"&gt; &lt;ul&gt; &lt;li&gt; &lt;div class=\"cnt\"&gt; &lt;div class=\"img\"&gt;&lt;a href=\"#\"&gt;&lt;img src=\"http://nec.netease.com/img/s/3.jpg\"&gt;&lt;/a&gt;&lt;/div&gt; &lt;div class=\"txt\"&gt; &lt;h3&gt;&lt;a href=\"#\"&gt;标题标题标题标题&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;左图右文左图右文左图右文左图右文左图右文左图右文左图右文左图右文左图右文左图右文左图右文左图右文左图右文左图右文左图右文左图右文左图右文左图右文左图右文&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div class=\"cnt\"&gt; &lt;div class=\"img\"&gt;&lt;a href=\"#\"&gt;&lt;img src=\"http://nec.netease.com/img/s/3.jpg\"&gt;&lt;/a&gt;&lt;/div&gt; &lt;div class=\"txt\"&gt; &lt;h3&gt;&lt;a href=\"#\"&gt;标题标题标题标题&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;左图右文左图右文左图右文左图右文左图右文左图右文左图右文左图右文左图右文左图右文左图右文左图右文左图右文左图右文左图右文左图右文左图右文左图右文左图右文&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div class=\"m-demo m-demo-1\"&gt; &lt;ul&gt; &lt;li&gt; &lt;div class=\"cnt\"&gt; &lt;div class=\"img\"&gt;&lt;a href=\"#\"&gt;&lt;img src=\"http://nec.netease.com/img/s/3.jpg\"&gt;&lt;/a&gt;&lt;/div&gt; &lt;div class=\"txt\"&gt; &lt;h3&gt;&lt;a href=\"#\"&gt;标题标题标题标题&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;左图右文列表左图右文列表左图右文列表左图右文列表左图右文列表&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div class=\"cnt\"&gt; &lt;div class=\"img\"&gt;&lt;a href=\"#\"&gt;&lt;img src=\"http://nec.netease.com/img/s/3.jpg\"&gt;&lt;/a&gt;&lt;/div&gt; &lt;div class=\"txt\"&gt; &lt;h3&gt;&lt;a href=\"#\"&gt;标题标题标题标题&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;左图右文列表左图右文列表左图右文列表左图右文列表左图右文列表&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div class=\"cnt\"&gt; &lt;div class=\"img\"&gt;&lt;a href=\"#\"&gt;&lt;img src=\"http://nec.netease.com/img/s/3.jpg\"&gt;&lt;/a&gt;&lt;/div&gt; &lt;div class=\"txt\"&gt; &lt;h3&gt;&lt;a href=\"#\"&gt;标题标题标题标题&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;左图右文列表左图右文列表左图右文列表左图右文列表左图右文列表&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt;&lt;div class=\"m-demo m-demo-2\"&gt; &lt;ul&gt; &lt;li&gt; &lt;div class=\"cnt\"&gt; &lt;div class=\"img\"&gt;&lt;a href=\"#\"&gt;&lt;img src=\"http://nec.netease.com/img/s/3.jpg\"&gt;&lt;/a&gt;&lt;/div&gt; &lt;div class=\"txt\"&gt; &lt;h3&gt;&lt;a href=\"#\"&gt;标题标题标题&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;上图下文列表上图下文列表上图下文列表上图下文列表&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div class=\"cnt\"&gt; &lt;div class=\"img\"&gt;&lt;a href=\"#\"&gt;&lt;img src=\"http://nec.netease.com/img/s/3.jpg\"&gt;&lt;/a&gt;&lt;/div&gt; &lt;div class=\"txt\"&gt; &lt;h3&gt;&lt;a href=\"#\"&gt;标题标题标题&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;上图下文列表上图下文列表上图下文列表&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div class=\"cnt\"&gt; &lt;div class=\"img\"&gt;&lt;a href=\"#\"&gt;&lt;img src=\"http://nec.netease.com/img/s/3.jpg\"&gt;&lt;/a&gt;&lt;/div&gt; &lt;div class=\"txt\"&gt; &lt;h3&gt;&lt;a href=\"#\"&gt;标题标题标题&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;上图下文列表上图下文列表上图下文列表上图下文列表&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div class=\"cnt\"&gt; &lt;div class=\"img\"&gt;&lt;a href=\"#\"&gt;&lt;img src=\"http://nec.netease.com/img/s/3.jpg\"&gt;&lt;/a&gt;&lt;/div&gt; &lt;div class=\"txt\"&gt; &lt;h3&gt;&lt;a href=\"#\"&gt;标题标题标题&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;上图下文列表上图下文列表上图下文列表上图下文列表上图下文列表上图下文列表上图下文列表&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;li&gt; &lt;div class=\"cnt\"&gt; &lt;div class=\"img\"&gt;&lt;a href=\"#\"&gt;&lt;img src=\"http://nec.netease.com/img/s/3.jpg\"&gt;&lt;/a&gt;&lt;/div&gt; &lt;div class=\"txt\"&gt; &lt;h3&gt;&lt;a href=\"#\"&gt;标题标题标题&lt;/a&gt;&lt;/h3&gt; &lt;p&gt;上图下文列表上图下文列表上图下文列表上图下文列表上图下文列表&lt;/p&gt; &lt;/div&gt; &lt;/div&gt; &lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 十一. 表头固定内容滚动12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;style&gt; .m-demo &#123; margin: 0 0 20px; line-height: 18px; &#125; .m-demo .scroll &#123; max-height: 116px; border: 1px solid #ddd; border-top: 0; overflow-y: auto; &#125; .m-demo table &#123; width: 100%; table-layout: fixed; &#125; .m-demo th, .m-demo td &#123; width: 100px; padding: 10px; border: 1px solid #ddd; &#125; .m-demo th &#123; font-weight: bold; background: #eee; &#125; .m-demo thead th:last-child, .m-demo tbody td:last-child &#123; width: auto; &#125; .m-demo tbody tr:nth-child(2n) &#123; background: #fafafa; &#125; .m-demo tbody tr:first-child td &#123; border-top: 0; &#125; .m-demo tbody tr:last-child td &#123; border-bottom: 0; &#125; .m-demo tbody tr td:first-child &#123; border-left: 0; &#125; .m-demo tbody tr td:last-child &#123; border-right: 0; &#125;&lt;/style&gt; 12345678910111213141516171819&lt;div class=\"m-demo\"&gt; &lt;table&gt; &lt;thead&gt; &lt;tr&gt;&lt;th&gt;定宽a&lt;/th&gt;&lt;th&gt;定宽b&lt;/th&gt;&lt;th&gt;定宽c&lt;/th&gt;&lt;th&gt;最后列不定宽d&lt;/th&gt;&lt;/tr&gt; &lt;/thead&gt; &lt;/table&gt; &lt;div class=\"scroll\"&gt; &lt;table&gt; &lt;tbody&gt; &lt;tr&gt;&lt;td&gt;定宽a&lt;/td&gt;&lt;td&gt;定宽b&lt;/td&gt;&lt;td&gt;定宽c&lt;/td&gt;&lt;td&gt;最后列不定宽d&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;定宽a&lt;/td&gt;&lt;td&gt;定宽b&lt;/td&gt;&lt;td&gt;定宽c&lt;/td&gt;&lt;td&gt;最后列不定宽d&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;定宽a&lt;/td&gt;&lt;td&gt;定宽b&lt;/td&gt;&lt;td&gt;定宽c&lt;/td&gt;&lt;td&gt;最后列不定宽d&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;定宽a&lt;/td&gt;&lt;td&gt;定宽b&lt;/td&gt;&lt;td&gt;定宽c&lt;/td&gt;&lt;td&gt;最后列不定宽d&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;定宽a&lt;/td&gt;&lt;td&gt;定宽b&lt;/td&gt;&lt;td&gt;定宽c&lt;/td&gt;&lt;td&gt;最后列不定宽d&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;定宽a&lt;/td&gt;&lt;td&gt;定宽b&lt;/td&gt;&lt;td&gt;定宽c&lt;/td&gt;&lt;td&gt;最后列不定宽d&lt;/td&gt;&lt;/tr&gt; &lt;/tbody&gt; &lt;/table&gt; &lt;/div&gt;&lt;/div&gt; 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"css","slug":"css","permalink":"https://wangchloe.vip/tags/css/"}]},{"title":"每天10个前端知识点：正则应用篇","date":"2017-02-17T19:27:35.000Z","path":"2017/02/18/blog20/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 1. 校验座机号码示例：021-88888880791-88888888 区号- -&gt; (0[1-9]\\d{1,2}-)? 3/4位数字 首位数字为0、第二位非0 区号-可有可无 号码 -&gt; [1-9]\\d{6,7} 7/8位数字 首位数字非0 正则：/^(0[1-9]\\d{1,2}-)?[1-9]\\d{6,7}$/ 2. 校验邮箱示例：wangchloe@yeah.net123123123@163.com.cn用户名 + @ + 域名 + . + 后缀`\\w+ @ [a-z0-9-]+ (.[a-z]{2,8}){1,2} 正则：/^\\w+@[a-z0-9-]+(\\.[a-z]{2,8}){1,2}$/ 3. 校验年龄(18-100)18-19 20-99 1001[89] | [2-9]\\d | 100 正则：/^1[89]|[2-9]\\d|100$/ ^优先级比|高，会先执行^1[89]和100$，并且^与超过两个|同时出现就会错乱，需要加括号包裹多个条件，提升优先级 /^([89]|[2-9]\\d|100)$/ 4. 仿trim()去除首尾空格 去首空格 ^\\s+ 去尾空格 \\s+$ 去掉开头为空格或者空格为结尾 正则：/^\\s+|\\s+$/ 5. 校验名字str.fromCharCode(&#39;0x4e00&#39;)第一个中文 0x4e00 一最后一个中文 0x9fa5 龥(yu) unicode编码：统一编码 utf-8 utf-16 utf-32以\\u开头 \\u4e00(一) ~ \\u9fa5(龥) GB2312编码 两个到七个汉字正则：/^[\\u4e00-\\u9fa5]{2,7}$/ 6. 首字母大写123456789&lt;script&gt; var str = &apos;this is wangchloe&apos;; var str2 = str.replace(/\\w+/g, function(s) &#123; return s.charAt(0).toUpperCase() + s.substring(1); &#125;); console.log(str2); // This is wangchloe&lt;/script&gt; 7. 过滤标签123456&lt;script&gt; var str = oBox.innerHTML; var str2 = str.replace(/&lt;[^&gt;]+&gt;/g, &apos;&apos;); console.log(str2);&lt;/script&gt; 8. 正则getByClass等方法12345678910111213141516171819202122232425262728293031323334353637383940&lt;script&gt; function getByClass(oParent, sClass) &#123; // oParent为从哪个父级下面查找类为sClass的元素 if(oParent.getElementsByClassName) &#123; // IE8- -&gt; undefined 高级浏览器 -&gt; function return oParent.getElementsByClassName(sClass); // 高级浏览器 &#125; else &#123; // IE8 var arr = []; var aEle = oParent.getElementsByTagName(&apos;*&apos;); var reg = new RegExp(&apos;\\\\b&apos; + sClass + &apos;\\\\b&apos;); for (var i = 0; i &lt; aEle.length; i++) &#123; if(reg.test(aEle[i].className)) &#123; arr.push(aEle[i]); &#125; &#125; return arr; &#125; &#125; function hasClass(obj, sClass) &#123; var reg = new RegExp(&apos;\\\\b&apos; + sClass + &apos;\\\\b&apos;); return reg.test(obj.className); &#125; function addClass(obj, sClass) &#123; if(obj.className) &#123; if(!hasClass(obj, sClass)) &#123; obj.className += &apos; &apos; + sClass; &#125; &#125; else &#123; obj.className = sClass; &#125; &#125; function removeClass(obj, sClass) &#123; var reg = new RegExp(&apos;\\\\b&apos; + sClass + &apos;\\\\b&apos;); if(hasClass(obj, sClass)) &#123; // obj.className = obj.className.replace(reg, &apos;&apos;).replace(/^\\s+/g, &apos;&apos;); obj.className = obj.className.replace(reg, &apos;&apos;).replace(/\\s+/g, &apos; &apos;).replace(/^\\s+|\\s+$/, &apos;&apos;); &#125; &#125;&lt;/script&gt; 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"js","slug":"js","permalink":"https://wangchloe.vip/tags/js/"},{"name":"应用","slug":"应用","permalink":"https://wangchloe.vip/tags/应用/"}]},{"title":"每天10个前端知识点：正则表达式","date":"2017-02-16T19:27:35.000Z","path":"2017/02/17/blog19/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 1. 正则表达式用处：处理字符串 RegExp对象var reg = new RegExp(&#39;字符串&#39;, [选项]); 可选选项 选项： i ignore 忽略大小写 g global 全局匹配 m multi-line 多行匹配 字符串为正则表达式时，不能用选项，直接在正则表达式//后增加选项 2. 正则定义的多种方法 var a = &#39;aaa&#39;;var reg = new RegExp(a, &#39;g&#39;); 正则可以使用变量形式 var reg = /\\d+/g; 正则不可以使用变量形式 str.replace(/\\d/g, &#39;&#39;); 3. 正则校验reg.test(str); true -&gt; 校验通过 false -&gt; 校验不通过 4. 正则使用的字符串相关方法 str.search(&#39;w&#39;) 查找w 成功 返回w的下标 失败 返回-1 str.match(&#39;w&#39;) 匹配w 返回值类型：数组(object) 成功 返回w 失败 返回null str.replace(&#39;xxx&#39;, &#39;yyy&#39;) 被替换内容，替换内容 修改第一个被替换内容 替换不修改原字符串, 需重新声明 第二个参数可为一个方法 replace可以连用 示例1234567&lt;script&gt; var str = &apos;aaa&apos;; var str2 = str.replace(&apos;a&apos;, &apos;b&apos;); console.log(str); // aaa console.log(str2); // baa&lt;/script&gt; 12345678910&lt;script&gt; str.replace(&apos;xxx&apos;, function(s) &#123; console.log(s); // **参数s为被替换字符 数据类型：string var star = &apos;&apos;; for (var i = 0; i &lt; s.length; i++) &#123; star += &apos;*&apos;; &#125; return star; // 返回替换内容 &#125;)&lt;/script&gt; 5. 特殊字符 . 匹配任何单字符(除换行符\\n) ^ 匹配开始位置 不选m 匹配字符串的开始位置 选m 识别字符串的换行，并匹配字符串每行的开始位置 $ 匹配结束位置 () 标记子表达式 [] 标记元字符表达式 {} 标记限定符表达式 6. 元字符(一个字符) [abc] 字符集合 -&gt; /a|b|c/ [^abc] 负值字符集合 -&gt; 除了abc [0-9] 字符范围 -&gt; /0|1|2|3|4|5|6|7|8|9/ eg: [1-29] -&gt; [1-2]或者[1-9] [^0-9] 负值字符范围 -&gt; 非数字 7. 限定符 {n} 匹配n个 {n,} 最少匹配n个 {,m} 最多匹配m个 {n,m}最少匹配n个，最多匹配m个 n,m为非负整数(n&lt;=m) * 匹配{0,} eg: &#39;zo*&#39; -&gt; &#39;z&#39;及&#39;zo&#39;、&#39;zooooo&#39; + 匹配{1,} eg: &#39;zo+&#39; -&gt; &#39;zo&#39;及&#39;zoo&#39;、&#39;zooooo&#39; ? 匹配{0,1} eg: &#39;do(es)?&#39; -&gt; &#39;do&#39;或&#39;does&#39; 8. 转义字符 \\\\ \\ eg: \\\\\\\\\\ -&gt; \\\\ 会报错 \\n 换行符 \\r 回车符 \\f 换页符 \\d digital 数字(不认识小数) [0-9] \\w word 单词(包括下划线) [A-Za-z0-9_] \\s space 空白字符 \\D 非数字 [^0-9] \\W 非单词 [^A-Za-z0-9_] \\S 非空白字符 var reg = /\\d/; -&gt; 选项 /\\d/g; -&gt; 匹配一次或多次 /\\d+/g 9.单词边界找确定单词时在正则中加上单词边界 \\b 在正则中需转义为 \\\\b var reg = new RegExp(&#39;\\\\bAAAA\\b&#39;); 10. 简单示例 /\\d+/ 一串数字 /\\d\\d+/ 最少2个数字 /.+/ 任意多个 /.*/ 可有可无 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"js","slug":"js","permalink":"https://wangchloe.vip/tags/js/"}]},{"title":"每天10个前端知识点：jQuery(下)","date":"2017-02-15T19:27:35.000Z","path":"2017/02/16/blog18/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 1. jQuery获取物体信息js obj.offsetWidth obj.offsetHeight obj.offsetLeft obj.offsetTop obj.parentNode 结构父级 根：document obj.offsetParent 定位父级 根：body js处理小数较弱，取出时取整Math.round() jQuery(只封装了以下方法) obj.width(); 纯width obj.height(); 纯height obj.outerWidth(); 盒子模型的width (width+padding+border) =&gt; offsetWidth obj.outerHeight(); 盒子模型的height (height+padding+border) =&gt; offsetHeight obj.position().left; 距离定位父级left值 (不包括margin) =&gt; offsetLeft obj.position().top; 距离定位父级top值 (不包括margin) =&gt; offsetTop obj.offset().left; 距离定位父级left值 (包括margin) obj.offset().top; 距离定位父级top值 (包括margin) obj.scrollTop(); 元素相对滚动条顶部的偏移 obj.scrollLeft(); 元素相对滚动条左侧的偏移 父级 obj.parent() 结构父级 根：document =&gt; parentNode obj.parents() 返回被选元素的所有祖先元素，直到&lt;html&gt; obj.offsetParent() 定位父级 根：body =&gt; offsetParent 子级 obj.children() 返回被选元素的所有直接子元素 obj.find() 返回被选元素的后代元素，一路向下直到最后一个后代 2. jQuery筛选(1) 过滤 .eq(index) index &gt;= 0 正向选取(0代表第一个，1代表第二个) index &lt; 0 反向选取(-1代表倒数第一个) .first() .last() .hasClass(className) (2) 查找 .find(tagName/className/id) eg: oBox.find(&#39;ol li&#39;); 3. jQuery &lt;=&gt; js(1) 原生js转jQuery对象$() 包裹this -&gt; $(this)document -&gt; $(document) 1234&lt;script&gt; var oDiv = document.getElementById(&apos;div1&apos;); $(oDiv).html(&apos;xxx&apos;);&lt;/script&gt; (2) jQuery转原生js对象[] / get() $(&#39;div&#39;)[0].innerHTML = &#39;xxx&#39;; $(&#39;div&#39;).get(0).innerHTML = &#39;xxx; 4. jQuery链式运动obj.css(...).html(...).attr(...).click(); 5. jQuery循环obj.each(function(){...}); JS中的forEach、$.each、map方法推荐 eg:123456&lt;script&gt; $(&apos;div&apos;).each(function(index, element) &#123; // 索引，当前元素 console.log($(element).html); // **element是原生对象，需转成jq对象 $(this); // 当前对象 &#125;);&lt;/script&gt; 6. jQuery工具 $.trim(str); 去掉字符串起始和结尾的空格 $.browser.version; 浏览器版本 eg:12345&lt;script&gt; if($.browse.version.substring(0, 1) == &apos;6&apos;) &#123; // IE6 code here &#125;&lt;/script&gt; 7. jQuery Ajax$.ajax({...}); type: ‘get/post’ 12345678910111213&lt;script&gt; $.ajax(&#123; url: URL, data: &#123;&#125;, type: &apos;get&apos;, error: fn, complete: fn, time: 3000; success: function(str) &#123; console.log(str); &#125; &#125;)&lt;/script&gt; 8. jQuery jsonp$.ajax({...}); dataType: ‘jsonp’ cbName: ‘callback/cb’ 1234567891011&lt;script&gt; $.ajax(&#123; url: URL, data: &#123;&#125;, dataType: &apos;jsonp&apos;, cbName: &apos;callback&apos;, success: function(json) &#123; console.log(json); &#125; &#125;);&lt;/script&gt; 9. jQuery插件写插件$: jqfn: 帮助 jq里面除了插件里的this以外，其他都是原生的js jquery的$.extend和$.fn.extend作用及区别 一个插件$.fn.插件名 = fn; 1234567&lt;script&gt; $.fn.插件名 = function() &#123; this.css(&apos;name&apos;, &apos;value&apos;); // 插件中的this不用加$ &#125; $(&apos;div&apos;).插件名();&lt;/script&gt; 一组插件$.fn.extend(...); 插件调用不能用链式 1234567891011121314&lt;script&gt; $.fn.extend(&#123; 插件名1: function() &#123; this.css(&apos;name&apos;, &apos;value&apos;); &#125;, 插件名2: function() &#123; this.css(&apos;name&apos;, &apos;value&apos;); &#125; &#125;) // 插件调用不能用链式 $(&apos;div&apos;).插件名1(); $(&apos;div&apos;).插件名2();&lt;/script&gt; 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://wangchloe.vip/tags/jQuery/"}]},{"title":"每天10个前端知识点：jQuery(上)","date":"2017-02-14T19:27:35.000Z","path":"2017/02/15/blog17/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 1. jQuery &amp;&amp; js jQuery js onload $(function() {}); window.onload=function(){}; 获取元素 $(‘div’); document.getElementsByTagName(‘div’); 事件 obj.click(fn); obj.onclick=fn; this $(this) this 索引 $(this).index() aDiv[i].index=i;… 操作属性 (1)获取attr(name) (1). (2)设置attr(name, value) (2)[] (3)getAttribute()/setAttribute() 2. jQuery效果 .hide() 隐藏 .show() 显示 .slideDown() 下滑 .slideUp() 上滑 .fadeIn() 淡入 .fadeOut() 淡出 参数：time时间，easing运动方式，fn回调函数 .animate(params, [speed], [easing], fn) eg: .animate({width: &#39;100px&#39;, opacity: 1}, &#39;slow&#39;, {duration: 1000, easing: &#39;linear&#39;, complete: function(){...}}) animate()函数记得先清除定时器$(&#39;ul&#39;).stop().animate(...); 3. jQuery选择器(1) 伪类选择器 $(&#39;li:first&#39;) 第一个 $(&#39;li:last&#39;) 最后一个 $(&#39;li:eq(n)&#39;) 第n+1个 $(&#39;li:odd&#39;) 第奇数个 (tips:记忆odd字母个数为奇数个) $(&#39;li:even&#39;) 第偶数个 (tips:记忆even字母个数为偶数个) $(&#39;li:contains(xxx)&#39;) 包含文本xxx的li标签 $(&#39;li:has(p)&#39;) 包含p标签的li标签 (2) 属性选择器 $(&#39;input[type==password]&#39;) 属性type为password的input标签 4. jQuery操作css属性 获取 .css(&#39;name&#39;); 设置 单一样式 .css(&#39;name&#39;, &#39;value&#39;) 多个样式 .css({&#39;name&#39;: &#39;value&#39;, &#39;name2&#39;: &#39;value2&#39;})eg: .css(&#39;background-color&#39;: &#39;red&#39;)或者.css(&#39;backgroundColor&#39;: &#39;red&#39;) 5. jQuery操作内容 非表单 获取 .html() // innnerHTML 设置 .html(&#39;xxx&#39;) 表单 获取 .val() // value 设置 .val(&#39;xxx&#39;) 文本 获取 .text() 设置 .text(&#39;xxx&#39;) 6. jQuery操作类名 添加 .addClass(&#39;xxx&#39;) 删除 .removeClass(&#39;xxx&#39;) 添加/删除 .toggleClass(&#39;xxx&#39;) 7. jQuery操作属性 获取 .attr(name) 设置 单一属性 .attr(&#39;name&#39;, &#39;value&#39;) 多个属性 .attr({&#39;name&#39;: &#39;value&#39;, &#39;name2&#39;: &#39;value2&#39;}) 8. jQuery DOM(1) 创建元素$(&#39;&lt;div&gt;text&lt;/div&gt;&#39;) (2) 添加元素 .append()parent.append(child); 父级添加子级至末尾 .appendTochild.appendTo(parent); 子级追加至父级末尾 .prepend()parent.prepend(child); 父级添加子级至最前 .prependTo()child.prependTo(parent); 子级追加至父级最前 .before()sib1.before(sib2); sib2添加至同级sib1前面 .after()sib1.after(sib2); sib2添加至同级sib1后面 .insertBefore()sib1.insertBefore(sib2); sib1添加至同级sib2前面 .insertAfter()sib1.insertAfter(sib2); sib1添加至同级sib2后面 .wrap()child.wrap(parent); 子元素被父元素包裹 .unwrap()child.unwrap(); 子元素移出上级父元素 (3) 删除元素 .remove()obj.remove(); 删除obj节点 .empty()obj.empty(); 删除obj内所有子节点 .detach() $(‘p’).detach(); 删除所有p标签及其中内容 $(‘p’).detach(‘.hello’); 删除所有类为hello的p标签及其中内容 9. jQuery事件jQuery中所有事件都是绑定的 .ready() DOM完全加载时执行的函数 .change() .click() .dblclick() 双击 注意是dbl .contextmenu() 右击 .hover()hover(over, out) 可以绑定两个方法 1234567&lt;script&gt; obj.hover(function() &#123; // 移入 &#125;, function() &#123; // 移出 &#125;)&lt;/script&gt; .mouseover() .mouseout() .mousedown() .mouseup() .mousewheel 鼠标滚轮 jQuery没有封装这个函数，需用on事件绑定 .keydown() .keypress() .keyup() 最好不用jQuery封装的事件，都用on事件绑定 .on() 绑定 .off() 解绑 .bind() 绑定 .unbind() 解绑 // live() die() jQuery 1.7+被删除 jQuery事件绑定on()、bind()与delegate() 方法详解 事件相关 return false; 阻止默认事件、阻止冒泡 ev.preventDefault(); 阻止默认事件 ev.stopPropagation(); 阻止冒泡 事件委托 第一种方法.on(events, selector, callback) 1234567891011&lt;script&gt; // $(&apos;table td&apos;).on(&apos;hover&apos;, function() &#123; // $(this).toggleClass(&apos;active&apos;); // &#125;) // =&gt; $(&apos;table&apos;).on(&apos;hover&apos;, &apos;td&apos;, function() &#123; #(this).toggleClass(&apos;active&apos;); &#125;)&lt;/script&gt; 第二种方法.delegate() 12345&lt;script&gt; $(&apos;table&apos;).delegate(&apos;td&apos;, &apos;hover&apos;, function() &#123; $(this).toggleClass(&apos;active&apos;); &#125;)&lt;/script&gt; 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://wangchloe.vip/tags/jQuery/"}]},{"title":"每天10个前端知识点：ajax && jsonp","date":"2017-02-12T19:27:35.000Z","path":"2017/02/13/blog16/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 1. Ajax前导(1) XMLHttpRequest*兼容： 除IE6ie6 -&gt; 报错 (2) readyState就绪状态 0 uninitialized ajax 对象创建成功 1 loading 打开连接(已经建立连接) 2 loaded 发送数据 3 interactive 下载内容 4 complete 完成 (3) HTTP状态码重点 200 ok 304 not modified 403 Forbidden 404 Not found 405 Not allowed 414 Request-URI Too Long 500 Internal Server Error 502 Bad Gateway 附：全部状态码‘100’: ‘Continue’,‘101’: ‘Switching Protocols’,‘102’: ‘Processing’,‘200’: ‘OK’,‘201’: ‘Created’,‘202’: ‘Accepted’,‘203’: ‘Non-Authoritative Information’,‘204’: ‘No Content’,‘205’: ‘Reset Content’,‘206’: ‘Partial Content’,‘207’: ‘Multi-Status’,‘208’: ‘Already Reported’,‘226’: ‘IM Used’,‘300’: ‘Multiple Choices’,‘301’: ‘Moved Permanently’,‘302’: ‘Found’,‘303’: ‘See Other’,‘304’: ‘Not Modified’,‘305’: ‘Use Proxy’,‘307’: ‘Temporary Redirect’,‘308’: ‘Permanent Redirect’,‘400’: ‘Bad Request’,‘401’: ‘Unauthorized’,‘402’: ‘Payment Required’,‘403’: ‘Forbidden’,‘404’: ‘Not Found’,‘405’: ‘Method Not Allowed’,‘406’: ‘Not Acceptable’,‘407’: ‘Proxy Authentication Required’,‘408’: ‘Request Timeout’,‘409’: ‘Conflict’,‘410’: ‘Gone’,‘411’: ‘Length Required’,‘412’: ‘Precondition Failed’,‘413’: ‘Payload Too Large’,‘414’: ‘URI Too Long’,‘415’: ‘Unsupported Media Type’,‘416’: ‘Range Not Satisfiable’,‘417’: ‘Expectation Failed’,‘418’: ‘I\\’m a teapot’,‘421’: ‘Misdirected Request’,‘422’: ‘Unprocessable Entity’,‘423’: ‘Locked’,‘424’: ‘Failed Dependency’,‘425’: ‘Unordered Collection’,‘426’: ‘Upgrade Required’,‘428’: ‘Precondition Required’,‘429’: ‘Too Many Requests’,‘431’: ‘Request Header Fields Too Large’,‘451’: ‘Unavailable For Legal Reasons’,‘500’: ‘Internal Server Error’,‘501’: ‘Not Implemented’,‘502’: ‘Bad Gateway’,‘503’: ‘Service Unavailable’,‘504’: ‘Gateway Timeout’,‘505’: ‘HTTP Version Not Supported’,‘506’: ‘Variant Also Negotiates’,‘507’: ‘Insufficient Storage’,‘508’: ‘Loop Detected’,‘509’: ‘Bandwidth Limit Exceeded’,‘510’: ‘Not Extended’,‘511’: ‘Network Authentication Required’ (4) ajax提交方式 GET 数据在open提交 载体：url POST 数据在send提交 载体：请求头(setRequestHeader) 2. Ajax原生编写ajax.js 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374&lt;script&gt; function ajax(json) &#123; // url, data, type, success, error, time, loading, complete //路径，数据，方式，成功回调函数，失败回调函数，超时时间，等待动画，完成后的回调函数 // data数据格式为json json = json || &#123;&#125;; if(!json.url) &#123; alert('url is null!'); return; &#125; json.data = json.data || &#123;&#125;; json.type = json.type || 'get'; // 默认提交方式为GET json.time = json.time || 3000; // 默认超时时间为3000ms var timer = null; clearTimeout(timer); // 1. 获得ajax if(window.XMLHttpRequest) &#123; // 查看当前浏览器XMLHttpRequest是否是全局变量 var oAjax = new XMLHttpRequest(); &#125; else &#123; var oAjax = new ActiveXObject('Microsoft.XMLHTTP'); // IE6，传入微软参数 &#125; switch(json.type.toLowerCase()) &#123; case 'get': // 2. 打开地址 oAjax.open('GET', json.url + '?' + jsonToURL(json.data), true); // 提交方式(大写)，url，是否异步 // 3. 发送数据 oAjax.send(); break; case 'post': // 2. 打开地址 oAjax.open('POST', json.url, true); // 提交方式(大写)，url，是否异步 oAjax.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded'); // 设置请求头 // 3. 发送数据 oAjax.send(jsonToURL(json.data)); &#125; json.loading &amp;&amp; json.loading(); // 执行等待动画 // 4. 接收数据 oAjax.onreadystatechange = function() &#123; // 监控状态 if(oAjax.readyState == 4) &#123; json.complete &amp;&amp; json.complete(); if(oAjax.status &gt;= 200 &amp;&amp; oAjax.status &lt; 300 || oAjax.status == 304) &#123; json.success &amp;&amp; json.success(oAjax.responseText); // 执行成功的回调函数，responseText为响应内容 &#125; else &#123; json.error &amp;&amp; json.error(oAjax.status); // 执行失败的回调函数 &#125; clearTimeout(timer); &#125; &#125;; // 网络超时时执行 timer = null; timer = setTimeout(function() &#123; console.log('请求超时'); oAjax.onreadystatechange = null; &#125;, json.time); &#125; function jsonToUrl(json) &#123; var arr = []; for(var name in json) &#123; arr.push(name + '=' + json[name]); &#125; return arr.join('&amp;'); &#125;&lt;/script&gt; 3. Ajax服务器相关 oAjax.getAllResponseHeaders(); 获取ajax服务全部信息 oAjax.getResponseHeader(&#39;xxx&#39;); 获取ajax服务器相关信息 4. Ajax2.0事件 oAjax.onload 替代oAjax.onreadystatechange oAjax.onerror 发生错误(网络层级的错误才会触发) oAjax.onprogress 上传进度(ev.loaded/ev.total) oAjax.onabort 中断 5. 关于锚点hash应用：刷新保留分页页码 cookie只有4k左右，此处应用hash保留分页页码 123456789101112131415161718192021&lt;style&gt; a&#123; display: block; width: 50px; height: 50px; border:1px solid #000; text-align: center; line-height: 50px; text-decoration: none; float: left; margin:10px; &#125; a:hover&#123; background: #f60; color: #fff; &#125; a.active&#123; background: #f60; color: #fff; &#125;&lt;/style&gt; 12345&lt;a href=\"javascirpt:;\" class=\"active\"&gt;1&lt;/a&gt;&lt;a href=\"javascirpt:;\"&gt;2&lt;/a&gt;&lt;a href=\"javascirpt:;\"&gt;3&lt;/a&gt;&lt;a href=\"javascirpt:;\"&gt;4&lt;/a&gt;&lt;a href=\"javascirpt:;\"&gt;5&lt;/a&gt; 1234567891011121314151617181920212223242526&lt;script&gt; window.onload = function() &#123; var aA = document.getElementsByTagName('a'); var hash = window.location.hash; var index = hash.substring(1); if(hash) &#123; tab(index-1); &#125; for (var i = 0; i &lt; aA.length; i++) &#123; aA[i].index = i; aA[i].onclick = function() &#123; var index = this.index; tab(index); window.location.hash = '#' + (this.index + 1); &#125;; &#125; function tab(index) &#123; for (var i = 0; i &lt; aA.length; i++) &#123; aA[i].className = ''; &#125; aA[index].className = 'active'; &#125; &#125;;&lt;/script&gt; 6. Ajax跨域同源策略：Ajax只能同域名下取数据 js跨域请求方式 jsonp(json with padding) 修改document.domain跨子域 window.name H5 window.postMessage(IE6 7不支持) CORS(跨域资源共享) 设置header: Access-Control-Allow-Origin nginx反向代理 JavaScript跨域总结与解决办法 7. jsonp前导 jsonp原理动态创建script标签，利用script:src可以跨域的属性跨域 HTML里面所有带src属性的标签都可以跨域，如iframe，img，script等。 不需要服务器环境 jsonp接口测试网址 8. jsonp原生编写jsonp.js 1234567891011121314151617181920212223242526272829303132333435&lt;script&gt; function jsonp(json) &#123; // url, data, cbName, success // 路径，参数，回调函数名字，回调函数 json = json || &#123;&#125;; if(!json.url) &#123; return; &#125; json.data = json.data || &#123;&#125;; json.cbName = json.cbName || 'cb'; // 默认回调函数名字为cb，回调函数名一般为cb或callback var fnNmae = 'jsonp_' + Math.random(); fnName = fnName.replace('.', ''); // 定义随机函数名，但名内不能包含. // 全局函数防止与外部函数jsonp()重名 window[fnName] = function(json2) &#123; json.success &amp;&amp; json.success(json2); oHead.removeChild(oS); &#125;; json.data[json.cbName] = fnName; var arr = []; for(var name in json.data) &#123; arr.push(name + '=' + json.data[name]); &#125; var oS = document.createElement('script'); // **动态创建script标签 var oHead = document.getElementsByTagName('head')[0]; oS.src = json.url + '?' + arr.join('&amp;'); // 动态script的src属性为jsonp的路径 oHead.appendChild(oS); // 插入到&lt;head&gt;标签最末 &#125;&lt;/script&gt; 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"js","slug":"js","permalink":"https://wangchloe.vip/tags/js/"}]},{"title":"每天10个前端知识点：原生篇(6)","date":"2017-02-06T19:27:35.000Z","path":"2017/02/07/blog15/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 本次内容：cookie、Require、数据交互前导 1. cookie数据类型：string 需在服务器环境中 不安全 过期时间(expires)：默认关闭浏览器时清空 session的常见实现形式是会话cookie（session cookie），即未设置过期时间的cookie;平常所说的cookie主要指的是另一类cookie——持久cookie（persistent cookies）。 12345&lt;script&gt; var oDate = new Date(); oDate.setDate(oDate.getDate()+3); // 延迟三天清空 document.cookie = 'expires=' + oDate;&lt;/script&gt; 容量小，4k左右 返回的数据类型是字符串，使用时需转化 内部能访问外部cookie，外部不能访问内部cookiepath统一设置到根目录 document.cookie = &#39;name=value;path=/&#39;; domain 设置域名访问 eg: baidu baidu.com domain=baidu.com 需在上一级域名设置domain fanyi.baidu.com setCookie baike.baidu.com getCookie 有缓存 封装cookie.js1234567891011121314151617181920212223242526272829303132333435&lt;script&gt; // 设置cookie function setCookie(name, value, iDay) &#123; if(iDay) &#123; var oDate = new Date(); oDate.setDate(oDate.getDate() + iDay); document.cookie = name + '=' + value + ';path=/;expires=' + oDate; // document.cookie = name + '=' + value + ';path=/;expires=' + oDate + ';domain=localhost'; // 设置只能在localhost下设置cookie &#125; else &#123; document.cookie = name + '=' + value + ';path=/'; // 关闭浏览器时清空 &#125; &#125; // cookie形式 eg: \"name1=value1; name2=value\" (表达式之间有空格) // 获取cookie function getCookie(name) &#123; var str = document.cookie; var arr = str.split('; '); // **分号后有空格 for(var i = 0; i &lt; arr.length; i++) &#123; var arr2 = arr[i].split('='); if(arr2[0] == name) &#123; return arr2[1]; &#125; &#125; return ''; // 没有找到即返回空字符串 &#125; // 移除cookie function removeCookie(name) &#123; setCookie(name, 'xxx', -10); // **将日期设为小于0的值 '-0'不能达到移除cookie的目的 &#125;&lt;/script&gt; 2. 模块化sea.js &amp;&amp; require.js sea.js require.js 采用CMD(通用模块定义,依赖就近) 采用AMD(异步模块定义,依赖前置) AMD 和 CMD 的区别有哪些? - 玉伯的回答 - 知乎 前端模块化（CommonJs,AMD和CMD） 详解JavaScript模块化开发 3. Require.jsRequireJS 中文网 好处 解决命名冲突 解决文件彼此依赖 自动引入js 异步加载，可维护性高只发送一个请求，最终引用文件命名为init.js或者&lt;script src=&quot;require.js&quot; data-main=&quot;init&quot;&gt;&lt;/script&gt; (1)定义模块r1.js123456789101112&lt;script&gt; define(function(require, exports, module) &#123; // 引入模块，导出模块，批量导出 exports.a = 1; // console.log(1); // return &#123;a:1, b:2&#125;; &#125;);&lt;/script&gt; (2)使用模块123456789&lt;script&gt; // require(['r1.js']); // 可不写函数 require(['r1.js'], function(mod) &#123; // **使用时注意路径，若报错试着将路径改为'js/r1.js' console.log(mod.a); // 1 &#125;)&lt;/script&gt; 1234567&lt;script&gt; require(['r1.js', 'r2.js'], function(mod1, mod2) &#123; // 使用多个模块 console.log(mod1.a, mod2.a); &#125;)&lt;/script&gt; (3)引用模块这里的模块依赖其实应该一开始就写好。 123456789101112&lt;script&gt; define(function(require, exports, module) &#123; // 引入模块，导出模块，批量导出 var mod1 = require('r1.js'); var mod2 = require('r2.js'); exports.sum = function() &#123; return mod1.a + mod2.a; &#125; &#125;);&lt;/script&gt; 因专用于js，require时可省略类型后缀 ‘js/r1.js’ -&gt; ‘js/r1’ Require的使用结构一般如下exp1.html放于主目录js文件放在js文件夹下 exp1.html1234567......&lt;script src=&quot;js/require.js&quot; data-main=&quot;js/init&quot;&gt;&lt;/script&gt;...... init.js 12345&lt;script&gt; require(['exp1']);&lt;/script&gt; exp1.js 123456789101112131415&lt;script&gt; define(function(require) &#123; var r1 = require('r1'); ... ... oBtn.onclick = function() &#123; ... r1(xxx); &#125; &#125;)&lt;/script&gt; r1.js123456789101112131415161718&lt;script&gt; define(function(require) &#123; var move = require('move'); ... ... return function(yyy) &#123; ... ... move(aaa, &#123;opacity: 1&#125;); &#125; &#125;)&lt;/script&gt; 4. 数据交互form提交数据缺点：(1)会刷新页面 (2)不能取出数据 想要提交数据须有 action 提交的地址 &lt;form action=&#39;&#39;&gt;&lt;/form&gt; name 数据名称 &lt;input name=&quot;user.tel&quot; /&gt; value 数据 input.value 提交方式 get(默认) 容量32K左右 不安全，有缓存 好处：(1)分享 (2)收藏 post 容量1G左右 相对安全，没有缓存 缓存(cache)对于浏览器而言，相同的地址只会访问一次 ajax(Asynchronous JavaScript and XML，异步JavaScript和XML) 需在服务器环境中 编码需一致 url若为文件名，可不写文件名后缀 返回的数据类型是字符串，使用时需转化 缓存(get方法)浏览器清除缓存 ctrl+F5 或 ctrl+alt+delete防止IE缓存 路径+随机因子 (1)&#39;路径?t=&#39; + Math.random(); (2)&#39;路径?t=&#39; + oDate.getTime(); eg:var URL = &#39;user.php?act=login&amp;user=&#39; + logU.value + &#39;&amp;pass=&#39; + logP.value + &#39;&amp;t=&#39; + new Date().getTime(); 5. eval的替代用法12345678&lt;script&gt; function strTrs(str) &#123; var fn = new Function('return' + str); return fn(); &#125;&lt;/script&gt; 6. 数据交互时输入中文问题中文转换URL编码 encodeURIComponent(str)解编码 decodeURIComponent(str) IE兼容写法12345&lt;script&gt; var URL = 'user.php?act=login&amp;user=' + encodeURIComponent(logU.value) + '&amp;pass=' + encodeURIComponent(logP.value) + '&amp;t=' + new Date().getTime();&lt;/script&gt; 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"js","slug":"js","permalink":"https://wangchloe.vip/tags/js/"}]},{"title":"每天10个前端知识点：命名规范","date":"2017-02-04T19:27:35.000Z","path":"2017/02/05/blog14/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 规范Reset.css张鑫旭-HTML5 css reset 目前比较全的CSS重设(reset)方法总结 css命名规范头：header 内容：content/container 尾：footer 导航：nav 侧栏：sidebar栏目：column 包裹层：wrapper 左右中：left right center 登录条：loginbar 标志：logo 抽奖：raffle广告：banner 页面主体：main 热点：hot 新闻：news下载：download 子导航：subnav 菜单：menu 子菜单：submenu 搜索：search 友情链接：friendlink 页脚：footer 版权：copyright 滚动：scroll 内容：content标签页：tab文章列表：list提示信息：msg小技巧：tips栏目标题：title加入：joinus指南：guide服务：service注册：regsiter状态：status投票：vote合作伙伴：partner 注释的写法 xxx id命名(1)页面结构容器: container页头：header内容：content/container页面主体：main页尾：footer导航：nav侧栏：sidebar栏目：column包裹层：wrapper左右中：left right center (2)导航导航：nav主导航：mainnav子导航：subnav顶导航：topnav边导航：sidebar左导航：leftsidebar右导航：rightsidebar菜单：menu子菜单：submenu标题: title摘要: summary (3)功能标志：logo广告：banner登陆：login登录条：loginbar注册：regsiter搜索：search功能区：shop标题：title加入：joinus状态：status按钮：btn滚动：scroll标签页：tab文章列表：list提示信息：msg当前的: current小技巧：tips图标: icon注释：note指南：guide服务：service热点：hot新闻：news下载：download投票：vote合作伙伴：partner友情链接：link版权：copyright class的命名(1) 颜色:使用颜色的名称或者16进制代码,如.red { color: red; }.f60 { color: #f60; }.ff8600 { color: #ff8600; } (2) 字体大小,直接使用”font+字体大小”作为名称,如.font12px { font-size: 12px; }.font9pt {font-size: 9pt; } (3) 对齐样式,使用对齐目标的英文名称,如 .left { float:left; } (4) 标题栏样式,使用”类别+功能”的方式命名,如.barnews { }.barproduct { } 注意事项1.一律小写;2.尽量用英文;3.尽量不缩写，除非一看就明白的单词. css层次主要的 main.css模块 module.css基本共用 base.css/global.css布局，版面 layout.css主题 themes.css专栏 columns.css文字 font.css表单 forms.css补丁 mend.css 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"前端周边","slug":"前端周边","permalink":"https://wangchloe.vip/tags/前端周边/"}]},{"title":"每天10个前端知识点：运动框架应用篇(下)","date":"2017-02-03T19:27:35.000Z","path":"2017/02/04/blog13/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 本次内容：打字依次显示效果、收起当前页放出下一页效果、分块运动、无缝幻灯片、带进度条的无缝幻灯片 10. 打字依次显示效果 12345678910&lt;style&gt; body &#123; background: #000; &#125; span &#123; color: #fff; font-size: 20px; opacity: 0; &#125;&lt;/style&gt; 12 123456789101112131415161718192021222324&lt;script type=\"text/javascript\" src='move.js'&gt;&lt;/script&gt;&lt;script&gt; window.onload = function () &#123; var str = '往左走(left负数)W = oUl.offsetWidth / 2;left -= 5;left = left % W;往右走(left正数)W = oUl.offsetWidht / 2;left += 5;left = (left % W - W) % W;'; for(var i = 0; i &lt; str.length; i++) &#123; var oS = document.createElement('span'); oS.innerHTML = str.charAt(i); document.body.appendChild(oS); &#125; var aSpan = document.body.children; var i = 0; // 分步运动 var timer = setInterval(function() &#123; move(aSpan[i], &#123;opacity: 1&#125;, &#123;duration: 100&#125;); i++; if(i == aSpan.length) &#123; clearInterval(timer); &#125; &#125;, 100); &#125;&lt;/script&gt; 效果示例 11. 收起当前页放出下一页效果12345678910111213141516171819&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; ul &#123; width: 516px; margin: 50px auto; &#125; ul li &#123; list-style: none; width: 150px; height: 150px; background: #ccc; float: left; margin: 10px; border: 1px solid #000; &#125;&lt;/style&gt; 123456789101112&lt;input type=\"button\" value=\"下一页\" id=\"btn1\" /&gt;&lt;ul id=\"ul1\"&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt;&lt;/ul&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576&lt;script type=\"text/javascript\" src='move.js'&gt;&lt;/script&gt;&lt;script&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn1'); var oUl = document.getElementById('ul1'); var aLi = oUl.children; // 浮动定位 -&gt; 绝对定位 var aPos = []; for (var i = 0; i &lt; aLi.length; i++) &#123; aPos[i] = &#123; left: aLi[i].offsetLeft, top: aLi[i].offsetTop &#125;; &#125; for (var i = 0; i &lt; aLi.length; i++) &#123; aLi[i].style.position = 'absolute'; aLi[i].style.left = aPos[i].left + 'px'; aLi[i].style.top = aPos[i].top + 'px'; aLi[i].style.margin = 0; &#125; var timer = null; var bSin = false; oBtn.onclick = function() &#123; if (bSin) return; bSin = true; // 分步运动 var i = 0; timer = setInterval(function()&#123; (function(index)&#123; // 收起 move(aLi[i], &#123; left: 0, top:0, width: 0, height: 0, opacity: 0 &#125;,&#123; complete: function() &#123; // 回调函数 if (index == aLi.length-1) &#123; // 放出 for (var i = 0; i &lt; aLi.length; i++) &#123; aLi[i].style.background = 'rgb('+parseInt(Math.random()*256)+','+parseInt(Math.random()*256)+','+parseInt(Math.random()*256)+')'; &#125; timer = setInterval(function()&#123; (function(index2)&#123; move(aLi[index], &#123; left: aPos[index].left, top: aPos[index].top, width: 150, height: 150, opacity: 1 &#125;,&#123; complete: function()&#123; if (index2 == 0) &#123; // 放出最后一张后点击才有效 bSin = false; &#125; &#125; &#125;); &#125;)(index); index--; if (index &lt; 0) &#123; clearInterval(timer); &#125; &#125;,200); &#125; &#125; &#125;) &#125;)(i); i++; if (i == aLi.length) &#123; clearInterval(timer); &#125; &#125;,200); &#125;; &#125;;&lt;/script&gt; 效果示例 12. 分块运动 自定义行数R、列数C 创建span计算oSpan的width、height、left、top、background-position 注意：先appendChild才能获取oSpan的offsetWidth和offsetHeight 分步运动，依次显示span 优化：setInterval可用for循环+setTimeout替代，可设置行列相关时同一时间出现 12345678910111213141516171819202122232425262728293031&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; #btn&#123; margin: 20px auto; padding: 5px; width: 100px; height: 20px; background: #f5850e; color: #fff; font-size: 16px; text-align: center; line-height: 20px; border-radius: 5px; cursor: pointer; &#125; #box &#123; position: relative; margin: 50px auto; width: 500px; height: 300px; background: url('img/slide0.jpg'); &#125; #box span&#123; position: absolute; opacity: .1; /* opacity: 0; */ &#125;&lt;/style&gt; 12&lt;div id='btn'&gt;点击随机变换&lt;/div&gt;&lt;div id=\"box\"&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980&lt;script type=\"text/javascript\" src='move.js'&gt;&lt;/script&gt;&lt;script&gt; window.onload = function() &#123; var oBtn = document.body.children[0]; var oBox = document.body.children[1]; var R = 3; var C = 5; // 整图 -&gt; 分块(绝对定位) for(var r = 0; r &lt; R; r++) &#123; for(var c = 0; c &lt; C; c++) &#123; var oSpan = document.createElement('span'); oSpan.style.width = oBox.offsetWidth / C + 'px'; oSpan.style.height = oBox.offsetHeight / R + 'px'; oBox.appendChild(oSpan); oSpan.style.left = oSpan.offsetWidth * c + 'px'; oSpan.style.top = oSpan.offsetHeight * r + 'px'; oSpan.style.backgroundPosition = - oSpan.offsetWidth * c + 'px ' + (-oSpan.offsetHeight * r) + 'px'; oSpan.r = r; oSpan.c = c; &#125; &#125; var aSpan = oBox.children; var iNow = 0; var bSin = false; oBtn.onclick = function() &#123; if(bSin) &#123;return;&#125; bSin = true; iNow++; oBox.style.background = 'url(\"img/slide'+ (iNow%9-1+9)%9 +'.jpg\")'; block(parseInt(Math.random()*7+1)); // 随机变换显示方式 &#125; var json = &#123;&#125;; for(var i = 0; i &lt; 8; i++) &#123; json[i] = 0; &#125; function block(method) &#123; json[method]++; var med = 1; for(var i = 0; i &lt; aSpan.length; i++) &#123; (function(index) &#123; switch(method) &#123; case 1: med = index; break; case 2: med = aSpan[index].r + aSpan[index].c; // 斜角显示 break; case 3: med = aSpan[index].r * aSpan[index].c; break; case 4: med = aSpan[index].r - aSpan[index].c; break; case 5: med = aSpan[index].r / aSpan[index].c; break; case 6: med = aSpan.length - index; // 由下至上 break; case 7: med = Math.random(); break; &#125; setTimeout(function()&#123; aSpan[index].style.backgroundImage = 'url(\"img/slide'+ iNow%9 + '.jpg\")'; aSpan[index].style.opacity = 0.1; (function(index2) &#123; move(aSpan[index], &#123;opacity: 1&#125;, &#123;complete: function() &#123; if(index2 == aSpan.length - 1) &#123; // 放出最后一个分块后点击才有效 bSin = false; &#125; &#125;&#125;); &#125;)(index); &#125;, 100*(med)); // 每个分块延迟时间不同，达到依次显示的效果 &#125;)(i); &#125; &#125; &#125;&lt;/script&gt; 效果示例 13. 仿Mac 感应变大效果 感应距离：一般为500 比例：scale = 1 - c/500; 勾股定理计算鼠标至图片中心距离 var a = getPos(aImg[i]).left + aImg[i].offsetWidth / 2 - oEvent.clientX; var b = getPos(aImg[i]).top + aImg[i].offsetHeight / 2 - oEvent.clientY; var c = Math.sqrt(a a + b b); 计算方放大比例，范围为[0.5, 1]var scale = 1 - c / 500;scale &lt; 0.5 &amp;&amp; (scale = 0.5);aImg[i].style.width = scale * 80 + ‘px’; 12345678910111213&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; #box &#123; position: absolute; bottom: 20px; width: 100%; text-align: center; &#125;&lt;/style&gt; 12345&lt;div id=\"box\"&gt; &lt;img src=\"img/per-1.png\" width=\"40\"&gt; &lt;img src=\"img/per-2.png\" width=\"40\"&gt; &lt;img src=\"img/per-3.png\" width=\"40\"&gt;&lt;/div&gt; 123456789101112131415161718192021222324252627282930313233&lt;script&gt; function getPos(obj) &#123; var l = 0; var t = 0; while(obj) &#123; l += obj.offsetLeft; t += obj.offsetTop; obj = obj.offsetParent; &#125; return &#123;left: l, top: t&#125;; &#125; window.onload = function() &#123; var oBox = document.body.children[0]; var aImg = oBox.children; document.onmousemove = function(ev) &#123; var oEvent = ev || event; for(var i = 0; i &lt; aImg.length; i++) &#123; // 勾股定理计算鼠标至图片中心距离 var a = getPos(aImg[i]).left + aImg[i].offsetWidth / 2 - oEvent.clientX; var b = getPos(aImg[i]).top + aImg[i].offsetHeight / 2 - oEvent.clientY; var c = Math.sqrt(a * a + b * b); //计算方放大比例，范围为[0.5, 1] var scale = 1 - c / 500; scale &lt; 0.5 &amp;&amp; (scale = 0.5); aImg[i].style.width = scale * 80 + 'px'; &#125; &#125; &#125;&lt;/script&gt; 效果示例 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"js","slug":"js","permalink":"https://wangchloe.vip/tags/js/"},{"name":"应用","slug":"应用","permalink":"https://wangchloe.vip/tags/应用/"}]},{"title":"每天10个前端知识点：运动框架应用篇(中)","date":"2017-02-02T19:27:35.000Z","path":"2017/02/03/blog12/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 本次内容：运动时钟、返回顶部、无缝滚动、无缝幻灯片、带进度条的无缝幻灯片 5. 运动时钟 1234567891011121314151617181920212223&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; #box &#123; margin: 20px auto; width: 185px; height: 35px; line-height: 35px; overflow: hidden; &#125; #box ul li &#123; float: left; position: relative; list-style: none; width: 23px; height: 35px; &#125; #box ul li img &#123; position: absolute; &#125;&lt;/style&gt; 123456789101112&lt;div id=\"box\"&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=\"img/num.png\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/num.png\"&gt;&lt;/li&gt; &lt;li&gt;:&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/num.png\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/num.png\"&gt;&lt;/li&gt; &lt;li&gt;:&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/num.png\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/num.png\"&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829&lt;script type=\"text/javascript\" src='move.js'&gt;&lt;/script&gt;&lt;script&gt; function toDou(num) &#123; return num &lt; 10 ? '0' + num : '' + num; &#125; window.onload = function() &#123; var oBox = document.body.children[0]; var oUl = oBox.children[0]; var aImg = oUl.getElementsByTagName('img'); clock(); setInterval(clock, 1000); function clock() &#123; var oDate = new Date(); var iH = oDate.getHours(); var iM = oDate.getMinutes(); var iS = oDate.getSeconds(); var str = toDou(iH) + toDou(iM) + toDou(iS); for(var i = 0; i &lt; aImg.length; i++) &#123; // aImg[i].style.top = - str.charAt(i) * 35 + 'px'; move(aImg[i], &#123;top: - str.charAt(i) * 35&#125;, &#123;duration: 500&#125;); &#125; &#125; &#125;&lt;/script&gt; 效果示例 6. 返回顶部 此例因为涉及documentElement，move.js中没有相关判断，所以用move.js原理写了一个 123456789101112&lt;style&gt; body &#123; height: 3000px; background: linear-gradient(red,blue); &#125; input &#123; position: fixed; right: 20px; bottom: 20px; display: none; &#125;&lt;/style&gt; 1&lt;input type=\"button\" value=\"返回顶部\" id=\"btn1\" /&gt; 123456789101112131415161718192021222324252627282930313233343536373839404142&lt;script&gt; window.onload = function() &#123; var oBtn = document.getElementById('btn1'); var timer = null; // 添加滚动事件 var bSin = false; window.onscroll = function() &#123; if (bSin) &#123; clearInterval(timer); &#125; bSin = true; var scrollT = document.documentElement.scrollTop || document.body.scrollTop; if (scrollT &gt; 0) &#123; // 按钮出来 oBtn.style.display = 'block'; &#125; else &#123; oBtn.style.display = 'none'; &#125; &#125;; // 按钮事件 oBtn.onclick = function() &#123; // 先关后开 var scrollT = document.documentElement.scrollTop || document.body.scrollTop; clearInterval(timer); var count = Math.floor(1000/30); var dis = 0 - scrollT; var n = 0; timer = setInterval(function()&#123; bSin = false; n++; var a = 1-n/count; var cur = scrollT + dis*(1-Math.pow(a,3)); document.documentElement.scrollTop = document.body.scrollTop = cur; if (n == count) &#123; clearInterval(timer); &#125; &#125;,30); &#125;; &#125;;&lt;/script&gt; 效果示例 7. 无缝滚动 此例资源为4张不重复图片，宽度为相应宽度*4 ul里的内容复制一份达到无缝的目的，再计算ul宽度 模%求得余数 往左走(left负数)W = oUl.offsetWidth / 2;left -= 5;left = left % W; 往右走(left正数)W = oUl.offsetWidht / 2;left += 5;left = (left % W - W) % W; 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; #box &#123; width: 1280px; height: 220px; border: 1px solid #000; position: relative; margin: 100px auto; overflow: hidden; &#125; #box ul &#123; position: absolute; left: 0; top: 0; &#125; #box ul li &#123; float: left; padding: 10px; list-style: none; width: 300px; height: 200px; &#125; #box ul li img &#123; width: 100%; height: 100%; &#125; #box span &#123; z-index: 2; position: absolute; top: 0; width: 640px; height: 220px; &#125; #left &#123; left: 0; &#125; #right &#123; right: 0; &#125;&lt;/style&gt; 12345678910&lt;div id=\"box\"&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=\"img/slide1.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/slide2.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/slide3.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/slide4.jpg\" alt=\"\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;span id=\"left\"&gt;&lt;/span&gt; &lt;span id=\"right\"&gt;&lt;/span&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;script&gt; window.onload = function() &#123; var oBox = document.getElementById('box'); var oUl = oBox.children[0]; var oL = oBox.children[1]; var oR = oBox.children[2]; var aLi = oUl.children; // 内容复制一份达到无缝的目的 oUl.innerHTML += oUl.innerHTML; // 重新计算ul宽度 oUl.style.width = aLi[0].offsetWidth * aLi.length + 'px'; var timer = null; oL.onmouseover = function() &#123; toLeft(); &#125;; oR.onmouseover = function() &#123; toRight(); &#125;; var left = 0; var W = oUl.offsetWidth/2; toRight(); // 默认向右滚动 function toRight() &#123; clearInterval(timer); timer = setInterval(function()&#123; left += 5; oUl.style.left = (left%W-W)%W + 'px'; &#125;,30); &#125; function toLeft() &#123; clearInterval(timer); timer = setInterval(function()&#123; left -= 5; oUl.style.left = (left%W-W)%W + 'px'; &#125;,30); &#125; &#125;;&lt;/script&gt; 效果示例 8. 无缝幻灯片 ul里的内容复制一份达到无缝的目的，再计算ul宽度 模%求得余数 往左走(left负数)W = oUl.offsetWidth / 2;left -= 5;left = left % W; 往右走(left正数)W = oUl.offsetWidht / 2;left += 5;left = (left % W - W) % W; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; #box &#123; position: relative; margin: 50px auto; width: 600px; height: 350px; overflow: hidden; &#125; #box ul &#123; position: absolute; &#125; #box ul li &#123; float: left; list-style: none; width: 100%; height: 100%; &#125; #box ul li img &#123; width: 100%; height: 100%; &#125; #box ol &#123; position: absolute; left: 50%; bottom: 10px; width: 100px; margin-left: -50px; &#125; #box ol li &#123; float: left; margin: 5px; list-style: none; width: 10px; height: 10px; border-radius: 50%; background: #666; opacity: .7; cursor: pointer; &#125; #box ol li.active &#123; background: #fff; &#125; #box a &#123; position: absolute; z-index: 1; top: 50%; margin-top: -25px; width: 30px; height: 50px; line-height: 50px; text-align: center; background: #666; color: #fff; opacity: .1; border-radius: 2px; text-decoration: none; &#125; #box a.prev &#123; left: 0; &#125; #box a.next &#123; right: 0; &#125;&lt;/style&gt; 123456789101112131415161718&lt;div id=\"box\"&gt; &lt;a href=\"javascript:;\" class=\"prev\"&gt;←&lt;/a&gt; &lt;a href=\"javascript:;\" class=\"next\"&gt;→&lt;/a&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=\"img/slide1.jpg\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/slide2.jpg\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/slide3.jpg\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/slide4.jpg\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/slide5.jpg\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li class=\"active\"&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;li&gt;&lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697&lt;script type=\"text/javascript\" src='move.js'&gt;&lt;/script&gt;&lt;script&gt; window.onload = window.onresize = function() &#123; var oBox = document.body.children[0]; var oPrev = oBox.children[0]; var oNext = oBox.children[1]; var oUl = oBox.children[2]; var oOl = oBox.children[3]; var aLi = oUl.children; var aBtn = oOl.children; var iNow = 0; oBox.onmouseover = function() &#123; clearInterval(timer2); move(oPrev, &#123;opacity: 0.7&#125;, &#123;duration: 500&#125;); move(oNext, &#123;opacity: 0.7&#125;, &#123;duration: 500&#125;); &#125; oBox.onmouseout = function() &#123; carousel(); move(oPrev, &#123;opacity: 0.1&#125;, &#123;duration: 300&#125;); move(oNext, &#123;opacity: 0.1&#125;, &#123;duration: 300&#125;); &#125; for(var i = 0; i &lt; aLi.length; i++) &#123; aLi[i].style.width = oBox.offsetWidth + 'px'; &#125; oUl.innerHTML += oUl.innerHTML; oUl.style.width = aLi.length * (aLi[0].offsetWidth) + 'px'; var timer2 = null; carousel(); function carousel() &#123; clearInterval(timer2); timer2 = setInterval(function() &#123; iNow++; tab(); &#125;, 3000); &#125; for(var i = 0; i &lt; aBtn.length; i++) &#123; aBtn[i].index = i; aBtn[i].onmouseover = function() &#123; // iNow = this.index; //第几轮，解决第二轮之后上移运动回第一轮的问题 iNow = Math.floor(iNow/aBtn.length)*aBtn.length+this.index; tab(); &#125; &#125; oPrev.onclick = function() &#123; iNow--; tab(); &#125; oNext.onclick = function() &#123; iNow++; tab(); &#125; function tab() &#123; for(var i = 0; i &lt; aBtn.length; i++) &#123; aBtn[i].className = ''; &#125; //解决当iNow&lt;0时aBtn[iNow%aBtn.length]找不到的问题 aBtn[(iNow%aBtn.length+aBtn.length)%aBtn.length].className = 'active'; // move(oUl, &#123;left: - aLi[0].offsetWidth * iNow&#125;, &#123;duration: 500&#125;); toR(oUl, - aLi[0].offsetWidth * iNow); &#125; var iW = oUl.offsetWidth / 2; var timer = null; var left = 0; function toR(obj, iTarget) &#123; clearInterval(timer); var start = left; var dis = iTarget - start; var count = Math.floor(1000 / 30); var n = 0; timer = setInterval(function() &#123; n++; var a = n / count; var cur = start + dis * a; left = cur; oUl.style.left = (left % iW - iW) % iW + 'px'; if(n == count) &#123; clearInterval(timer); &#125; &#125;, 30); &#125; &#125;&lt;/script&gt; 效果示例 9. 带进度条的无缝幻灯片12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; #box &#123; position: relative; margin: 50px auto; width: 350px; height: 200px; overflow: hidden; &#125; #box ul &#123; position: absolute; &#125; #box ul li &#123; float: left; list-style: none; width: 350px; height: 200px; text-align: center; line-height: 200px; font-size: 80px; color: #ffb; &#125; #box ol &#123; position: absolute; left: 50%; bottom: 10px; margin-left: -150px; width: 300px; &#125; #box ol li &#123; position: relative; float: left; margin: 10px; list-style: none; width: 40px; height: 10px; background: #fff; &#125; #box ol li span &#123; position: absolute; top: 0; width: 0; height: 10px; background: #666; &#125;&lt;/style&gt; 12345678910111213141516&lt;div id=\"box\"&gt; &lt;ul&gt; &lt;li style=\"background: #aaa\"&gt;1&lt;/li&gt; &lt;li style=\"background: #afe\"&gt;2&lt;/li&gt; &lt;li style=\"background: #50f\"&gt;3&lt;/li&gt; &lt;li style=\"background: #aea\"&gt;4&lt;/li&gt; &lt;li style=\"background: #fe0\"&gt;5&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li&gt;&lt;span&gt;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;&lt;/span&gt;&lt;/li&gt; &lt;li&gt;&lt;span&gt;&lt;/span&gt;&lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;script type=\"text/javascript\" src='move.js'&gt;&lt;/script&gt;&lt;script&gt; window.onload = function() &#123; var oBox = document.body.children[0]; var oUl = oBox.children[0]; var aLi = oUl.children; var oOl = oBox.children[1]; var aSpan = oOl.getElementsByTagName('span'); oUl.innerHTML += oUl.innerHTML; oUl.style.width = aLi.length * aLi[0].offsetWidth + 'px'; var iNow = 0; next(); function next() &#123; move(aSpan[iNow % aSpan.length], &#123;width: 40&#125;, &#123;easing: 'ease-out',complete: function()&#123; // 回调函数 iNow++; for(var i = 0; i &lt; aSpan.length; i++) &#123; aSpan[i].style.width = 0; &#125; move2(oUl, -iNow * aLi[0].offsetWidth, function() &#123; !bSin &amp;&amp; next(); &#125;); &#125;&#125;); &#125; var iW = oUl.offsetWidth / 2; var left = 0; var timer = null; function move2(obj, iTarget, complete) &#123; clearInterval(timer); var start = left; var dis = iTarget - start; var count = Math.floor(1000 / 30); var n = 0; timer = setInterval(function() &#123; n++; var a = n / count; var cur = start + dis * a; left = cur; obj.style.left = (left % iW - iW) % iW + 'px'; if(n == count) &#123; clearInterval(timer); complete &amp;&amp; complete(); &#125; &#125;, 30); &#125; var bSin = false; oBox.onmouseover = function() &#123; bSin = true; for(var i = 0; i &lt; aSpan.length; i++) &#123; clearInterval(aSpan[i].timer); aSpan[i].style.width = 0; &#125; &#125; oBox.onmouseout = function() &#123; bSin = false; next(); &#125; &#125;&lt;/script&gt; 效果示例 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"js","slug":"js","permalink":"https://wangchloe.vip/tags/js/"},{"name":"应用","slug":"应用","permalink":"https://wangchloe.vip/tags/应用/"}]},{"title":"每天10个前端知识点：运动框架应用篇(上)","date":"2017-02-01T19:27:35.000Z","path":"2017/02/02/blog11/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 本次内容：仿jiaThis分享到、幻灯片、手风琴、多图片中心展开 1. 仿jiaThis分享到JiaThis - 社会化分享按钮及移动端分享代码提供商！ 1234567891011121314151617181920212223242526272829303132&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; body &#123; overflow: hidden; &#125; #box &#123; position: absolute; right: -140px; top: 50%; margin-top: -75px; padding: 20px; width: 100px; height: 150px; background: rgba(0, 0, 0, .1); color: #fff; font-size: 20px; &#125; #box span &#123; position: absolute; left: -20px; width: 20px; height: 60px; line-height: 20px; background: #fe0; color: #fff; font-size: 12px; text-align: center; &#125;&lt;/style&gt; 123456&lt;div id=\"box\"&gt; &lt;span&gt;分享到&lt;/span&gt; &lt;p&gt;QQ&lt;/p&gt; &lt;p&gt;WeChat&lt;/p&gt; &lt;p&gt;sina&lt;/p&gt;&lt;/div&gt; 123456789101112131415&lt;script type=\"text/javascript\" src='move.js'&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; var oBox = document.getElementById('box'); var oSpan = oBox.children[0]; oBox.onmouseover = function() &#123; move(oBox, &#123;right: 0&#125;, &#123;duration: 300&#125;); &#125; oBox.onmouseout = function() &#123; move(oBox, &#123;right: -140&#125;, &#123;duration: 300&#125;); &#125; &#125;&lt;/script&gt; 效果示例 2. 幻灯片123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; #box &#123; position: relative; margin: 50px auto; width: 400px; height: 300px; overflow: hidden; &#125; ul &#123; position: absolute; top: 0; left: 0; width: 1200px; height: 250px; &#125; ul li &#123; width: 400px; height: 250px; float: left; list-style: none; &#125; ul li img &#123; width: 100%; height: 100%; &#125; ol &#123; position: absolute; left: 50%; bottom: 50px; margin-left: -45px; &#125; ol li &#123; margin: 10px; width: 10px; height: 10px; border-radius: 50%; border: 1px solid #fff; font-size: 8px; text-align: center; line-height: 10px; color: #fff; cursor: pointer; &#125; ol li.active &#123; background: #ccc; &#125;&lt;/style&gt; 123456789101112&lt;div id=\"box\"&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=\"img/slide1.jpg\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/slide2.jpg\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/slide3.jpg\"&gt;&lt;/li&gt; &lt;/ul&gt; &lt;ol&gt; &lt;li class=\"active\"&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;/ol&gt;&lt;/div&gt; 1234567891011121314151617181920212223&lt;script type=\"text/javascript\" src='move.js'&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; var oBox = document.body.children[0]; var oUl = oBox.children[0]; var oOl = oBox.children[1]; var aLi = oUl.children; var aLi2 = oOl.children; for(var i = 0; i &lt; aLi2.length; i++) &#123; aLi2[i].index = i; (function(index) &#123; aLi2[i].onmouseover = function() &#123; for(var i = 0; i &lt; aLi2.length; i++) &#123; aLi2[i].className = ''; &#125; this.className = 'active'; move(oUl, &#123;marginLeft: - this.index * aLi[0].offsetWidth&#125;, &#123;duration: 500&#125;); &#125; &#125;)(i); &#125; &#125;&lt;/script&gt; 效果示例 3. 手风琴123456789101112131415161718192021222324252627&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; #box &#123; position: relative; margin: 50px auto; width: 380px; height: 200px; overflow: hidden; &#125; #box ul &#123; width: 380px; height: 200px; &#125; #box ul li &#123; position: absolute; list-style: none; width: 380px; height: 200px; &#125; #box ul li img&#123; width: 100%; height: 100%; &#125;&lt;/style&gt; 123456789&lt;div id=\"box\"&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=\"img/slide1.jpg\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/slide2.jpg\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/slide3.jpg\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/slide4.jpg\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/slide5.jpg\"&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 1234567891011121314151617181920212223242526&lt;script type=\"text/javascript\" src='move.js'&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; var oBox = document.body.children[0]; var oUl = oBox.children[0]; var aLi = oUl.children; var w = 30; for(var i = 1; i &lt; aLi.length; i++) &#123; aLi[i].style.left = oBox.offsetWidth - (aLi.length - i) * w + 'px'; &#125; for(var i = 0; i &lt; aLi.length; i++) &#123; aLi[i].index = i; aLi[i].onmouseover = function() &#123; for(var i = 0; i &lt; aLi.length; i++) &#123; if(i &lt;= this.index) &#123; move(aLi[i], &#123;left: i * w&#125;); // 小于当前位置往右推 &#125; else &#123; move(aLi[i], &#123;left: oBox.offsetWidth - (aLi.length - i) * w&#125;); // 大于当前位置往左推 &#125; &#125; &#125; &#125; &#125;&lt;/script&gt; 效果示例 4. 多图片展开 这个示例是有问题的，展开的z-index没有调整好，在此求解！ 12345678910111213141516171819202122232425&lt;style&gt; * &#123; margin: 0; padding: 0; &#125; #box &#123; position: relative; margin: 50px auto; width: 660px; &#125; #box ul &#123; width: 660px; &#125; #box ul li &#123; float: left; list-style: none; margin: 10px; width: 200px; height: 100px; &#125; #box ul li img &#123; width: 100%; height: 100%; &#125;&lt;/style&gt; 12345678910111213&lt;div id=\"box\"&gt; &lt;ul&gt; &lt;li&gt;&lt;img src=\"img/slide1.jpg\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/slide2.jpg\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/slide3.jpg\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/slide4.jpg\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/slide5.jpg\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/slide6.jpg\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/slide7.jpg\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/slide8.jpg\"&gt;&lt;/li&gt; &lt;li&gt;&lt;img src=\"img/slide9.jpg\"&gt;&lt;/li&gt; &lt;/ul&gt;&lt;/div&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;script type=\"text/javascript\" src='move.js'&gt;&lt;/script&gt;&lt;script type=\"text/javascript\"&gt; window.onload = function() &#123; var oBox = document.body.children[0]; var oUl = oBox.children[0]; var aLi = oUl.children; var bSin = false; var aPos = []; for(var i = 0; i &lt; aLi.length; i++) &#123; aPos[i] = &#123; left: aLi[i].offsetLeft, top: aLi[i].offsetTop &#125; &#125; //浮动定位 -&gt; 绝对定位 for(var i = 0; i &lt; aLi.length; i++) &#123; aLi[i].style.position = 'absolute'; aLi[i].style.left = aPos[i].left + 'px'; aLi[i].style.top = aPos[i].top + 'px'; aLi[i].style.margin = 0; &#125; //移上中心放大动画 for(var i = 0; i &lt; aLi.length; i++) &#123; aLi[i].index = i; aLi[i].onmouseover = function() &#123; if(bSin) return; bSin = true; for(var i = 0; i &lt; aLi.length; i++) &#123; aLi[i].style.zIndex = 0; &#125; move(this, &#123; width: 600, height: 300, left: 30, top: 30 &#125;); this.style.zIndex = 1; &#125; aLi[i].onmouseout = function() &#123; move(this, &#123; width: 200, height: 100, left: aPos[this.index].left, top: aPos[this.index].top &#125;); bSin = false; // this.style.zIndex = 0; &#125; &#125; &#125;&lt;/script&gt; 这个示例是有问题的，展开的z-index没有调整好，在此求解！ 效果示例 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"js","slug":"js","permalink":"https://wangchloe.vip/tags/js/"},{"name":"应用","slug":"应用","permalink":"https://wangchloe.vip/tags/应用/"}]},{"title":"每天10个前端知识点：原生运动框架","date":"2017-01-31T19:27:35.000Z","path":"2017/02/01/blog10/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 原生js编写运动框架，当然部分特性可用CSS3实现。 move.js 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061&lt;script&gt; function move(obj, json, options) &#123; // 运动物体，&#123;改变的属性及终态&#125;，&#123;总时间，运动形式，链式运动的回调&#125; options = options || &#123;&#125;; options.duration = options.duration || 700; // 默认总时间 [可自定义] options.easing = options.easing || 'linear'; // 默认运动形式 [可自定义] clearInterval(obj.timer); var start = &#123;&#125;; // 起点 var dis = &#123;&#125;; // 总距离 for(var name in json) &#123; start[name] = parseFloat(getStyle(obj, name)); // 字符串转数字，并保留小数(透明度) dis[name] = json[name] - start[name]; &#125; var count = Math.floor(options.duration / 30); // 总次数 30ms 最佳定时器时间 var n = 0; obj.timer = setInterval(function()&#123; // 自定义属性加定时器 n++; for(var name in json) &#123; switch(options.easing) &#123; // 自定义运动形式 case 'linear': var a = n / count; var cur = start[name] + dis[name] * a; // 匀速 break; case 'ease-in': var a = n / count; var cur = start[name] + dis[name] * Math.pow(a, 3); // 加速 a的3次方 [可自定义] break; case 'ease-out': var a = 1 - n / count; var cur = start[name] + dis[name] * (1 - Math.pow(a, 3)); // 减速 [可自定义] break; &#125; if(name == 'opacity') &#123; // 若改变属性为透明度时另作处理 obj.style.opacity = cur; obj.style.filter = 'Alpha(opacity:' + cur * 100 + ')'; &#125; else &#123; obj.style[name] = cur + 'px'; &#125; &#125; if( n == count) &#123; clearInterval(obj.timer); options.complete &amp;&amp; options.complete(); // 链式运动 &#125; &#125;, 30); // 30ms 最佳定时器时间 &#125; function getStyle(obj, name) &#123; return (obj.currentStyle || getComputedStyle(obj, false))[name]; &#125;&lt;/script&gt; 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"js","slug":"js","permalink":"https://wangchloe.vip/tags/js/"}]},{"title":"每天10个前端知识点：事件篇","date":"2017-01-22T19:27:35.000Z","path":"2017/01/23/blog9/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 将事件的冒泡、绑定、捕获、委托及鼠标和键盘的相关事件整理了下。 1. 事件对象 event 事件对象(系统自带)*兼容：Chrome IE系FF -&gt; 报错 ev 事件函数传入参数*兼容：高级浏览器(Chrome、FF、IE9+) IE8- -&gt; undefined 兼容写法：var oEvent = ev || event; 2. 事件冒泡概念：子级的事件会传递给父级。如果父级有相同的事件，会依次从内到外执行，直到相同事件的祖宗节点，否则会继续冒泡。 阻止事件冒泡： 子级事件内添加 oEvent.cancelBubble = true; 3. 事件绑定有效解决事件冲突 obj.addEventListener(事件名, 函数名/函数, 是否捕获); *兼容：高级浏览器 事件名 -&gt; 不能加’on’ 函数名 -&gt; 不能加括号 是否捕获 -&gt; false obj.attachEvent(事件名, 函数名/函数); *兼容：IE10- 事件名 -&gt; 必须加’on’ 函数名 -&gt; 不能加括号 兼容写法 封装一个事件绑定的函数1234567891011&lt;script&gt; function addEvent(obj, sEv, fn) &#123; //对象, 事件(不加on), 函数名/函数 if(obj.addEventListner) &#123; //高级浏览器 -&gt; function 低级 -&gt;undefined //高级浏览器 obj.addEventListener(sEv, fn, false); &#125; else &#123; //低级浏览器 obj.attachEvent('on' + sEv, fn); &#125; &#125;&lt;/script&gt; 4. 关于捕获(这点理解不是很到位)事件冒泡：子级 -&gt; 父级设置捕获：父级 -&gt; 子级 5. 事件解绑 obj.removeEventListener(事件名, 函数名/函数, 是否捕获); *兼容：高级浏览器 注意：函数不能是匿名函数，每个匿名函数都相当于新创建了一个函数。 创建函数 var show = new Function(‘a’,’b’, ‘alert(a + b)’); obj.detachEvent(事件名, 函数名/函数); *兼容：IE10- 兼容写法 封装一个事件解绑的函数1234567891011&lt;script&gt; function removeEvent(obj, sEv, fn) &#123; //对象, 事件(不加on), 函数名/函数 if(obj.removeEventListner) &#123; //高级浏览器 -&gt; function 低级 -&gt;undefined //高级浏览器 obj.removeEventListener(sEv, fn, false); &#125; else &#123; //低级 obj.detachEvent('on' + sEv, fn); &#125; &#125;&lt;/script&gt; 6. 查看鼠标点击位置var oEvent = ev || event; X轴：oEvent.clientX; Y轴：oEvent.clientY; 7. 键盘事件 obj.onkeydown 按下键盘触发 obj.onkeyup 释放键盘触发 obj.oninput 键盘输入时实时触发*兼容：高级浏览器IE9删除时有问题 obj.onpropertychange 键盘输入时实时触发*兼容：IE10-IE9删除时有问题 兼容处理 事件的兼容不需要处理，直接连等 obj.oninput = obj.onpropertychange = function() {} *处理IE9：定时器 封装一个实时统计字数的函数12345678910111213141516171819&lt;script&gt; function calLen(obj1, obj2) &#123; if (window.navigator.userAgent.indexOf('MSIE 9.0') != -1) &#123; //IE9 var timer = null; obj1.onfocus = function() &#123; timer = setInterval(function() &#123; obj2.innerHTML = obj1.value.length; &#125;, 50); &#125;; obj1.onblur = function() &#123; clearInterval(timer); &#125; &#125; else &#123; //能不添加定时器时就不添加 obj1.oninput = obj1.onpropertychange = function() &#123; //高级浏览器、IE10- obj2.innerHTML = obj1.value.length; &#125; &#125; &#125;&lt;/script&gt; 应用：实时统计输入字数 键码 oEvent.keyCode重要 0~9：48~57 a~z：65~90 ctrl：17 delete：46 backspace：8 enter：13 左键：37 上键：38 右键：39 下键：40 组合键(js中键码不能组合使用) ctrl -&gt; ctrlKey shift -&gt; shiftKey alt -&gt; altKey eg:if(oEvent.ctrlKey &amp;&amp; oEvent.shiftKey &amp;&amp; oEvent.keyCode == 65){...} 8. 鼠标事件 obj.oncontextmenu 点击鼠标右键触发(有默认右键菜单行为) 默认行为：点击右键有菜单 文本框能输入内容 点击a标签能跳转等 阻止默认行为：return false; 应用：自定义右键菜单应用：自定义输入框 obj.onmousedown 按下鼠标时触发 obj.onmouseup 抬起鼠标时触发 obj.onmousemove 鼠标移动触发 应用：拖拽应用：拖拽(带框)应用：磁性吸附 obj.onmouseover 鼠标移入时触发 obj.onmouseout 鼠标移出时触发 问题 问题1：移入子级也算重新移入解决1：onmouseover -&gt; onmouseenter 问题2：移出子级也算移出解决2：onmouseout -&gt; onmouseleave obj.onmousewheel 滚动鼠标滚轮触发 *兼容：Chrome IE系 DOMMouseScroll DOM滚轮事件(DOM事件只能通过事件绑定添加) *兼容：FF 兼容写法1234567891011&lt;script&gt; if (window.navigator.userAgent.indexOf('FireFox') != -1) &#123; document.addEventListener('DOMMouseScroll', function() &#123; //FF //scroll code here &#125;, false) &#125; else &#123; document.onmousewheel = function() &#123; //Chrome IE系 //scroll code here &#125; &#125;&lt;/script&gt; 判断滚动方向 oEvent.wheelDelta *兼容：Chrome IE系 向上：120 向下：-120 DOMMouseScroll *兼容：FF 向上：-3 向下：3 兼容写法 封装一个鼠标滚动方向的函数 123456789101112131415161718192021222324252627282930313233343536&lt;script&gt; function addWheel(obj, fn) &#123; //向上fn(false)，向下fn(true) function wheel(ev) &#123; var oEvent = ev || event; // var bDown = true; //默认向下 --&gt; // if(oEvent.wheelDelta) &#123; //FF -&gt; undefined // //Chrome IE系 // bDown = oEvent.wheelDelta &lt; 0; // &#125; else &#123; // //FF // bDown = oEvent.detail &gt; 0; // &#125; var bDown = oEvent.wheelDelta ? oEvent.wheelDelta &lt; 0 : oEvent.detail &gt; 0; //判断是否传入函数，执行回调函数 fn &amp;&amp; fn(bDown); //FF阻止默认 oEvent.preventDefault &amp;&amp; oEvent.preventDefault(); //阻止默认 return false; &#125; if (window.navigator.userAgent.indexOf('FireFox') != -1) &#123; //FF document.addEventListener('DOMMouseScroll', wheel, false); //事件中阻止默认没有用 &#125; else &#123; //Chrome IE系 // document.onmousewheel = wheel; addEvent(obj, 'mousewheel', wheel); &#125; &#125;&lt;/script&gt; oEvent.preventDefault(); 兼容：高级浏览器 IE8- -&gt; undefined 应用：自定义滚动条 9. domReady DOMContentLoaded 当DOM加载完成时触发(在页面前) DOM事件必须通过事件绑定添加*兼容：高级浏览器 onreadystatechange 模拟domReady 兼容写法封装domReady全兼容方法 1234567891011121314151617&lt;script&gt; function domReady(fn) &#123; if (document.addEventListener) &#123; //高级浏览器 document.addEventListener('DOMContentLoaded', function() &#123; fn &amp;&amp; fn(); &#125;, false); &#125; else &#123; //低级浏览器 模拟domReady document.onreadystatechange = function() &#123; if (document.readyState == 'complete') &#123; // 全兼容 fn &amp;&amp; fn(); &#125; &#125; &#125; &#125;&lt;/script&gt; 10. 事件委托概念：子级自己的事件可以委托给父级处理 好处： (1)提高性能 (2)可以给未来的子元素添加事件 11. 事件源 oEvent.target*兼容：高级浏览器低级浏览器 -&gt; undefined oEvent.srcElement*兼容：Chrome、IE系FF -&gt; undefined 兼容写法var oSrc = oEvent.srcElement || oEvent.target; 注意：oSrc.tagName获取到的标签名都是大写 ###给子级循环添加事件 闭包的替代写法 -&gt; 委托123456789&lt;script&gt; oUl.onclick = function(ev) &#123; var oEvent = ev || event; var oSrc = oEvent.scrElement || oEvent.target; if (oSrc.tagName == 'LI') &#123; // **注意获取到的标签名都是大写 this.style.background = '#f00'; &#125; &#125;&lt;/script&gt; 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"js","slug":"js","permalink":"https://wangchloe.vip/tags/js/"}]},{"title":"每天10个前端知识点：各种宽高距离篇","date":"2017-01-19T19:27:35.000Z","path":"2017/01/20/blog8/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 这几个宽高距离总是让我辨别不清，索性整合对比了下，方便记忆。 1. 滚动距离html简写：document.documentElement document.body.scrollTop 兼容：Chrome 其他 -&gt; 0 document.documentElement.scrollTop 兼容：IE、FF 其他 -&gt; 0 兼容写法纵向：var scrollT = document.documentElement.scrollTop || document.body.scrollTop;横向：var scrollL = document.documentElement.scrollLeft || document.body.scrollLeft; 2. 滚动高度obj.scrollHeight 内容高度 &gt; 盒模型高度 取内容高度 盒模型高度 &gt; 内容高度 去盒模型高度 3. 可视区高度 可视区高度：var clientH = document.documentElement.clientHeight; 可视区宽度：var clientW = document.documentElement.clientWidth; 兼容：全兼容 4. 物体高度获取的是盒模型大小 = width/height + padding + border; 物体的高度：var oH = obj.offsetHeight; 物体的宽度：var oW = obj.offsetWidth; 注意：offsetWidth/height只有append进body后才有，创建时获取不到盒模型的大小。 5. offsetHeight &amp;&amp; getStyle() offsetHeight getStyle() 返回值 数字 字符串 获取值 获取的是盒模型的大小(width/height+padding+border) 获取的是纯width/height display:none后 0 仍可以获取 6. 物体的相对距离 物体距离定位父级左边距离：var oL = obj.offsetLeft; 物体距离定位父级上边距离：var oT = obj.offsetTop; 7. 关于父级 结构父级 obj.parentNode 根：document 定位父级 obj.offsetParent 根：body 8. 封装一个物体距离左边/上边的绝对位置的函数12345678910111213&lt;script&gt; function getPos(obj) &#123; var l = 0; // 距离左边的绝对距离 var t = 0; // 距离上边的绝对距离 while(obj) &#123; l += obj.offsetLeft; t += obj.offsetTop; obj = obj.offsetParent; // 继续查找上一层定位父级 &#125; return &#123;left: l, top: t&#125;; &#125;&lt;/script&gt; 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"js","slug":"js","permalink":"https://wangchloe.vip/tags/js/"}]},{"title":"每天10个前端知识点：js组成篇","date":"2017-01-17T19:27:35.000Z","path":"2017/01/18/blog7/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 本次内容有关js的三大组成。 1. js实现的组成ECMAECMAScript(js核心) 提供核心语言功能 *兼容：完全兼容eg:if(){} arr.pop(); DOMDocument Object Model 文档对象模型 提供访问和操作网页内容的方法和接口 DOM是针对XML但经过扩展用于HTML的应用程序接口(API)。 *兼容：大部分兼容，不兼容可以作兼容处理eg:document.getElementById(&#39;id&#39;) oDiv.style.background = &#39;red&#39;; BOMBrowser Object Model 浏览器对象模型 提供与浏览器交互的方法和接口 *兼容：根据使用浏览器来，根本不兼容，且不能作兼容处理eg:window.navigator.userAgent alert(); 2. DOM节点关系 父子节点 子节点：父节点.children; (一级，一层) 父节点：子节点.parentNode; 兄弟节点 上一个兄弟节点： obj.perviousElementSibling; *兼容：高级浏览器 obj.previousSibling *兼容：全兼容 高级浏览器 -&gt; object text 低级浏览器 -&gt; 能获取相应的节点 兼容写法 var oPrev = obj.previousElementSibling || obj.previousSibling; 下一个兄弟节点 obj.nextElementSibling *兼容：高级浏览器 obj.nextSibling *兼容：全兼容 高级浏览器 -&gt; object text 低级浏览器 -&gt; 能获取相应的节点 兼容写法 var oNext = obj.nextElementSibling || obj.nextSibling; 首尾节点 首节点 父节点.firstElementChild *兼容：高级浏览器 低级浏览器 -&gt; undefined 父节点.firstChild *兼容：全兼容 高级浏览器 -&gt; object text 低级浏览器 -&gt; 能获取相应的节点 兼容写法 (1) 父节点.fisrtElementChild || 父节点.firstChild (2) 父节点.children[0] 尾节点 父节点.lastElementChild *兼容：高级浏览器 低级浏览器 -&gt; undefined 父节点.lastChild *兼容：全兼容 高级浏览器 -&gt; object text 低级浏览器 -&gt; 能获取相应的节点 兼容写法 (1) 父节点.lastElementChild || 父节点.lastChild (2) 父节点.children[父节点.children.length - 1] 3. DOM节点操作 创建一个节点 var obj = document.createElement(‘tagName’); 添加一个节点 父节点.appendChild(要添加的节点); 父节点.insertBefore(要添加的节点, 在谁前面添加); 删除一个节点 父节点.removeChild(要删除的节点); 替换一个节点 父节点.replaceChild(新节点, 删除的节点); 4. DOM属性操作 . [] 可操作自定义属性 获取属性 obj.getAttribute(属性的名字); 设置属性 obj.setAttribute(属性的名字, 值); 删除属性 obj.removeAttribute(属性的名字); 获取设置属性方法尽量不混用 5. BOM window.open(地址, 方式); 打开新窗口 返回值：新的窗体对象Chrome：拦截 FF：阻止 IE：直接打开 *：用户自己打开的都不拦截 打开方式：(1) _blank 新窗口打开(默认) (2) _self 当前页面打开 about:blank 空白页 window.close(); 关闭当前窗口Chrome：直接关闭 FF：没有反应 IE：提示 *：只能关闭自己open出来的窗口 window.location 获取地址栏信息 返回值数据类型：object window.location.href 获取地址栏信息返回值数据类型：string window.location.search 获取地址栏信息中的数据返回值：?(包括?)后面的值 window.location.hash 获取地址栏信息中的锚点返回值：#(包括#)后面的值 window.location.protocol 获取地址栏信息中的协议返回值：eg: http: window.location.host 获取地址栏信息中的域名返回值：eg：localhost:8080 baidu.com window.location.port 获取地址栏信息中的端口返回值：eg：8080 window.location.pathname 获取地址栏信息中的路径返回值：eg：/../../xxx.html window.history 获取地址的历史信息 window.history.forward() 前进 window.history.back() 后退 window.history.go(数字)前进时数字&gt;0 -&gt; 1代表前进1个页面后退时数字 -1代表后退1个页面 window.location.reload(); 强制刷新页面 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"js","slug":"js","permalink":"https://wangchloe.vip/tags/js/"}]},{"title":"每天10个前端知识点：原生篇(5)","date":"2017-01-15T19:04:50.000Z","path":"2017/01/16/blog6/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 本次内容是一些比较零散的知识点，有坑慎入，踩坑快乐！ 1. select下拉框的相关属性 选中的索引值oSel.selectedIndex 获取所有选项oSel.options 获取选中的选项的文本内容oSel.options[oSel.selectedIndex].innerHTMLoSel.options[oSel.selectedIndex].text 添加选项var option = new Option(文本内容, value值);oSel.options.add(option); 删除选项oSel.options.remove(index); 2. 预解析变量和函数的定义会预先解析，解析在当前script标签内的最上面 作用域：(1)script (2)函数 12345678910111213&lt;script&gt; var a = 111; function show() &#123; alert(a); var a = 12; // 相当于 // var a; // alert(a); //undefined // a = 12; &#125; show(); // undefined alert(a); // 111&lt;/script&gt; 3. 已知计算机编码查看对应单词String.fromCharCode(‘0x4e00’); // 对应中文 “一” 第一个中文 0x4e00 一 最后一个中文 0x9fa5 龥(yu) unicode编码：以\\u开头 \\u4e00(一) ~ \\u9fa5(龥) 4. 字节长度和编码的关系英文、数组都占1个字节，与编码格式无关UTF-8；中文占3个字节GB2312：中文占2个字节 封装一个求字节长度的函数123456789101112131415161718&lt;script&gt; function getBytesLen(str, type) &#123; // 字符串，编码格式 var result = 0; type = type.toLowerCase(); for (var i = 0; i &lt; str.length; i++) &#123; if(str.charAt(i) &gt;= '\\u4e00' &amp;&amp; str.charAt(i) &lt;= '\\u9fa5') &#123; if(type == 'gb2312') &#123; result += 2; &#125; else &#123; result += 3; &#125; &#125; else &#123; result++; &#125; &#125; return result; &#125;&lt;/script&gt; 5. 严格模式非严格模式下，没有用var定义变量时为全局变量，全局的东西都属于window12345678&lt;script&gt; function show()&#123; a = 12; //a没有var时a为全局变量 alert(a); //1. 12 &#125; show(); //需先调用show函数 alert(a); //2. 12&lt;/script&gt; 严格模式 在script标签内最上面写&#39;use strict&#39;; IE6不识别但不报错 &#39;use strict&#39;;好处： 修复局部this的问题 不允许if/while/for里面定义函数 去掉了with(){} 定义变量必须加var 作用域：(1)当前script标签内 (2)函数 (3)js文件 坑12345678910111213&lt;script&gt; var a = 5; if(a % 2) &#123; function show() &#123; alert('单数'); &#125; &#125; else &#123; function show() &#123; alert('双数'); &#125; &#125; show(); // 单数 最新版高级浏览器中预解析不会覆盖，之前版本预解析后此例预解析覆盖 弹出双数&lt;/script&gt; 1234567891011121314&lt;script&gt; 'use strict'; var a = 5; if(a % 2) &#123; function show() &#123; alert('单数'); &#125; &#125; else &#123; function show() &#123; alert('双数'); &#125; &#125; show(); // show is not defined，严格模式不允许if/for里面定义函数&lt;/script&gt; 6. 连等及逗号运算符连等函数内部使用连等定义变量，第一个是局部变量，其余是全局变量。 12345&lt;script&gt; function show()&#123; var a=b=c=1; //a是局部变量，b、c是全局变量 &#125;&lt;/script&gt; 逗号运算符逗号运算符 以最后一个为准 12345678&lt;script&gt; var a=(1,2,3); // a=3 for(var i=0, j=5, k=8; i&lt;10, j&lt;10, k&lt;10; i++, j++, k++) &#123; &#125; alert(i+j+k); // 2+7+10=19&lt;/script&gt; 7. 文本提示框聚焦事件：oT.onfocus = function() {};失焦事件：oT.onblur = function() {}; 强制获取一个焦点：oT.focus();强制失去一个焦点：oT.blur(); 8. form表单想要提交数据须有 action 提交的地址 &lt;form action=&#39;&#39;&gt;&lt;/form&gt; name 数据名称 &lt;input name=&quot;user.tel&quot; /&gt; value 数据 input.value 提交方式 get(默认) 容量32K左右 不安全，有缓存 好处：(1)分享 (2)收藏 post 容量1G左右 相对安全，没有缓存 缓存(cache)对于浏览器而言，相同的地址只会访问一次 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"js","slug":"js","permalink":"https://wangchloe.vip/tags/js/"}]},{"title":"每天10个前端知识点：数组应用篇","date":"2017-01-14T19:27:35.000Z","path":"2017/01/15/blog5/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 本次内容总结了个人遇到的部分数组应用，其中不乏前端笔试高频考点。 1. 数组翻转方法2eg:这里说明一下，这个方法用的不是reverse，因为一次面试中被问过不用reverse实现翻转，所以这里标注为数组的翻转方法2。123456789&lt;script&gt; var arr=[1,2,3,4]; var arr2=[]; while(arr.length) &#123; var num=arr.pop(); arr2.push(num); &#125; alert(arr2);&lt;/script&gt; 2. 首字母大写eg:1234567891011121314151617&lt;script&gt; var str = 'welcome to china'; var arr = str.split(' '); var arr2 = []; for(var i = 0; i &lt; arr.length; i++) &#123; var first = arr[i].charAt(0).toUpperCase(); var other = arr[i].substring(1); arr2.push(first + other); &#125; alert(arr2.join(' ')); //正则写法 var str2 = str.replace(/\\w+/g, function(s) &#123; return s.charAt(0).toUpperCase().substring(); &#125;) alert(str2);&lt;/script&gt; 3.快速清空数组 length=0; arr=[]; arr.splice(0,arr.length); 循环pop或shift 4. 数组排序方法更多方法见后续排序算法篇 123456789101112131415161718192021&lt;script&gt; function findMinIndex(arr, start) &#123; var iMin = arr[start]; var iMinIndex = start; for(var i = start + 1; i &lt; arr.length; i++) &#123; if(iMin &gt; arr[i]) &#123; iMin = arr[i]; iMinIndex = i; &#125; &#125; return iMinIndex; &#125; for(var i = 0; i &lt; arr.length; i++) &#123; var iMinIndex = findMinIndex(arr, i); var temp; temp = arr[iMinIndex]; arr[iMinIndex] = arr[i]; arr[i] = temp; &#125;&lt;/script&gt; 5. 数组内查找元素是否存在1234567891011&lt;script&gt; function findInArr(item, arr) &#123; for(var i = 0; i &lt; arr.length; i++) &#123; if(item == arr[i]) &#123; return true; &#125; else &#123; return false; &#125; &#125; &#125;&lt;/script&gt; 6. 数组去重的多种方法(1)findInArr1234567891011121314151617181920&lt;script&gt; var arr2 = []; for(var i = 0; i &lt; arr.length; i++) &#123; if(!findInArr(arr[i], arr2)) &#123; arr2.push(arr[i]); &#125; &#125; // 数组内查找元素是否存在 function findInArr(item, arr) &#123; for(var i = 0; i &lt; arr.length; i++) &#123; if(item == arr[i]) &#123; return true; &#125; else &#123; return false; &#125; &#125; &#125;&lt;/script&gt; (2)json(自动从小到大排序)123456789101112&lt;script&gt; var json = &#123;&#125;; var arr2 = []; for(var i = 0; i &lt; arr.length; i++) &#123; json[arr[i]] = 'xxx'; &#125; for(var name in json) &#123; arr2.push(name); &#125;&lt;/script&gt; 摘自也谈JavaScript数组去重 1234567891011121314&lt;script&gt; function unique(arr) &#123; var ret = []; var len = arr.length; var tmp = &#123;&#125;; for(var i=0; i&lt;len; i++)&#123; if(!tmp[arr[i]])&#123; tmp[arr[i]] = 1; ret.push(arr[i]); &#125; &#125; return ret;&#125;&lt;/script&gt; (3)sort()123456789&lt;script&gt; arr.sort(); for(var i = 0; i &lt; arr.length; i++) &#123; if(arr[i] == arr[i+1]) &#123; arr.splice(i, 1); i--; &#125; &#125;&lt;/script&gt; (4) indexOf这个方法是在前端公众号偶然看到的，数组的indexOf方法第一次用到 1234567&lt;script&gt; for(var i = 0; i &lt; arr.length; i++) &#123; if(arr2.indexOf(arr[i]) &lt; 0) &#123; arr2.push(arr[i]); &#125; &#125;&lt;/script&gt; (5)二分法1234567891011121314151617181920212223242526272829303132333435&lt;script&gt; var arr = [1, 2, 3, 2, 4, 3, 1, 5, 7, 2, 5]; // 数组内查找元素是否存在 function findInArr(item, arr) &#123; for(var i = 0; i &lt; arr.length; i++) &#123; if(item == arr[i]) &#123; return true; &#125; &#125; return false; &#125; function del(arr, s, e) &#123; if(s &gt; e) &#123; return []; &#125; else if(s == e) &#123; return [arr[s]]; &#125; var c = Math.floor((s + e) / 2); var l = del(arr, s, c); var r = del(arr, c + 1, e); for(var i = 0; i &lt; r.length; i++) &#123; if(!findInArr(r[i], l)) &#123; l.push(r[i]); &#125; &#125; return l; &#125; console.log(del(arr, 0 , arr.length - 1));&lt;/script&gt; (6)Map(ES6)摘自也谈JavaScript数组去重 Map的存取使用单独的get()、set()接口。 123456789101112131415&lt;script&gt;function unique(arr) &#123; var ret = []; var len = arr.length; var tmp = new Map(); for(var i=0; i&lt;len; i++)&#123; if(!tmp.get(arr[i]))&#123; tmp.set(arr[i], 1); ret.push(arr[i]); &#125; &#125; return ret;&#125;&lt;/script&gt; (7)Set(ES6)摘自也谈JavaScript数组去重 Set不允许重复元素出现。 123456&lt;script&gt;function unique(arr)&#123; var set = new Set(arr); return Array.from(set);&#125;&lt;/script&gt; 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"js","slug":"js","permalink":"https://wangchloe.vip/tags/js/"},{"name":"应用","slug":"应用","permalink":"https://wangchloe.vip/tags/应用/"}]},{"title":"每天10个前端知识点：原生篇(4)","date":"2017-01-13T18:51:22.000Z","path":"2017/01/14/blog4/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 本次内容主要关于字符串、数组及Math的常用方法。 1. 参数的数组arguments参数中的数组，函数中可以不需要定义参数1234567&lt;script&gt; sum(12, 5, 6); function sum() &#123; console.log(arguments[1]); // 5 &#125;&lt;/script&gt; 2. 设置样式的三种方法 style.xxxoDiv.style.width = ‘300px’; classNameoDiv.className = ‘active’; cssText批量设置样式oDiv.style.cssText = ‘width: 300px; height: 300px’; 3. 字符串的相关方法 str.charAt(i); 获取字符串中的第i+1个字符 返回值：相应位置的字符 str[i]的兼容问题获取字符串中的第i+1个 str[i] 兼容：高级浏览器及IE8+IE7 -&gt; undefined str.charAt(i) 全兼容 str.indexOf(‘w’); 查找w在字符串中的位置 返回值：成功 -&gt; w在字符串中的位置 失败 -&gt; -1 从左往右找 区分大小写 找到第一个相同值即停止 查找多个字符时，返回第一个字符的位置 str.lastIndexOf(‘w’); 查找w在字符串中的位置 返回值：成功 -&gt; w在字符串中的位置 失败 -&gt; -1 从右往左倒序查找，返回的索引值与indexOf()规则相同 str.search(‘w’); 与indexOf()规则相同 常用于正则 str.substring(开始位置, 结束位置); 截取字符串，包含开始位置，不包含结束位置 str.substring(开始位置); 截取字符串 从开始位置一直截取到最后 str.substr(开始位置, 截取字符串长度); 定长截取字符串 str.slice(开始位置, 结束位置); 截取字符串 str.match(‘w’); 在字符串中匹配w 常用于正则 返回值：成功 -&gt; 匹配的w 失败 -&gt; null str.split(‘w’); 切割字符串 返回值类型：数组 字符串按w割开，去掉w后组成的数组 若没找到w则原样返回一个长度为1的数组 若为’’(空字符串，无空格)则返回将str中每个字符逐个拆开的数组 str.toUpperCase(); str转大写 str.toLowerCase(); str转小写 str.replace(‘xxx’, ‘yyy’); 常用于正则 参数：被替换内容,替换内容 修改第一个被替换内容 替换不修改原字符串, 需重新声明 第二个参数可为一个方法 replace可以连用 12345678910&lt;script&gt; var str = 'xxa'; str.replace('x','y'); str2 = str.replace('a', 'b'); str3 = str.replace('x', 'y').replace('a', 'b'); alert(str); // xxa alert(str.replace('x', 'y')); // yxa alert(str2); //xxb alert(str3); //yxb&lt;/script&gt; 12345678910111213&lt;script&gt; var str = 'xxxy'; var str2 = str.replace('xxx', function(s)&#123; alert(s); // xxx 被替换字符 数据类型：string var str2 = ''; for(var i = 0; i &lt; s.length; i++) &#123; str2 += '*'; &#125; return str2; // 替换后的内容 &#125;); alert(str2); // ***y&lt;/script&gt; str.charCodeAt(i); // 获取字符串中的第i+1个字符对应的ASCII编码 a-&gt; 0x61 -&gt; 97b-&gt; 0x62 -&gt; 98z -&gt; 0x7A -&gt; 122 4. 字符串比较 英文 按照字典序(a~z)依次比较，z为最大；从两字符串的第一个字符开始，若相当再比较下一个字符 数字 按照数字大小依次；从两字符串的第一个字符开始，若相当再比较下一个字符 汉字 按照unicode大小比较 5. 字符串应用判断浏览器的类型window.navigator.userAgenteg:1234567891011&lt;script&gt; if(window.navigator.userAgent.indexOf('Chrome') != -1) &#123; console.log('Chrome'); &#125; else if(window.navigator.userAgent.indexOf('Firefox') != -1) &#123; console.log('Firefox'); &#125; else if(window.navigator.userAgent.indexOf('MSIE7.0') != -1) &#123; consolle.log('IE7'); &#125; else &#123; console.log('others'); &#125;&lt;/script&gt; 判断上传文件格式eg:1234&lt;script&gt; var index = str.lastIndexOf('.'); var type = str.substring(index+1); //返回文件类型名&lt;/script&gt; 6. 定义数组 var arr = [1, 2, 3]; var arr = new Array(1, 2, 3); Array()只传一个参数时表示定义一个新数组的长度new Array(10); 定义一个长度为10的数组 7. 数组的相关方法 arr.push(‘w’); 往数组最后面添加一项 返回值：新添加的那项 arr.unshift(‘w’); 往数组最前面添加一项 返回值：新数组长度 arr.pop(); 删除数组最后一项 返回值：删除的那项 arr.shift(); 删除数组最前一项 返回值：删除的那项 arr.join(‘w’); 数组各项用w连接成一个字符串 返回值类型：字符串 arr.concat(arr2, arr3, …); 数组arr与arr2、arr3…连接 arr.reverse(); 数组翻转 arr.sort(); 数组排序(按字典序和数字序列) 高级排序 数值排序 从小到大arr.sort(function(n1, n2){ return n1-n2;}); 从大到小arr.sort(function(n1, n2){ return n2-n1;}); arr.splice(开始位置, 删除个数, 元素1, 元素2); 12345678910&lt;script&gt; var arr1=[1,2,3,4]; arr1.splice(1, 0, 'a', 'b'); //添加：在1后添加'a','b' 返回值：返回空数组 var arr2=[1,2,3,4]; arr2.splice(1, 2); //删除：删除2、3 返回值：返回删除的各项 var arr3=[1,2,3,4]; arr3.splice(1, 1, 8, 88, 888) //修改：先删除再添加 把2改为8,88,888 返回值：返回删除的各项&lt;/script&gt; splice模拟方法1) arr.push(c); -&gt; arr.splice(arr.length, 0, c);2）arr.unshift(c); -&gt; arr.splice(0, 0, c);3）arr.pop(); -&gt; arr.splice(arr.length-1, 1);4）arr.shift(); -&gt; arr.splice(0, 1); 8. json(object类型)json格式：{name:value,name2:value2, …}json标准格式：{“name”:value, “name2”:value2, …} 所有键名需双引号,键值非数字时需加引号键值对没有json.lengthjson的name是唯一的 获取json值: json.name 或者 json[‘name’] 添加/修改: json.aaa = ‘bbb’; 或者 json[‘aaa’] = ‘bbb’; 删除: delete json.c; 或者 delete json[‘c’]; 判断json内某个属性是否存在 1234&lt;script&gt; var json = &#123;a: 1, b: 2&#125;; alert('c' in json); // false 属性c不存在&lt;/script&gt; json和数组的区别length 数组：有length json：没有length 循环遍历方法 数组：for(var i=0;i&lt;arr.length;i++){alert(arr[i])}; for循环 json：for(var name in json){alert(json[name])}; for in循环 访问元素下标类型 数组：arr[1] 数字 json：json[‘a’] 字符串 顺序 数组：有序，根据下标访问 json：无序，根据键名访问 9. Math方法 Math.random() 0-1随机数（不包含1） Math.abs(num) 绝对值 Math.max(num1, num2, ...) 最大数 Math.min(num1, num2, ...) 最小数 Math.floor(num) 向下取整 12.4 -&gt; 12 12.6 -&gt; 12 Math.ceil(num) 向上取整 12.5 -&gt; 13 12.1 -&gt; 13 Math.pow(n, m) n的m次方 Math.pow(2, 3)=8; Math.sqrt(num) num开平方 Math.sqrt(9)=3; Math.round(num) 四舍五入 12.1 -&gt; 12 12.6 -&gt; 13 num.toFixed(保留小数个数); 保留几位小数(自动四舍五入) 10. try-catch捕获异常12345678910&lt;script&gt; try &#123; // code &#125; catch(ex) &#123; // exception console.log(ex.message); // 查看错误信息 // 错误的提示信息 // 补救的代码 &#125;&lt;/script&gt; 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"js","slug":"js","permalink":"https://wangchloe.vip/tags/js/"}]},{"title":"每天10个前端知识点：原生篇(3)","date":"2017-01-12T18:51:22.000Z","path":"2017/01/13/blog3/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 本次内容主要关于js函数返回值、定时器、日期(Date)对象、this以及闭包。 1. 返回值问题(return) return语句后面的代码不执行 函数若没有写return，则默认返回undefined 函数返回语句为return; 也返回undefined return必须写在函数function内 2. undefined出现的情况 函数没有返回值或只有return; 定义了一个变量，但没有赋值 eg:12345&lt;script&gt; var a; // undefined function show(a) &#123;&#125; show(); // undefined`&lt;/script&gt; 访问不存在的属性 eg: oDiv.aaa; // undefined 3. eval(字符串) 虽然这个不建议使用，但还是聊聊这个东西是怎么用的吧 eval能把字符串里面的代码转换成js能理解的程序，把引号中的拿出来运行 1234&lt;script&gt; var a = '[1, 2, 3]'; //字符串 alert(eval(a)); // 1, 2, 3 '[1, 2, 3]' -&gt; [1, 2, 3]&lt;/script&gt; 4. 数字小于10的补零函数123456789&lt;script&gt; function toTen(num) &#123; if(num &lt; 10) &#123; return '0' + num; &#125; else &#123; return '' + num; // 函数的返回类型最好保持一致 &#125; &#125;&lt;/script&gt; 简化12345&lt;script&gt; function toTen(num) &#123; return num &lt; 10 ? '0' + num : '' + num; &#125;&lt;/script&gt; 5. 定时器(1) Interval(每过一段时间执行一次，循环执行) 开启定时器setInterval(函数/函数名, 时间); 时间单位是毫秒 关闭定时器clearInterval(定时器的名字); interval的问题 1.时间不能设置太小的值 eg:设置0其实会超出01234567&lt;script&gt; var a = 6; setTimeout(function()&#123; a = 66; &#125;,0); alert(a); //6&lt;/script&gt; 2.时间值越小越不稳定 3.打开其他窗口时，该窗口定时器时间会变长 *定时器的最佳时间：30ms (时间过小，程序性能开销大) (2) Timeout(过一段时间执行一次，只执行一次) 开启定时器setTimeout(函数/函数名, 时间); 时间单位是毫秒 关闭定时器clearTimeout(定时器的名字); 123456789101112131415&lt;script&gt; // 定时器先关后开 var bSin = false; var timer = setInterval(function() &#123; if(bSin) &#123; return; &#125; bSin = true; &#125;, 30); function clear() &#123; clearInterval(timer); bSin = false; &#125;&lt;/script&gt; 6. 日期对象1234567891011121314&lt;script&gt; // 获取时间 var oDate = new Date(); oDate.getFullYear(); // 获取年 oDate.getMonth(); // 获取月，从0开始，获取+1，设置-1 !important oDate.getDate(); // 获取日 oDate.getDay(); // 获取星期，星期天 -&gt; 0，星期一 ~ 星期六 -&gt; 1 ~ 6 oDate.getHours(); // 获取小时，记得加s，下同 !important oDate.getMinutes(); // 获取分钟 oDate.getSeconds(); // 获取秒 oDate.getMillseconds(); // 获取毫秒 oDate.getTime(); // 时间戳 当前时间距离1970/1/1凌晨的毫秒数&lt;/script&gt; 123456789&lt;script&gt; // 设置时间 var oDate = new Date(); oDate.setFulllYear(2017, 11, 13); // 设置年、月、日 月份设置时-1 oDate.setHours(0, 0, 0, 0); // 设置时、分、秒、毫秒 // 获得时间戳 oDate.getTime(); // 设置后的时间距离1970/1/1凌晨的毫秒数&lt;/script&gt; 7. 日期对象应用 oDate.setDate(31); // 假设本月有30天会跑到下个月的第一天 会自动进位oDate.setDate(0); // 会跑到上个月的最后一天 本月有多少天1234567&lt;script&gt; var oDate = new Date(); oDate.setMonth(oDate.getMonth() + 1); // 当前月份+1 oDate.setDate(0); // setDate(0); alert(oDate.getDate());&lt;/script&gt; 本月第一天是周几12345&lt;script&gt; var oDate = new Date(); oDate.setDate(1); // setDate(1); alert(oDate.getDay());&lt;/script&gt; 本月最后一天是周几123456&lt;script&gt; var oDate = new Date(); oDate.setMonth(oDate.getMonth()+1); // 当前月份+1 oDate.setDate(0); // setDate(0); alert(oDate.getDay());&lt;/script&gt; 8. 事件函数相同可以合并eg: oDiv1.onmouseout = oDiv2.onmouseout = function() {}; 9. thisthis: 当前方法属于谁，this就是谁this默认属于window 定时器里的this不能直接使用，原因：this指向了window (1) 定时器中的this不指向元素，指向window解决：在定时器外保存this12345678&lt;script&gt;oBtn.onclick = function() &#123; var _this = this; setTimeout(function()&#123; _this.style.background = '#f00'; &#125;,1000);&#125;&lt;/script&gt; (2) 调用封装函数使用this，this不指向元素，指向window(3) 低级浏览器attachEvent)事件绑定里面的this 报错10. 闭包用处： 解决变量名冲突 解决循环添加事件，事件中的循环变量不能用的问题 123456789101112131415&lt;script&gt; function clickEg() &#123; //获取一组按钮 ps:js一组元素不能一起改变样式或设置事件 var aBtn = document.getElementsByTagName('button'); for(var i = 0; i &lt; 3; i++) &#123; aBtn[i].onclick = function() &#123; //循环中的i变量此时已自增至3 //aBtn[i].style.background = '#f00'; //当前事件发生的对象 aBtn[i]为this this.style.background = 'f00'; &#125; &#125; &#125;&lt;/script&gt; 闭包写法： 12345678910111213&lt;script&gt; function clickEg() &#123; //获取一组按钮 ps:js一组元素不能一起改变样式或设置事件 var aBtn = document.getElementsByTagName('button'); for(var i = 0; i &lt; 3; i++) &#123; (function(index) &#123; aBtn[i].onclick = function() &#123; aBtn[index].style.background = 'f00'; &#125; &#125;)(i); &#125; &#125;&lt;/script&gt; 1234567&lt;script&gt; for(var i=0; i&lt;2; i++) &#123; setTimeout(function()&#123; alert(i); &#125;, 2000); &#125; // 结果：两秒后alert两次2，两秒后i已为2，然后执行两次循环&lt;/script&gt; 闭包写法： 123456789&lt;script&gt; for(var i=0; i&lt;2; i++) &#123; (function(a)&#123; setTimeout(function()&#123; alert(a); &#125;,2000); &#125;)(i); &#125; // 结果：两秒后alert 0、1&lt;/script&gt; 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"js","slug":"js","permalink":"https://wangchloe.vip/tags/js/"}]},{"title":"每天10个前端知识点：原生篇(2)","date":"2017-01-12T13:00:28.000Z","path":"2017/01/12/blog2/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 本次内容主要关于js事件基础以及DOM操作元素。 1. js操作元素属性 . 属性操作符(不可以接收变量) [] 中括号可以操作属性也可以接收变量 12345678&lt;script&gt; function setValue() &#123; //省略获取元素oBtn, oBtn2的伪代码 oBtn.value = 'bbb'; oBtn2['value'] = 'bbb'; &#125;&lt;/script&gt; 凡是. 出现的地方都可以用中括号替代 2. js设置复杂样式 非首单词的首字母大写并去掉-符 12345&lt;style&gt; .complex &#123; margin-left: 10px; &#125;&lt;/style&gt; 123456&lt;script&gt; function setStyle() &#123; var oC = document.getElementsByClassName('complex')[0]; oC.style.marginLeft = '10px'; &#125;&lt;/script&gt; 3. 物体从中心放大 margin-top: -变化的高度/2 margin-left: -变化的宽度/2 4. a链接防止刷新1&lt;a href=\"#\"&gt;点击会刷新页面&lt;/a&gt; 12&lt;a href=&quot;javascript:;&quot;&gt;点击不会刷新页面！(推荐使用)&lt;/a&gt;&lt;!-- javascript:;相当于一个伪协议 --&gt; 5. 循环添加事件，事件中的循环变量不能用123456789101112131415&lt;script&gt; function clickEg() &#123; //获取一组按钮 ps:js一组元素不能一起改变样式或设置事件 var aBtn = document.getElementsByTagName('button'); for(var i = 0; i &lt; 3; i++) &#123; aBtn[i].onclick = function() &#123; //循环中的i变量此时已自增至3 //aBtn[i].style.background = '#f00'; //当前事件发生的对象 aBtn[i]为this this.style.background = 'f00'; &#125; &#125; &#125;&lt;/script&gt; 6. 浏览器加载的过程1.加载整个页面的标签和属性2.过滤不符合W3C标准的标签和属性(高级浏览器)3.执行js -&gt; window.onload 7. DOM获取元素方法1.document.getElementById(‘id’);2.document/obj.getElementsByTagName(‘TagName’);3.document/obj.getElementsByClassName(‘ClassName’);兼容：Chrome、FF、IE9+ obj.getElementsByClassName 高级浏览器 -&gt; function IE8- -&gt; undefined兼容写法1234567891011121314151617&lt;script&gt; function getByClass(obj, sClass) &#123; // obj为从哪个父级下面查找类为sClass的元素 if(obj.getElementsByClassName) &#123; // IE8- -&gt; undefined 高级浏览器 -&gt; function return obj.getElementsByClassName(sClass); // 高级浏览器 &#125; else &#123; // IE8 var aEle = document.getElementsByTagName('*'); var arr = []; for(var i=0; i&lt;aEle.length; i++)&#123; var temp = aEle[i].className.split(' '); if(findInArr(sClass, temp)) &#123; arr.push(aEle[i]); &#125; &#125; return arr; &#125; &#125;&lt;/script&gt; getElementById只能从document下获取 var oDiv = document.getElementById(‘id’); getElementsByTagName/getElementsByClassName可以从document下获取，也可以从父级下获取 var oDiv2 = document.getElementsByClassName(‘ClassName’)[0]; var oDiv3 = oBox.getElementsByTagName(‘TagName’)[0]; 8. js中的真假 真：非0数字，非空字符串，true，非空对象 假：0，空字符串(‘’)，false，空对象(null)，undefined，NaN 9. 获取元素当前样式(兼容)123456789101112&lt;script&gt; function getStyle(obj, name)&#123; //元素，样式名称 if(obj.currentStyle) &#123; // Chrome、FF -&gt; undefined IE -&gt; object // IE系 return obj.currentStyle[name]; // 兼容IE系 &#125; else &#123; // Chrome、FF return getComputedStyle(obj, false)[name]; // 兼容高级浏览器(Chrome、FF、IE9+) &#125; &#125;&lt;/script&gt; 简化12345678&lt;script&gt; function getStyle(obj, name)&#123; //元素，样式名称 return (obj.currentStyle || getComputedStyle(obj, false))[name]; &#125; // 调用 console.log(parseInt(getStyle(oDiv, 'heihgt')));&lt;/script&gt; 10. 获取一个n~m之间的随机数(n&lt;m，且不包括m)12345&lt;script&gt; function rnd(n, m) &#123; return parseInt(Math.random() * (m - n) + n); &#125;&lt;/script&gt; 应用：随机变色 1234&lt;script&gt; // rgb色值范围[0, 255] oDiv.style.background = 'rgb(' + rnd(0, 256) + ',' + rnd(0, 256) + ',' + rnd(0, 256) + ')';&lt;/script&gt; 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"js","slug":"js","permalink":"https://wangchloe.vip/tags/js/"}]},{"title":"每天10个前端知识点：原生篇(1)","date":"2017-01-10T19:27:35.000Z","path":"2017/01/11/blog1/","text":"以下内容若有问题烦请即时告知我予以修改，以免误导更多人。 本次内容主要关于js数据类型及变量命名。 1. js六大数据类型 null并非typeof出来的类型，不过由于null不可再分，所以将其归于基本数据类型之中。 typeof类型：undefined、boolean、string、number、object、function 以下是根据ECMAScript标准的数据类型分类 基本数据类型 Number 数字 String 字符串 Boolean 布尔 Undefined 未定义 Null 空对象 Symbol 独一无二的值(ES6新增) 复杂数据类型 Object 对象(可拆分为多种数据类型) 2. 数据类型补充 null空对象 -&gt; 数据类型(object) NaN 非数字 -&gt; 数据类型(number) NaN和任何数据类型都不相等，包括自己 3. 数字相关判断方法 是否是数字isNaN() 非数字-&gt;true 数字-&gt;false 是否是整数if(num == parseInt(num)) 4. 变量 全局变量 局部变量 闭包 子函数可以使用父函数的全局变量 变量的遮蔽 全局变量和局部变量同名 就近原则-&gt;在函数里优先使用自己的变量 5. 运算符 算术运算符 比较运算符== -&gt; != === -&gt; !== 赋值运算符 逻辑运算符 6. 常见变量命名前缀 前缀 全称 含义 示例 o object 一个对象，一个元素 oDiv a array 一组元素 aLi s string 字符串 sUserName i integer 整数 iCount f float 浮点数 fPrice b boolean 布尔 bOk fn function 函数 fnSucc re RegExp 正则 reMailCheck 7. 字符串转化为数字parseInt() 从左往右开始找，找到第一个非数字(包含小数点)就停止，如果第一个数不是数字，则返回NaN eg: ‘12.5’ -&gt; 12 ‘12abc’ -&gt; 12 ‘abc’ -&gt; NaN parseFloat() 从左往右开始找，找到第一个非数字(不包含小数点)就停止，如果第一个数不是数字，则返回NaN eg: ‘12.5’ -&gt; 12.5 ‘12abc’ -&gt; 12 ‘abc’ -&gt; NaN Number() 既能处理整数，也能处理小数，但只能处理数字 eg: ‘12.5’ -&gt; 12.5 ‘12’ -&gt; 12 ‘12abc’ -&gt; NaN ‘abc’ -&gt; NaN 8. 数字转化为字符串number + ‘’ eg：12 + ‘’ -&gt; ‘12’ 9. if语句变形 条件 &amp;&amp; 语句; (条件为真时执行) 条件 || 语句; (条件为假时执行) 三目运算 条件? 语句1: 语句2; 10. js及事件的笼统概念 js：修改样式 事件：用户的操作 任何标签都可以添加事件，任何属性都可以修改 更多内容可以订阅本人微信公众号，一起开启前端小白进阶的世界！","tags":[{"name":"js","slug":"js","permalink":"https://wangchloe.vip/tags/js/"}]}]